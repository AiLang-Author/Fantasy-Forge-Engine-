// ============================================
// Library.Shop.ailang
// Shop & Trading System
// ============================================
//
// DATA-DRIVEN SHOP SYSTEM
// All shops defined in /data/shops.dnddat
//
// FILE FORMAT (shops.dnddat):
//   SHOP,id,name,buy_rate,sell_rate,map_id,x,y
//   STOCK,shop_id,item_id,quantity,restock_rate
//
// buy_rate: % of item value to charge (100 = full price)
// sell_rate: % of item value when selling (50 = half price)
// restock_rate: 0=never, 1-100=chance per day
//
// ============================================

LibraryImport.TUI
LibraryImport.Item

// ============================================
// CONSTANTS
// ============================================

FixedPool.Shop_Limits {
    "MAX_SHOPS": Initialize=20
    "MAX_STOCK": Initialize=30      
    "NAME_LEN": Initialize=32
}

// ============================================
// SHOP STRUCTURE (64 bytes)
// ============================================
// 0-31:  Name (32 bytes)
// 32:    ID (1 byte)
// 33:    Buy rate % (1 byte)
// 34:    Sell rate % (1 byte)
// 35:    Map ID (1 byte)
// 36-37: X position (2 bytes)
// 38-39: Y position (2 bytes)
// 40:    Stock count (1 byte)
// 41:    Shop type (1 byte) - 1=general, 2=weapon, 3=armor, 4=magic
// 42-63: Reserved

FixedPool.Shop_Offsets {
    "NAME": Initialize=0
    "ID": Initialize=32
    "BUY_RATE": Initialize=33
    "SELL_RATE": Initialize=34
    "MAP_ID": Initialize=35
    "X": Initialize=36
    "Y": Initialize=38
    "STOCK_COUNT": Initialize=40
    "TYPE": Initialize=41
    "SIZE": Initialize=64
}

// Shop types
FixedPool.Shop_Types {
    "GENERAL": Initialize=1
    "WEAPON": Initialize=2
    "ARMOR": Initialize=3
    "MAGIC": Initialize=4
    "INN": Initialize=5
}

// ============================================
// STOCK ENTRY (4 bytes)
// ============================================
// 0-1: Item ID (2 bytes)
// 2:   Quantity (1 byte, 255=unlimited)
// 3:   Restock rate (1 byte)

FixedPool.Stock_Offsets {
    "ITEM_ID": Initialize=0
    "QUANTITY": Initialize=2
    "RESTOCK": Initialize=3
    "SIZE": Initialize=4
}

// ============================================
// GLOBAL STATE
// ============================================

FixedPool.Shop_State {
    "shops": Initialize=0
    "shop_count": Initialize=0
    "stock": Initialize=0           
    "initialized": Initialize=0
}

// Current shop interaction
FixedPool.Shop_Current {
    "shop_id": Initialize=0
    "cursor": Initialize=0
    "mode": Initialize=0            
    "scroll": Initialize=0
    "running": Initialize=0
}

// ============================================
// INITIALIZATION
// ============================================

Function.Shop_Init {
    Body: {
        // Allocate shop definitions
        shops_size = Multiply(Shop_Limits.MAX_SHOPS, Shop_Offsets.SIZE)
        Shop_State.shops = Allocate(shops_size)
        Shop_State.shop_count = 0
        
        // Clear
        i = 0
        WhileLoop LessThan(i, shops_size) {
            SetByte(Shop_State.shops, i, 0)
            i = Add(i, 1)
        }
        
        // Allocate stock (MAX_SHOPS * MAX_STOCK * 4 bytes)
        stock_size = Multiply(Multiply(Shop_Limits.MAX_SHOPS, Shop_Limits.MAX_STOCK), Stock_Offsets.SIZE)
        Shop_State.stock = Allocate(stock_size)
        
        i = 0
        WhileLoop LessThan(i, stock_size) {
            SetByte(Shop_State.stock, i, 0)
            i = Add(i, 1)
        }
        
        Shop_State.initialized = 1
        ReturnValue(0)
    }
}

Function.Shop_Cleanup {
    Body: {
        IfCondition NotEqual(Shop_State.shops, 0) ThenBlock: {
            shops_size = Multiply(Shop_Limits.MAX_SHOPS, Shop_Offsets.SIZE)
            Deallocate(Shop_State.shops, shops_size)
        }
        IfCondition NotEqual(Shop_State.stock, 0) ThenBlock: {
            stock_size = Multiply(Multiply(Shop_Limits.MAX_SHOPS, Shop_Limits.MAX_STOCK), Stock_Offsets.SIZE)
            Deallocate(Shop_State.stock, stock_size)
        }
        ReturnValue(0)
    }
}

// ============================================
// SHOP REGISTRATION
// ============================================

Function.Shop_Register {
    Input: id: Integer
    Input: name: Address
    Input: buy_rate: Integer
    Input: sell_rate: Integer
    Input: map_id: Integer
    Input: x: Integer
    Input: y: Integer
    Input: shop_type: Integer
    Output: Integer
    Body: {
        IfCondition GreaterEqual(id, Shop_Limits.MAX_SHOPS) ThenBlock: {
            ReturnValue(-1)
        }
        
        offset = Multiply(id, Shop_Offsets.SIZE)
        base = Add(Shop_State.shops, offset)
        
        // Copy name
        i = 0
        WhileLoop LessThan(i, 31) {
            ch = GetByte(name, i)
            SetByte(base, i, ch)
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            i = Add(i, 1)
        }
        SetByte(base, 31, 0)
        
        SetByte(base, Shop_Offsets.ID, id)
        SetByte(base, Shop_Offsets.BUY_RATE, buy_rate)
        SetByte(base, Shop_Offsets.SELL_RATE, sell_rate)
        SetByte(base, Shop_Offsets.MAP_ID, map_id)
        SetByte(base, Shop_Offsets.X, BitwiseAnd(x, 255))
        SetByte(base, Add(Shop_Offsets.X, 1), RightShift(x, 8))
        SetByte(base, Shop_Offsets.Y, BitwiseAnd(y, 255))
        SetByte(base, Add(Shop_Offsets.Y, 1), RightShift(y, 8))
        SetByte(base, Shop_Offsets.STOCK_COUNT, 0)
        SetByte(base, Shop_Offsets.TYPE, shop_type)
        
        IfCondition GreaterEqual(id, Shop_State.shop_count) ThenBlock: {
            Shop_State.shop_count = Add(id, 1)
        }
        
        ReturnValue(id)
    }
}

Function.Shop_AddStock {
    Input: shop_id: Integer
    Input: item_id: Integer
    Input: quantity: Integer
    Input: restock_rate: Integer
    Output: Integer
    Body: {
        // Get shop
        shop_offset = Multiply(shop_id, Shop_Offsets.SIZE)
        shop_base = Add(Shop_State.shops, shop_offset)
        stock_count = GetByte(shop_base, Shop_Offsets.STOCK_COUNT)
        
        IfCondition GreaterEqual(stock_count, Shop_Limits.MAX_STOCK) ThenBlock: {
            ReturnValue(-1)
        }
        
        // Get stock array for this shop
        stock_base_offset = Multiply(shop_id, Multiply(Shop_Limits.MAX_STOCK, Stock_Offsets.SIZE))
        stock_entry_offset = Multiply(stock_count, Stock_Offsets.SIZE)
        stock_addr = Add(Shop_State.stock, Add(stock_base_offset, stock_entry_offset))
        
        SetByte(stock_addr, Stock_Offsets.ITEM_ID, BitwiseAnd(item_id, 255))
        SetByte(stock_addr, Add(Stock_Offsets.ITEM_ID, 1), RightShift(item_id, 8))
        SetByte(stock_addr, Stock_Offsets.QUANTITY, quantity)
        SetByte(stock_addr, Stock_Offsets.RESTOCK, restock_rate)
        
        SetByte(shop_base, Shop_Offsets.STOCK_COUNT, Add(stock_count, 1))
        
        ReturnValue(stock_count)
    }
}

// ============================================
// SHOP LOOKUP
// ============================================

Function.Shop_GetAtPosition {
    Input: map_id: Integer
    Input: x: Integer
    Input: y: Integer
    Output: Integer
    Body: {
        i = 0
        WhileLoop LessThan(i, Shop_State.shop_count) {
            offset = Multiply(i, Shop_Offsets.SIZE)
            base = Add(Shop_State.shops, offset)
            
            s_map = GetByte(base, Shop_Offsets.MAP_ID)
            s_x = Add(GetByte(base, Shop_Offsets.X), Multiply(GetByte(base, Add(Shop_Offsets.X, 1)), 256))
            s_y = Add(GetByte(base, Shop_Offsets.Y), Multiply(GetByte(base, Add(Shop_Offsets.Y, 1)), 256))
            
            IfCondition And(EqualTo(s_map, map_id), And(EqualTo(s_x, x), EqualTo(s_y, y))) ThenBlock: {
                ReturnValue(i)
            }
            
            i = Add(i, 1)
        }
        ReturnValue(-1)
    }
}

Function.Shop_GetName {
    Input: shop_id: Integer
    Output: Address
    Body: {
        offset = Multiply(shop_id, Shop_Offsets.SIZE)
        base = Add(Shop_State.shops, offset)
        ReturnValue(base)
    }
}

Function.Shop_GetBuyRate {
    Input: shop_id: Integer
    Output: Integer
    Body: {
        offset = Multiply(shop_id, Shop_Offsets.SIZE)
        base = Add(Shop_State.shops, offset)
        ReturnValue(GetByte(base, Shop_Offsets.BUY_RATE))
    }
}

Function.Shop_GetSellRate {
    Input: shop_id: Integer
    Output: Integer
    Body: {
        offset = Multiply(shop_id, Shop_Offsets.SIZE)
        base = Add(Shop_State.shops, offset)
        ReturnValue(GetByte(base, Shop_Offsets.SELL_RATE))
    }
}

Function.Shop_GetStockCount {
    Input: shop_id: Integer
    Output: Integer
    Body: {
        offset = Multiply(shop_id, Shop_Offsets.SIZE)
        base = Add(Shop_State.shops, offset)
        ReturnValue(GetByte(base, Shop_Offsets.STOCK_COUNT))
    }
}

Function.Shop_GetStockItem {
    Input: shop_id: Integer
    Input: stock_idx: Integer
    Output: Integer
    Body: {
        stock_base_offset = Multiply(shop_id, Multiply(Shop_Limits.MAX_STOCK, Stock_Offsets.SIZE))
        stock_entry_offset = Multiply(stock_idx, Stock_Offsets.SIZE)
        stock_addr = Add(Shop_State.stock, Add(stock_base_offset, stock_entry_offset))
        
        item_id = Add(GetByte(stock_addr, 0), Multiply(GetByte(stock_addr, 1), 256))
        ReturnValue(item_id)
    }
}

Function.Shop_GetStockQty {
    Input: shop_id: Integer
    Input: stock_idx: Integer
    Output: Integer
    Body: {
        stock_base_offset = Multiply(shop_id, Multiply(Shop_Limits.MAX_STOCK, Stock_Offsets.SIZE))
        stock_entry_offset = Multiply(stock_idx, Stock_Offsets.SIZE)
        stock_addr = Add(Shop_State.stock, Add(stock_base_offset, stock_entry_offset))
        
        ReturnValue(GetByte(stock_addr, Stock_Offsets.QUANTITY))
    }
}

// ============================================
// PRICE CALCULATIONS
// ============================================

Function.Shop_GetBuyPrice {
    Input: shop_id: Integer
    Input: item_id: Integer
    Output: Integer
    Body: {
        base_value = Item_GetValue(item_id)
        buy_rate = Shop_GetBuyRate(shop_id)
        
        price = Divide(Multiply(base_value, buy_rate), 100)
        IfCondition LessThan(price, 1) ThenBlock: {
            price = 1
        }
        
        ReturnValue(price)
    }
}

Function.Shop_GetSellPrice {
    Input: shop_id: Integer
    Input: item_id: Integer
    Output: Integer
    Body: {
        base_value = Item_GetValue(item_id)
        sell_rate = Shop_GetSellRate(shop_id)
        
        price = Divide(Multiply(base_value, sell_rate), 100)
        // Minimum 1 gold for any item
        IfCondition LessThan(price, 1) ThenBlock: {
            price = 1
        }
        
        ReturnValue(price)
    }
}

// ============================================
// TRANSACTIONS
// ============================================

Function.Shop_Buy {
    Input: shop_id: Integer
    Input: stock_idx: Integer
    Input: player_gold: Address
    Output: Integer
    Body: {
        item_id = Shop_GetStockItem(shop_id, stock_idx)
        qty = Shop_GetStockQty(shop_id, stock_idx)
        
        // Check stock
        IfCondition And(NotEqual(qty, 255), EqualTo(qty, 0)) ThenBlock: {
            ReturnValue(-1)  // Out of stock
        }
        
        price = Shop_GetBuyPrice(shop_id, item_id)
        gold = Dereference(player_gold)
        
        // Check gold
        IfCondition LessThan(gold, price) ThenBlock: {
            ReturnValue(-2)  // Can't afford
        }
        
        // Check inventory space
        result = Item_InvAdd(item_id, 1)
        IfCondition LessThan(result, 0) ThenBlock: {
            ReturnValue(-3)  // Inventory full
        }
        
        // Deduct gold
        new_gold = Subtract(gold, price)
        StoreValue(player_gold, new_gold)
        
        // Reduce stock (if not unlimited)
        IfCondition NotEqual(qty, 255) ThenBlock: {
            stock_base_offset = Multiply(shop_id, Multiply(Shop_Limits.MAX_STOCK, Stock_Offsets.SIZE))
            stock_entry_offset = Multiply(stock_idx, Stock_Offsets.SIZE)
            stock_addr = Add(Shop_State.stock, Add(stock_base_offset, stock_entry_offset))
            SetByte(stock_addr, Stock_Offsets.QUANTITY, Subtract(qty, 1))
        }
        
        ReturnValue(price)
    }
}

Function.Shop_Sell {
    Input: shop_id: Integer
    Input: inv_idx: Integer
    Input: player_gold: Address
    Output: Integer
    Body: {
        item_id = Item_InvGetItemId(inv_idx)
        IfCondition EqualTo(item_id, 0) ThenBlock: {
            ReturnValue(-1)  // No item
        }
        
        price = Shop_GetSellPrice(shop_id, item_id)
        
        // Remove from inventory
        Item_InvRemove(inv_idx, 1)
        
        // Add gold
        gold = Dereference(player_gold)
        new_gold = Add(gold, price)
        StoreValue(player_gold, new_gold)
        
        ReturnValue(price)
    }
}


Function.Shop_GetType {
    Input: shop_id: Integer
    Output: Integer
    Body: {
        offset = Multiply(shop_id, Shop_Offsets.SIZE)
        base = Add(Shop_State.shops, offset)
        ReturnValue(GetByte(base, Shop_Offsets.TYPE))
    }
}

// ============================================
// SHOP UI
// ============================================

Function.Shop_Open {
    Input: shop_id: Integer
    Input: player_gold: Address
    Output: Integer
    Body: {
        Shop_Current.shop_id = shop_id
        Shop_Current.cursor = 0
        Shop_Current.mode = 0
        Shop_Current.scroll = 0
        Shop_Current.running = 1
        
        WhileLoop EqualTo(Shop_Current.running, 1) {
            Shop_Draw(player_gold)
            TUI_Refresh()
            
            key = TUI_GetKey()
            Shop_HandleInput(key, player_gold)
        }
        
        ReturnValue(0)
    }
}

Function.Shop_Draw {
    Input: player_gold: Address
    Body: {
        TUI_Clear()
        
        shop_id = Shop_Current.shop_id
        shop_name = Shop_GetName(shop_id)
        
        // Header
        TUI_MoveTo(1, 2)
        TUI_Bold()
        TUI_SetFG(3)
        TUI_Print("=== ")
        TUI_Print(shop_name)
        TUI_Print(" ===")
        TUI_ResetColor()
        
        // Gold display
        TUI_MoveTo(1, 50)
        TUI_SetFG(3)
        TUI_Print("Gold: ")
        gold = Dereference(player_gold)
        TUI_PrintNum(gold)
        TUI_ResetColor()
        
        // Mode tabs
        TUI_MoveTo(3, 2)
        IfCondition EqualTo(Shop_Current.mode, 0) ThenBlock: {
            TUI_Reverse()
            TUI_Print("[ BUY ]")
            TUI_ResetColor()
            TUI_Print("  ")
            TUI_Dim()
            TUI_Print("[ SELL ]")
            TUI_ResetColor()
        } ElseBlock: {
            TUI_Dim()
            TUI_Print("[ BUY ]")
            TUI_ResetColor()
            TUI_Print("  ")
            TUI_Reverse()
            TUI_Print("[ SELL ]")
            TUI_ResetColor()
        }
        
        // Draw items
        IfCondition EqualTo(Shop_Current.mode, 0) ThenBlock: {
            Shop_DrawBuyList(player_gold)
        } ElseBlock: {
            Shop_DrawSellList(player_gold)
        }
        
        // Help
        TUI_MoveTo(22, 2)
        TUI_Dim()
        TUI_Print("Up/Down: Select  Tab: Buy/Sell  Enter: Purchase  ESC: Exit")
        TUI_ResetColor()
        
        ReturnValue(0)
    }
}

Function.Shop_DrawBuyList {
    Input: player_gold: Address
    Body: {
        shop_id = Shop_Current.shop_id
        stock_count = Shop_GetStockCount(shop_id)
        gold = Dereference(player_gold)
        
        IfCondition EqualTo(stock_count, 0) ThenBlock: {
            TUI_MoveTo(6, 4)
            TUI_Dim()
            TUI_Print("(Nothing for sale)")
            TUI_ResetColor()
            ReturnValue(0)
        }
        
        // Column headers
        TUI_MoveTo(5, 4)
        TUI_Dim()
        TUI_Print("Item                    Price   Stock")
        TUI_ResetColor()
        
        max_display = 12
        i = 0
        WhileLoop LessThan(i, max_display) {
            idx = Add(Shop_Current.scroll, i)
            IfCondition GreaterEqual(idx, stock_count) ThenBlock: {
                BreakLoop
            }
            
            row = Add(6, i)
            TUI_MoveTo(row, 4)
            
            // Highlight selection
            IfCondition EqualTo(Shop_Current.cursor, idx) ThenBlock: {
                TUI_Reverse()
            }
            
            item_id = Shop_GetStockItem(shop_id, idx)
            qty = Shop_GetStockQty(shop_id, idx)
            price = Shop_GetBuyPrice(shop_id, item_id)
            
            // Item name with rarity color
            rarity = Item_GetRarity(item_id)
            TUI_SetFG(Item_GetRarityColor(rarity))
            item_name = Item_GetName(item_id)
            TUI_Print(item_name)
            TUI_ResetColor()
            
            // Pad to price column
            TUI_MoveTo(row, 28)
            
            // Price (red if can't afford)
            IfCondition LessThan(gold, price) ThenBlock: {
                TUI_SetFG(1)
            } ElseBlock: {
                TUI_SetFG(3)
            }
            TUI_PrintNum(price)
            TUI_Print("g")
            TUI_ResetColor()
            
            // Stock
            TUI_MoveTo(row, 38)
            IfCondition EqualTo(qty, 255) ThenBlock: {
                TUI_Print("--")
            } ElseBlock: {
                IfCondition EqualTo(qty, 0) ThenBlock: {
                    TUI_SetFG(1)
                    TUI_Print("SOLD")
                    TUI_ResetColor()
                } ElseBlock: {
                    TUI_PrintNum(qty)
                }
            }
            
            TUI_ResetColor()
            i = Add(i, 1)
        }
        
        ReturnValue(0)
    }
}

Function.Shop_DrawSellList {
    Input: player_gold: Address
    Body: {
        shop_id = Shop_Current.shop_id
        inv_count = Item_InvCount()
        
        IfCondition EqualTo(inv_count, 0) ThenBlock: {
            TUI_MoveTo(6, 4)
            TUI_Dim()
            TUI_Print("(Nothing to sell)")
            TUI_ResetColor()
            ReturnValue(0)
        }
        
        // Column headers
        TUI_MoveTo(5, 4)
        TUI_Dim()
        TUI_Print("Item                    Sell For")
        TUI_ResetColor()
        
        max_display = 12
        i = 0
        WhileLoop LessThan(i, max_display) {
            idx = Add(Shop_Current.scroll, i)
            IfCondition GreaterEqual(idx, inv_count) ThenBlock: {
                BreakLoop
            }
            
            row = Add(6, i)
            TUI_MoveTo(row, 4)
            
            IfCondition EqualTo(Shop_Current.cursor, idx) ThenBlock: {
                TUI_Reverse()
            }
            
            item_id = Item_InvGetItemId(idx)
            qty = Item_InvGetQuantity(idx)
            price = Shop_GetSellPrice(shop_id, item_id)
            
            rarity = Item_GetRarity(item_id)
            TUI_SetFG(Item_GetRarityColor(rarity))
            item_name = Item_GetName(item_id)
            TUI_Print(item_name)
            TUI_ResetColor()
            
            IfCondition GreaterThan(qty, 1) ThenBlock: {
                TUI_Print(" x")
                TUI_PrintNum(qty)
            }
            
            TUI_MoveTo(row, 28)
            TUI_SetFG(3)
            TUI_PrintNum(price)
            TUI_Print("g")
            TUI_ResetColor()
            
            TUI_ResetColor()
            i = Add(i, 1)
        }
        
        ReturnValue(0)
    }
}

Function.Shop_HandleInput {
    Input: key: Integer
    Input: player_gold: Address
    Body: {
        // Exit
        IfCondition EqualTo(key, TUI_Keys.KEY_ESC) ThenBlock: {
            Shop_Current.running = 0
            ReturnValue(0)
        }
        IfCondition EqualTo(key, 113) ThenBlock: {  // q
            Shop_Current.running = 0
            ReturnValue(0)
        }
        
        // Tab to switch mode
        IfCondition EqualTo(key, TUI_Keys.KEY_TAB) ThenBlock: {
            IfCondition EqualTo(Shop_Current.mode, 0) ThenBlock: {
                Shop_Current.mode = 1
            } ElseBlock: {
                Shop_Current.mode = 0
            }
            Shop_Current.cursor = 0
            Shop_Current.scroll = 0
            ReturnValue(0)
        }
        
        // Get max items for current mode
        IfCondition EqualTo(Shop_Current.mode, 0) ThenBlock: {
            max_items = Shop_GetStockCount(Shop_Current.shop_id)
        } ElseBlock: {
            max_items = Item_InvCount()
        }
        
        // Navigation
        IfCondition EqualTo(key, TUI_Keys.KEY_UP) ThenBlock: {
            IfCondition GreaterThan(Shop_Current.cursor, 0) ThenBlock: {
                Shop_Current.cursor = Subtract(Shop_Current.cursor, 1)
                IfCondition LessThan(Shop_Current.cursor, Shop_Current.scroll) ThenBlock: {
                    Shop_Current.scroll = Shop_Current.cursor
                }
            }
            ReturnValue(0)
        }
        IfCondition EqualTo(key, TUI_Keys.KEY_DOWN) ThenBlock: {
            IfCondition LessThan(Shop_Current.cursor, Subtract(max_items, 1)) ThenBlock: {
                Shop_Current.cursor = Add(Shop_Current.cursor, 1)
                IfCondition GreaterThan(Shop_Current.cursor, Add(Shop_Current.scroll, 11)) ThenBlock: {
                    Shop_Current.scroll = Subtract(Shop_Current.cursor, 11)
                }
            }
            ReturnValue(0)
        }
        
        // Purchase/Sell
        IfCondition EqualTo(key, TUI_Keys.KEY_ENTER) ThenBlock: {
            IfCondition EqualTo(Shop_Current.mode, 0) ThenBlock: {
                result = Shop_Buy(Shop_Current.shop_id, Shop_Current.cursor, player_gold)
            } ElseBlock: {
                result = Shop_Sell(Shop_Current.shop_id, Shop_Current.cursor, player_gold)
                // Adjust cursor if needed
                new_count = Item_InvCount()
                IfCondition GreaterEqual(Shop_Current.cursor, new_count) ThenBlock: {
                    Shop_Current.cursor = Subtract(new_count, 1)
                    IfCondition LessThan(Shop_Current.cursor, 0) ThenBlock: {
                        Shop_Current.cursor = 0
                    }
                }
            }
            ReturnValue(0)
        }
        
        ReturnValue(0)
    }
}

// ============================================
// DEFAULT SHOPS
// ============================================

Function.Shop_RegisterDefaults {
    Body: {
        // Shop 0: Hometown General Store
        Shop_Register(0, "General Store", 120, 50, 1, 14, 4, Shop_Types.GENERAL)
        Shop_AddStock(0, 60, 10, 50)   // Health Potion
        Shop_AddStock(0, 61, 10, 50)   // Mana Potion
        Shop_AddStock(0, 63, 5, 30)    // Antidote
        Shop_AddStock(0, 80, 255, 0)   // Bread (unlimited)
        Shop_AddStock(0, 70, 3, 10)    // Rusty Key
        
        // Shop 1: Hometown Weapon Shop
        Shop_Register(1, "Weapon Smithy", 100, 40, 1, 4, 4, Shop_Types.WEAPON)
        Shop_AddStock(1, 1, 255, 0)    // Rusty Sword
        Shop_AddStock(1, 2, 5, 20)     // Iron Sword
        Shop_AddStock(1, 5, 10, 50)    // Dagger
        Shop_AddStock(1, 6, 3, 10)     // Battle Axe
        Shop_AddStock(1, 8, 5, 30)     // Mace
        
        // Shop 2: Hometown Armor Shop
        Shop_Register(2, "Armory", 100, 40, 1, 8, 4, Shop_Types.ARMOR)
        Shop_AddStock(2, 10, 255, 0)   // Cloth Tunic
        Shop_AddStock(2, 11, 5, 30)    // Leather Armor
        Shop_AddStock(2, 20, 10, 50)   // Wooden Shield
        Shop_AddStock(2, 21, 3, 20)    // Iron Shield
        Shop_AddStock(2, 30, 10, 50)   // Leather Cap
        
        // Shop 3: Castle Magic Shop
        Shop_Register(3, "Court Wizard", 150, 60, 4, 5, 5, Shop_Types.MAGIC)
        Shop_AddStock(3, 7, 3, 10)     // Staff
        Shop_AddStock(3, 14, 2, 5)     // Mage Robes
        Shop_AddStock(3, 32, 2, 5)     // Wizard Hat
        Shop_AddStock(3, 61, 20, 80)   // Mana Potion
        Shop_AddStock(3, 62, 5, 20)    // Elixir
        
        ReturnValue(0)
    }
}

// ============================================
// FILE LOADING (shops.dnddat)
// ============================================

Function.Shop_LoadFromFile {
    Input: filename: Address
    Output: Integer
    Body: {
        fd = SystemCall(2, filename, 0, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(-1)
        }
        
        buffer = Allocate(4096)
        bytes = SystemCall(0, fd, buffer, 4096)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes, 0) ThenBlock: {
            Deallocate(buffer, 4096)
            ReturnValue(-1)
        }
        
        count = Shop_ParseFile(buffer, bytes)
        
        Deallocate(buffer, 4096)
        ReturnValue(count)
    }
}

Function.Shop_ParseFile {
    Input: buffer: Address
    Input: length: Integer
    Output: Integer
    Body: {
        count = 0
        pos = 0
        line_start = 0
        
        // Skip header line
        WhileLoop LessThan(pos, length) {
            ch = GetByte(buffer, pos)
            IfCondition EqualTo(ch, 10) ThenBlock: {
                pos = Add(pos, 1)
                line_start = pos
                BreakLoop
            }
            pos = Add(pos, 1)
        }
        
        // Parse each line
        WhileLoop LessThan(pos, length) {
            ch = GetByte(buffer, pos)
            
            IfCondition EqualTo(ch, 10) ThenBlock: {
                IfCondition GreaterThan(pos, line_start) ThenBlock: {
                    // Check line type
                    first = GetByte(buffer, line_start)
                    IfCondition EqualTo(first, 83) ThenBlock: {  // 'S' - SHOP or STOCK
                        second = GetByte(buffer, Add(line_start, 1))
                        IfCondition EqualTo(second, 72) ThenBlock: {  // 'H' - SHOP
                            Shop_ParseShopLine(buffer, line_start, pos)
                            count = Add(count, 1)
                        }
                        IfCondition EqualTo(second, 84) ThenBlock: {  // 'T' - STOCK
                            Shop_ParseStockLine(buffer, line_start, pos)
                        }
                    }
                }
                pos = Add(pos, 1)
                line_start = pos
            } ElseBlock: {
                pos = Add(pos, 1)
            }
        }
        
        ReturnValue(count)
    }
}

// Stub functions for parsing - similar to other CSV parsing
Function.Shop_ParseShopLine {
    Input: buffer: Address
    Input: start: Integer
    Input: end: Integer
    Body: {
        // Parse: SHOP,id,name,buy_rate,sell_rate,map_id,x,y,type
        // Implementation similar to other CSV parsers
        ReturnValue(0)
    }
}

Function.Shop_ParseStockLine {
    Input: buffer: Address
    Input: start: Integer
    Input: end: Integer
    Body: {
        // Parse: STOCK,shop_id,item_id,quantity,restock_rate
        ReturnValue(0)
    }
}