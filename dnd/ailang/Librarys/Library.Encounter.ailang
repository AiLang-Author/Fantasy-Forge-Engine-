// ============================================
// Library.Encounter.ailang
// Random Encounter System
// ============================================
//
// Dragon Warrior style random battles:
//   - Encounter rate per terrain/map
//   - Monster groups by area
//   - Level-scaled encounters
//
// DATA FORMAT (encounters.dnddat):
//   ZONE,id,name,map_id,min_x,min_y,max_x,max_y,rate
//   GROUP,zone_id,monster_id,min_count,max_count,weight
//
// rate: 1-100 (% chance per step)
// weight: relative probability of this group
//
// ============================================

LibraryImport.DICE

// ============================================
// CONSTANTS
// ============================================

FixedPool.Enc_Limits {
    "MAX_ZONES": Initialize=30
    "MAX_GROUPS": Initialize=10     // Groups per zone
    "MAX_BATTLE_MONSTERS": Initialize=6
}

// ============================================
// ENCOUNTER ZONE (32 bytes)
// ============================================
// 0-15:  Name (16 bytes)
// 16:    ID (1 byte)
// 17:    Map ID (1 byte)
// 18-19: Min X (2 bytes)
// 20-21: Min Y (2 bytes)
// 22-23: Max X (2 bytes)
// 24-25: Max Y (2 bytes)
// 26:    Encounter rate % (1 byte)
// 27:    Group count (1 byte)
// 28:    Min player level (1 byte)
// 29:    Flags (1 byte)
// 30-31: Reserved

FixedPool.Zone_Offsets {
    "NAME": Initialize=0
    "ID": Initialize=16
    "MAP_ID": Initialize=17
    "MIN_X": Initialize=18
    "MIN_Y": Initialize=20
    "MAX_X": Initialize=22
    "MAX_Y": Initialize=24
    "RATE": Initialize=26
    "GROUP_COUNT": Initialize=27
    "MIN_LEVEL": Initialize=28
    "FLAGS": Initialize=29
    "SIZE": Initialize=32
}

// Zone flags
FixedPool.Zone_Flags {
    "DISABLED": Initialize=1
    "BOSS_ZONE": Initialize=2
    "NO_ESCAPE": Initialize=4
}

// ============================================
// MONSTER GROUP (8 bytes)
// ============================================
// 0:     Monster ID (1 byte)
// 1:     Min count (1 byte)
// 2:     Max count (1 byte)
// 3:     Weight (1 byte)
// 4-7:   Reserved

FixedPool.Group_Offsets {
    "MONSTER_ID": Initialize=0
    "MIN_COUNT": Initialize=1
    "MAX_COUNT": Initialize=2
    "WEIGHT": Initialize=3
    "SIZE": Initialize=8
}

// ============================================
// BATTLE STATE
// ============================================

FixedPool.Enc_Battle {
    "active": Initialize=0
    "monster_ids": Initialize=0     // Array of monster IDs in battle
    "monster_hps": Initialize=0     // Array of current HPs
    "monster_count": Initialize=0
    "can_escape": Initialize=1
    "zone_id": Initialize=0
}

// ============================================
// GLOBAL STATE
// ============================================

FixedPool.Enc_State {
    "zones": Initialize=0
    "zone_count": Initialize=0
    "groups": Initialize=0         
    "steps_since_battle": Initialize=0
    "initialized": Initialize=0
}

// ============================================
// INITIALIZATION
// ============================================

Function.Enc_Init {
    Body: {
        zones_size = Multiply(Enc_Limits.MAX_ZONES, Zone_Offsets.SIZE)
        Enc_State.zones = Allocate(zones_size)
        Enc_State.zone_count = 0
        
        i = 0
        WhileLoop LessThan(i, zones_size) {
            SetByte(Enc_State.zones, i, 0)
            i = Add(i, 1)
        }
        
        // Groups: MAX_ZONES * MAX_GROUPS * 8 bytes
        groups_size = Multiply(Multiply(Enc_Limits.MAX_ZONES, Enc_Limits.MAX_GROUPS), Group_Offsets.SIZE)
        Enc_State.groups = Allocate(groups_size)
        
        i = 0
        WhileLoop LessThan(i, groups_size) {
            SetByte(Enc_State.groups, i, 0)
            i = Add(i, 1)
        }
        
        // Battle monster arrays
        Enc_Battle.monster_ids = Allocate(Enc_Limits.MAX_BATTLE_MONSTERS)
        Enc_Battle.monster_hps = Allocate(Multiply(Enc_Limits.MAX_BATTLE_MONSTERS, 2))
        Enc_Battle.monster_count = 0
        Enc_Battle.active = 0
        
        Enc_State.steps_since_battle = 0
        Enc_State.initialized = 1
        
        ReturnValue(0)
    }
}

Function.Enc_Cleanup {
    Body: {
        IfCondition NotEqual(Enc_State.zones, 0) ThenBlock: {
            zones_size = Multiply(Enc_Limits.MAX_ZONES, Zone_Offsets.SIZE)
            Deallocate(Enc_State.zones, zones_size)
        }
        IfCondition NotEqual(Enc_State.groups, 0) ThenBlock: {
            groups_size = Multiply(Multiply(Enc_Limits.MAX_ZONES, Enc_Limits.MAX_GROUPS), Group_Offsets.SIZE)
            Deallocate(Enc_State.groups, groups_size)
        }
        IfCondition NotEqual(Enc_Battle.monster_ids, 0) ThenBlock: {
            Deallocate(Enc_Battle.monster_ids, Enc_Limits.MAX_BATTLE_MONSTERS)
        }
        IfCondition NotEqual(Enc_Battle.monster_hps, 0) ThenBlock: {
            Deallocate(Enc_Battle.monster_hps, Multiply(Enc_Limits.MAX_BATTLE_MONSTERS, 2))
        }
        ReturnValue(0)
    }
}

// ============================================
// ZONE REGISTRATION
// ============================================

Function.Enc_RegisterZone {
    Input: id: Integer
    Input: name: Address
    Input: map_id: Integer
    Input: min_x: Integer
    Input: min_y: Integer
    Input: max_x: Integer
    Input: max_y: Integer
    Input: rate: Integer
    Output: Integer
    Body: {
        IfCondition GreaterEqual(id, Enc_Limits.MAX_ZONES) ThenBlock: {
            ReturnValue(-1)
        }
        
        offset = Multiply(id, Zone_Offsets.SIZE)
        base = Add(Enc_State.zones, offset)
        
        // Copy name
        i = 0
        WhileLoop LessThan(i, 15) {
            ch = GetByte(name, i)
            SetByte(base, i, ch)
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            i = Add(i, 1)
        }
        SetByte(base, 15, 0)
        
        SetByte(base, Zone_Offsets.ID, id)
        SetByte(base, Zone_Offsets.MAP_ID, map_id)
        SetByte(base, Zone_Offsets.MIN_X, BitwiseAnd(min_x, 255))
        SetByte(base, Add(Zone_Offsets.MIN_X, 1), RightShift(min_x, 8))
        SetByte(base, Zone_Offsets.MIN_Y, BitwiseAnd(min_y, 255))
        SetByte(base, Add(Zone_Offsets.MIN_Y, 1), RightShift(min_y, 8))
        SetByte(base, Zone_Offsets.MAX_X, BitwiseAnd(max_x, 255))
        SetByte(base, Add(Zone_Offsets.MAX_X, 1), RightShift(max_x, 8))
        SetByte(base, Zone_Offsets.MAX_Y, BitwiseAnd(max_y, 255))
        SetByte(base, Add(Zone_Offsets.MAX_Y, 1), RightShift(max_y, 8))
        SetByte(base, Zone_Offsets.RATE, rate)
        SetByte(base, Zone_Offsets.GROUP_COUNT, 0)
        SetByte(base, Zone_Offsets.MIN_LEVEL, 1)
        SetByte(base, Zone_Offsets.FLAGS, 0)
        
        IfCondition GreaterEqual(id, Enc_State.zone_count) ThenBlock: {
            Enc_State.zone_count = Add(id, 1)
        }
        
        ReturnValue(id)
    }
}

Function.Enc_AddGroup {
    Input: zone_id: Integer
    Input: monster_id: Integer
    Input: min_count: Integer
    Input: max_count: Integer
    Input: weight: Integer
    Output: Integer
    Body: {
        zone_offset = Multiply(zone_id, Zone_Offsets.SIZE)
        zone_base = Add(Enc_State.zones, zone_offset)
        group_count = GetByte(zone_base, Zone_Offsets.GROUP_COUNT)
        
        IfCondition GreaterEqual(group_count, Enc_Limits.MAX_GROUPS) ThenBlock: {
            ReturnValue(-1)
        }
        
        // Get group slot
        groups_base = Multiply(zone_id, Multiply(Enc_Limits.MAX_GROUPS, Group_Offsets.SIZE))
        group_offset = Multiply(group_count, Group_Offsets.SIZE)
        group_addr = Add(Enc_State.groups, Add(groups_base, group_offset))
        
        SetByte(group_addr, Group_Offsets.MONSTER_ID, monster_id)
        SetByte(group_addr, Group_Offsets.MIN_COUNT, min_count)
        SetByte(group_addr, Group_Offsets.MAX_COUNT, max_count)
        SetByte(group_addr, Group_Offsets.WEIGHT, weight)
        
        SetByte(zone_base, Zone_Offsets.GROUP_COUNT, Add(group_count, 1))
        
        ReturnValue(group_count)
    }
}

// ============================================
// ZONE LOOKUP
// ============================================

Function.Enc_GetZoneAt {
    Input: map_id: Integer
    Input: x: Integer
    Input: y: Integer
    Output: Integer
    Body: {
        i = 0
        WhileLoop LessThan(i, Enc_State.zone_count) {
            offset = Multiply(i, Zone_Offsets.SIZE)
            base = Add(Enc_State.zones, offset)
            
            z_map = GetByte(base, Zone_Offsets.MAP_ID)
            IfCondition NotEqual(z_map, map_id) ThenBlock: {
                i = Add(i, 1)
                ContinueLoop
            }
            
            min_x = Add(GetByte(base, Zone_Offsets.MIN_X), Multiply(GetByte(base, Add(Zone_Offsets.MIN_X, 1)), 256))
            min_y = Add(GetByte(base, Zone_Offsets.MIN_Y), Multiply(GetByte(base, Add(Zone_Offsets.MIN_Y, 1)), 256))
            max_x = Add(GetByte(base, Zone_Offsets.MAX_X), Multiply(GetByte(base, Add(Zone_Offsets.MAX_X, 1)), 256))
            max_y = Add(GetByte(base, Zone_Offsets.MAX_Y), Multiply(GetByte(base, Add(Zone_Offsets.MAX_Y, 1)), 256))
            
            IfCondition And(GreaterEqual(x, min_x), LessEqual(x, max_x)) ThenBlock: {
                IfCondition And(GreaterEqual(y, min_y), LessEqual(y, max_y)) ThenBlock: {
                    // Check if disabled
                    flags = GetByte(base, Zone_Offsets.FLAGS)
                    IfCondition EqualTo(BitwiseAnd(flags, Zone_Flags.DISABLED), 0) ThenBlock: {
                        ReturnValue(i)
                    }
                }
            }
            
            i = Add(i, 1)
        }
        ReturnValue(-1)
    }
}

Function.Enc_GetZoneRate {
    Input: zone_id: Integer
    Output: Integer
    Body: {
        offset = Multiply(zone_id, Zone_Offsets.SIZE)
        base = Add(Enc_State.zones, offset)
        ReturnValue(GetByte(base, Zone_Offsets.RATE))
    }
}

Function.Enc_GetZoneName {
    Input: zone_id: Integer
    Output: Address
    Body: {
        offset = Multiply(zone_id, Zone_Offsets.SIZE)
        base = Add(Enc_State.zones, offset)
        ReturnValue(base)
    }
}

// ============================================
// ENCOUNTER CHECK
// ============================================

// Call this every step - returns 1 if battle starts
Function.Enc_CheckEncounter {
    Input: map_id: Integer
    Input: x: Integer
    Input: y: Integer
    Output: Integer
    Body: {
        // Find zone
        zone_id = Enc_GetZoneAt(map_id, x, y)
        IfCondition LessThan(zone_id, 0) ThenBlock: {
            ReturnValue(0)  // No encounter zone here
        }
        
        Enc_State.steps_since_battle = Add(Enc_State.steps_since_battle, 1)
        
        // Get encounter rate
        rate = Enc_GetZoneRate(zone_id)
        
        // Increase chance slightly with more steps (DW style)
        // Base rate + (steps / 10), capped at rate * 2
        adjusted_rate = Add(rate, Divide(Enc_State.steps_since_battle, 10))
        max_rate = Multiply(rate, 2)
        IfCondition GreaterThan(adjusted_rate, max_rate) ThenBlock: {
            adjusted_rate = max_rate
        }
        
        // Roll for encounter
        roll = Dice_Percent()
        IfCondition LessEqual(roll, adjusted_rate) ThenBlock: {
            // Encounter!
            Enc_State.steps_since_battle = 0
            Enc_StartBattle(zone_id)
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}

// ============================================
// BATTLE GENERATION
// ============================================

Function.Enc_StartBattle {
    Input: zone_id: Integer
    Body: {
        zone_offset = Multiply(zone_id, Zone_Offsets.SIZE)
        zone_base = Add(Enc_State.zones, zone_offset)
        group_count = GetByte(zone_base, Zone_Offsets.GROUP_COUNT)
        
        IfCondition EqualTo(group_count, 0) ThenBlock: {
            ReturnValue(-1)  // No monsters defined
        }
        
        // Calculate total weight
        total_weight = 0
        groups_base = Multiply(zone_id, Multiply(Enc_Limits.MAX_GROUPS, Group_Offsets.SIZE))
        
        i = 0
        WhileLoop LessThan(i, group_count) {
            group_addr = Add(Enc_State.groups, Add(groups_base, Multiply(i, Group_Offsets.SIZE)))
            weight = GetByte(group_addr, Group_Offsets.WEIGHT)
            total_weight = Add(total_weight, weight)
            i = Add(i, 1)
        }
        
        // Pick a group
        roll = Dice_Range(total_weight)
        cumulative = 0
        selected_group = 0
        
        i = 0
        WhileLoop LessThan(i, group_count) {
            group_addr = Add(Enc_State.groups, Add(groups_base, Multiply(i, Group_Offsets.SIZE)))
            weight = GetByte(group_addr, Group_Offsets.WEIGHT)
            cumulative = Add(cumulative, weight)
            
            IfCondition LessEqual(roll, cumulative) ThenBlock: {
                selected_group = i
                BreakLoop
            }
            i = Add(i, 1)
        }
        
        // Get group details
        group_addr = Add(Enc_State.groups, Add(groups_base, Multiply(selected_group, Group_Offsets.SIZE)))
        monster_id = GetByte(group_addr, Group_Offsets.MONSTER_ID)
        min_count = GetByte(group_addr, Group_Offsets.MIN_COUNT)
        max_count = GetByte(group_addr, Group_Offsets.MAX_COUNT)
        
        // Determine count
        count = Dice_RangeMinMax(min_count, max_count)
        IfCondition GreaterThan(count, Enc_Limits.MAX_BATTLE_MONSTERS) ThenBlock: {
            count = Enc_Limits.MAX_BATTLE_MONSTERS
        }
        
        // Set up battle
        Enc_Battle.monster_count = count
        Enc_Battle.zone_id = zone_id
        Enc_Battle.active = 1
        
        // Check no-escape flag
        flags = GetByte(zone_base, Zone_Offsets.FLAGS)
        IfCondition NotEqual(BitwiseAnd(flags, Zone_Flags.NO_ESCAPE), 0) ThenBlock: {
            Enc_Battle.can_escape = 0
        } ElseBlock: {
            Enc_Battle.can_escape = 1
        }
        
        // Populate monster arrays
        i = 0
        WhileLoop LessThan(i, count) {
            SetByte(Enc_Battle.monster_ids, i, monster_id)
            
            // Set HP (would need monster stats - placeholder 10-20)
            hp = Dice_RangeMinMax(10, 20)
            hp_offset = Multiply(i, 2)
            SetByte(Enc_Battle.monster_hps, hp_offset, BitwiseAnd(hp, 255))
            SetByte(Enc_Battle.monster_hps, Add(hp_offset, 1), RightShift(hp, 8))
            
            i = Add(i, 1)
        }
        
        ReturnValue(count)
    }
}

// ============================================
// BATTLE ACCESSORS
// ============================================

Function.Enc_IsInBattle {
    Output: Integer
    Body: {
        ReturnValue(Enc_Battle.active)
    }
}

Function.Enc_GetBattleMonsterCount {
    Output: Integer
    Body: {
        ReturnValue(Enc_Battle.monster_count)
    }
}

Function.Enc_GetBattleMonsterId {
    Input: idx: Integer
    Output: Integer
    Body: {
        ReturnValue(GetByte(Enc_Battle.monster_ids, idx))
    }
}

Function.Enc_GetBattleMonsterHP {
    Input: idx: Integer
    Output: Integer
    Body: {
        offset = Multiply(idx, 2)
        lo = GetByte(Enc_Battle.monster_hps, offset)
        hi = GetByte(Enc_Battle.monster_hps, Add(offset, 1))
        ReturnValue(Add(lo, Multiply(hi, 256)))
    }
}

Function.Enc_SetBattleMonsterHP {
    Input: idx: Integer
    Input: hp: Integer
    Body: {
        offset = Multiply(idx, 2)
        SetByte(Enc_Battle.monster_hps, offset, BitwiseAnd(hp, 255))
        SetByte(Enc_Battle.monster_hps, Add(offset, 1), RightShift(hp, 8))
        ReturnValue(0)
    }
}

Function.Enc_CanEscape {
    Output: Integer
    Body: {
        ReturnValue(Enc_Battle.can_escape)
    }
}

Function.Enc_EndBattle {
    Body: {
        Enc_Battle.active = 0
        Enc_Battle.monster_count = 0
        ReturnValue(0)
    }
}

// ============================================
// ESCAPE ATTEMPT
// ============================================

Function.Enc_TryEscape {
    Input: player_agi: Integer
    Output: Integer
    Body: {
        IfCondition EqualTo(Enc_Battle.can_escape, 0) ThenBlock: {
            ReturnValue(0)  // Can't escape this battle
        }
        
        // Base 50% + AGI bonus
        chance = Add(50, Multiply(player_agi, 2))
        IfCondition GreaterThan(chance, 90) ThenBlock: {
            chance = 90  // Cap at 90%
        }
        
        roll = Dice_Percent()
        IfCondition LessEqual(roll, chance) ThenBlock: {
            Enc_EndBattle()
            ReturnValue(1)  // Escaped!
        }
        
        ReturnValue(0)  // Failed to escape
    }
}

// ============================================
// DEFAULT ENCOUNTERS
// ============================================

Function.Enc_RegisterDefaults {
    Body: {
        // Zone 0: Overworld - near town (easy)
        Enc_RegisterZone(0, "Fields", 0, 5, 8, 15, 15, 8)
        Enc_AddGroup(0, 1, 1, 2, 50)    // 1-2 Goblins (common)
        Enc_AddGroup(0, 1, 3, 4, 20)    // 3-4 Goblins (uncommon)
        
        // Zone 1: Overworld - wilderness (medium)
        Enc_RegisterZone(1, "Wilderness", 0, 16, 0, 39, 24, 12)
        Enc_AddGroup(1, 1, 2, 3, 30)    // Goblins
        Enc_AddGroup(1, 2, 1, 2, 50)    // Orcs
        Enc_AddGroup(1, 2, 2, 3, 20)    // Orc pack
        
        // Zone 2: Dark Cave B1
        Enc_RegisterZone(2, "Cave B1", 2, 0, 0, 29, 19, 15)
        Enc_AddGroup(2, 1, 2, 4, 40)    // Goblins
        Enc_AddGroup(2, 2, 1, 2, 50)    // Orcs
        Enc_AddGroup(2, 3, 1, 1, 10)    // Troll (rare)
        
        // Zone 3: Dark Cave B2 (harder)
        Enc_RegisterZone(3, "Cave B2", 3, 0, 0, 29, 19, 20)
        Enc_AddGroup(3, 2, 2, 3, 40)    // Orcs
        Enc_AddGroup(3, 3, 1, 2, 50)    // Trolls
        Enc_AddGroup(3, 3, 2, 3, 10)    // Troll pack (rare)
        
        ReturnValue(0)
    }
}