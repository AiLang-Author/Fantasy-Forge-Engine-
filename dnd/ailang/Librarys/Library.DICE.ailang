// ============================================
// Library.Dice.ailang
// RPG Dice Rolling System
// ============================================
//
// USAGE:
//   Dice_Init()              Initialize RNG
//   Dice_Roll(sides)         Roll 1dN (e.g., Dice_Roll(20) = 1d20)
//   Dice_RollN(count, sides) Roll NdS (e.g., Dice_RollN(2, 6) = 2d6)
//   Dice_RollMod(n, s, mod)  Roll NdS+M (e.g., 2d6+3)
//   Dice_D4(), Dice_D6()...  Convenience functions
//   Dice_Percent()           Roll 1-100
//
// ============================================

// ============================================
// RNG STATE
// ============================================

FixedPool.Dice_RNG {
    "state": Initialize=12345
    "initialized": Initialize=0
}

// ============================================
// INITIALIZATION
// ============================================

// Seed from system time for randomness
Function.Dice_Init {
    Body: {
        // Get time for seed: clock_gettime(CLOCK_REALTIME=0, timespec*)
        timespec = Allocate(16)
        SystemCall(228, 0, timespec)  // clock_gettime
        
        // Use nanoseconds for better entropy
        sec = Dereference(timespec)
        nsec = Dereference(Add(timespec, 8))
        
        // Mix time values for seed
        seed = Add(Multiply(sec, 1000000), nsec)
        seed = BitwiseXor(seed, Multiply(sec, 31337))
        
        // Ensure non-zero
        IfCondition EqualTo(seed, 0) ThenBlock: {
            seed = 1
        }
        
        Dice_RNG.state = seed
        Dice_RNG.initialized = 1
        
        Deallocate(timespec, 16)
        
        // Warm up the generator
        i = 0
        WhileLoop LessThan(i, 10) {
            Dice_Next()
            i = Add(i, 1)
        }
        
        ReturnValue(0)
    }
}

// ============================================
// CORE RNG (Linear Congruential Generator)
// ============================================

// Generate next random number
Function.Dice_Next {
    Output: Integer
    Body: {
        // LCG: state = (a * state + c) mod m
        // Using parameters from Numerical Recipes
        // a = 1664525, c = 1013904223
        
        state = Dice_RNG.state
        
        // Multiply by 1664525
        state = Multiply(state, 1664525)
        
        // Add 1013904223
        state = Add(state, 1013904223)
        
        // Keep it positive (mask to 31 bits)
        state = BitwiseAnd(state, 2147483647)
        
        Dice_RNG.state = state
        ReturnValue(state)
    }
}

// Get random number in range [1, max]
Function.Dice_Range {
    Input: max: Integer
    Output: Integer
    Body: {
        IfCondition LessEqual(max, 0) ThenBlock: {
            ReturnValue(1)
        }
        
        raw = Dice_Next()
        result = Add(Modulo(raw, max), 1)
        ReturnValue(result)
    }
}

// Get random number in range [min, max]
Function.Dice_RangeMinMax {
    Input: min: Integer
    Input: max: Integer
    Output: Integer
    Body: {
        IfCondition GreaterEqual(min, max) ThenBlock: {
            ReturnValue(min)
        }
        
        range = Add(Subtract(max, min), 1)
        raw = Dice_Next()
        result = Add(Modulo(raw, range), min)
        ReturnValue(result)
    }
}

// ============================================
// DICE ROLLING FUNCTIONS
// ============================================

// Roll 1dN
Function.Dice_Roll {
    Input: sides: Integer
    Output: Integer
    Body: {
        result = Dice_Range(sides)
        ReturnValue(result)
    }
}

// Roll NdS (count dice of sides)
Function.Dice_RollN {
    Input: count: Integer
    Input: sides: Integer
    Output: Integer
    Body: {
        total = 0
        i = 0
        
        WhileLoop LessThan(i, count) {
            roll = Dice_Range(sides)
            total = Add(total, roll)
            i = Add(i, 1)
        }
        
        ReturnValue(total)
    }
}

// Roll NdS+M (with modifier)
Function.Dice_RollMod {
    Input: count: Integer
    Input: sides: Integer
    Input: modifier: Integer
    Output: Integer
    Body: {
        total = Dice_RollN(count, sides)
        total = Add(total, modifier)
        
        // Minimum of 0
        IfCondition LessThan(total, 0) ThenBlock: {
            total = 0
        }
        
        ReturnValue(total)
    }
}

// ============================================
// CONVENIENCE FUNCTIONS
// ============================================

Function.Dice_D4 {
    Output: Integer
    Body: {
        ReturnValue(Dice_Range(4))
    }
}

Function.Dice_D6 {
    Output: Integer
    Body: {
        ReturnValue(Dice_Range(6))
    }
}

Function.Dice_D8 {
    Output: Integer
    Body: {
        ReturnValue(Dice_Range(8))
    }
}

Function.Dice_D10 {
    Output: Integer
    Body: {
        ReturnValue(Dice_Range(10))
    }
}

Function.Dice_D12 {
    Output: Integer
    Body: {
        ReturnValue(Dice_Range(12))
    }
}

Function.Dice_D20 {
    Output: Integer
    Body: {
        ReturnValue(Dice_Range(20))
    }
}

Function.Dice_D100 {
    Output: Integer
    Body: {
        ReturnValue(Dice_Range(100))
    }
}

Function.Dice_Percent {
    Output: Integer
    Body: {
        ReturnValue(Dice_Range(100))
    }
}

// ============================================
// UTILITY FUNCTIONS
// ============================================

// Roll with advantage (roll twice, take higher)
Function.Dice_Advantage {
    Input: sides: Integer
    Output: Integer
    Body: {
        roll1 = Dice_Range(sides)
        roll2 = Dice_Range(sides)
        
        IfCondition GreaterThan(roll1, roll2) ThenBlock: {
            ReturnValue(roll1)
        }
        ReturnValue(roll2)
    }
}

// Roll with disadvantage (roll twice, take lower)
Function.Dice_Disadvantage {
    Input: sides: Integer
    Output: Integer
    Body: {
        roll1 = Dice_Range(sides)
        roll2 = Dice_Range(sides)
        
        IfCondition LessThan(roll1, roll2) ThenBlock: {
            ReturnValue(roll1)
        }
        ReturnValue(roll2)
    }
}

// Calculate modifier from ability score (D&D style)
Function.Dice_AbilityMod {
    Input: score: Integer
    Output: Integer
    Body: {
        // (score - 10) / 2, round down
        mod = Divide(Subtract(score, 10), 2)
        ReturnValue(mod)
    }
}

// Check if roll meets or beats DC
Function.Dice_Check {
    Input: roll: Integer
    Input: modifier: Integer
    Input: dc: Integer
    Output: Integer
    Body: {
        total = Add(roll, modifier)
        IfCondition GreaterEqual(total, dc) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// Flip a coin (1 = heads, 0 = tails)
Function.Dice_Coin {
    Output: Integer
    Body: {
        raw = Dice_Next()
        ReturnValue(Modulo(raw, 2))
    }
}