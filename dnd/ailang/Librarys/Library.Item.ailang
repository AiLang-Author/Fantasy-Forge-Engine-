// ============================================
// Library.Item.ailang
// Item & Inventory System
// ============================================
//
// Handles items, inventory, and equipment
// Works with Library.Character for equip bonuses
//
// ============================================

LibraryImport.Character

// ============================================
// CONSTANTS
// ============================================

FixedPool.Item_Limits {
    "MAX_ITEMS": Initialize=100      
    "MAX_INVENTORY": Initialize=20    
    "ITEM_SIZE": Initialize=32        
    "NAME_LEN": Initialize=20
}

// Item types
FixedPool.Item_Types {
    "NONE": Initialize=0
    "WEAPON": Initialize=1
    "ARMOR": Initialize=2
    "SHIELD": Initialize=3
    "HELMET": Initialize=4
    "RING": Initialize=5
    "AMULET": Initialize=6
    "POTION": Initialize=7
    "SCROLL": Initialize=8
    "KEY": Initialize=9
    "GOLD": Initialize=10
    "FOOD": Initialize=11
    "MISC": Initialize=12
}

// Equipment slots (matches Char_Slots)
FixedPool.Item_Slots {
    "WEAPON": Initialize=0
    "ARMOR": Initialize=1
    "SHIELD": Initialize=2
    "HELMET": Initialize=3
    "RING": Initialize=4
    "AMULET": Initialize=5
    "NONE": Initialize=255
}

// Item rarity
FixedPool.Item_Rarity {
    "COMMON": Initialize=1
    "UNCOMMON": Initialize=2
    "RARE": Initialize=3
    "EPIC": Initialize=4
    "LEGENDARY": Initialize=5
}

// ============================================
// ITEM STRUCTURE (32 bytes)
// ============================================
// 0-19:  Name (20 bytes)
// 20:    Type (1 byte)
// 21:    Slot (1 byte) - which equip slot, 255=none
// 22-23: Value (2 bytes) - gold value
// 24:    Attack bonus (1 byte, signed)
// 25:    Defense bonus (1 byte, signed)
// 26:    Magic bonus (1 byte, signed)
// 27:    HP bonus (1 byte)
// 28:    MP bonus (1 byte)
// 29:    Required level (1 byte)
// 30:    Rarity (1 byte)
// 31:    Flags (1 byte)

FixedPool.Item_Offsets {
    "NAME": Initialize=0
    "TYPE": Initialize=20
    "SLOT": Initialize=21
    "VALUE": Initialize=22
    "ATK_BONUS": Initialize=24
    "DEF_BONUS": Initialize=25
    "MAG_BONUS": Initialize=26
    "HP_BONUS": Initialize=27
    "MP_BONUS": Initialize=28
    "REQ_LEVEL": Initialize=29
    "RARITY": Initialize=30
    "FLAGS": Initialize=31
    "SIZE": Initialize=32
}

// ============================================
// INVENTORY ENTRY (4 bytes)
// ============================================
// 0-1: Item ID (2 bytes)
// 2:   Quantity (1 byte)
// 3:   Flags (1 byte)

FixedPool.InvEntry_Offsets {
    "ITEM_ID": Initialize=0
    "QUANTITY": Initialize=2
    "FLAGS": Initialize=3
    "SIZE": Initialize=4
}

// ============================================
// GLOBAL STATE
// ============================================

FixedPool.Item_State {
    "item_db": Initialize=0          
    "item_count": Initialize=0      
    "initialized": Initialize=0
}

// Player inventory
FixedPool.Item_Inventory {
    "items": Initialize=0          
    "count": Initialize=0            
    "equipped": Initialize=0        
}

// ============================================
// INITIALIZATION
// ============================================

Function.Item_Init {
    Body: {
        // Allocate item database
        db_size = Multiply(Item_Limits.MAX_ITEMS, Item_Offsets.SIZE)
        Item_State.item_db = Allocate(db_size)
        Item_State.item_count = 0
        
        // Clear database
        i = 0
        WhileLoop LessThan(i, db_size) {
            SetByte(Item_State.item_db, i, 0)
            i = Add(i, 1)
        }
        
        // Allocate inventory
        inv_size = Multiply(Item_Limits.MAX_INVENTORY, InvEntry_Offsets.SIZE)
        Item_Inventory.items = Allocate(inv_size)
        Item_Inventory.count = 0
        
        // Clear inventory
        i = 0
        WhileLoop LessThan(i, inv_size) {
            SetByte(Item_Inventory.items, i, 0)
            i = Add(i, 1)
        }
        
        // Allocate equipped slots (6 slots x 2 bytes = 12 bytes)
        Item_Inventory.equipped = Allocate(12)
        i = 0
        WhileLoop LessThan(i, 12) {
            SetByte(Item_Inventory.equipped, i, 0)
            i = Add(i, 1)
        }
        
        Item_State.initialized = 1
        ReturnValue(0)
    }
}

Function.Item_Cleanup {
    Body: {
        IfCondition NotEqual(Item_State.item_db, 0) ThenBlock: {
            db_size = Multiply(Item_Limits.MAX_ITEMS, Item_Offsets.SIZE)
            Deallocate(Item_State.item_db, db_size)
        }
        IfCondition NotEqual(Item_Inventory.items, 0) ThenBlock: {
            inv_size = Multiply(Item_Limits.MAX_INVENTORY, InvEntry_Offsets.SIZE)
            Deallocate(Item_Inventory.items, inv_size)
        }
        IfCondition NotEqual(Item_Inventory.equipped, 0) ThenBlock: {
            Deallocate(Item_Inventory.equipped, 12)
        }
        ReturnValue(0)
    }
}

// ============================================
// ITEM DATABASE FUNCTIONS
// ============================================

Function.Item_Register {
    Input: id: Integer
    Input: name: Address
    Input: item_type: Integer
    Input: slot: Integer
    Input: value: Integer
    Input: atk: Integer
    Input: def: Integer
    Input: mag: Integer
    Body: {
        IfCondition GreaterEqual(id, Item_Limits.MAX_ITEMS) ThenBlock: {
            ReturnValue(-1)
        }
        
        offset = Multiply(id, Item_Offsets.SIZE)
        base = Add(Item_State.item_db, offset)
        
        // Copy name
        i = 0
        WhileLoop LessThan(i, 19) {
            ch = GetByte(name, i)
            SetByte(base, i, ch)
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            i = Add(i, 1)
        }
        SetByte(base, 19, 0)
        
        // Set properties
        SetByte(base, Item_Offsets.TYPE, item_type)
        SetByte(base, Item_Offsets.SLOT, slot)
        SetByte(base, Item_Offsets.VALUE, BitwiseAnd(value, 255))
        SetByte(base, Add(Item_Offsets.VALUE, 1), RightShift(value, 8))
        SetByte(base, Item_Offsets.ATK_BONUS, atk)
        SetByte(base, Item_Offsets.DEF_BONUS, def)
        SetByte(base, Item_Offsets.MAG_BONUS, mag)
        SetByte(base, Item_Offsets.HP_BONUS, 0)
        SetByte(base, Item_Offsets.MP_BONUS, 0)
        SetByte(base, Item_Offsets.REQ_LEVEL, 1)
        SetByte(base, Item_Offsets.RARITY, Item_Rarity.COMMON)
        SetByte(base, Item_Offsets.FLAGS, 0)
        
        IfCondition GreaterEqual(id, Item_State.item_count) ThenBlock: {
            Item_State.item_count = Add(id, 1)
        }
        
        ReturnValue(id)
    }
}

Function.Item_RegisterFull {
    Input: id: Integer
    Input: name: Address
    Input: item_type: Integer
    Input: slot: Integer
    Input: value: Integer
    Input: atk: Integer
    Input: def: Integer
    Input: mag: Integer
    Input: hp: Integer
    Input: mp: Integer
    Input: req_level: Integer
    Input: rarity: Integer
    Body: {
        result = Item_Register(id, name, item_type, slot, value, atk, def, mag)
        IfCondition LessThan(result, 0) ThenBlock: {
            ReturnValue(result)
        }
        
        offset = Multiply(id, Item_Offsets.SIZE)
        base = Add(Item_State.item_db, offset)
        
        SetByte(base, Item_Offsets.HP_BONUS, hp)
        SetByte(base, Item_Offsets.MP_BONUS, mp)
        SetByte(base, Item_Offsets.REQ_LEVEL, req_level)
        SetByte(base, Item_Offsets.RARITY, rarity)
        
        ReturnValue(id)
    }
}

// ============================================
// ITEM ACCESSORS
// ============================================

Function.Item_GetName {
    Input: item_id: Integer
    Output: Address
    Body: {
        IfCondition GreaterEqual(item_id, Item_Limits.MAX_ITEMS) ThenBlock: {
            ReturnValue(0)
        }
        offset = Multiply(item_id, Item_Offsets.SIZE)
        base = Add(Item_State.item_db, offset)
        ReturnValue(base)
    }
}

Function.Item_GetType {
    Input: item_id: Integer
    Output: Integer
    Body: {
        offset = Multiply(item_id, Item_Offsets.SIZE)
        base = Add(Item_State.item_db, offset)
        ReturnValue(GetByte(base, Item_Offsets.TYPE))
    }
}

Function.Item_GetSlot {
    Input: item_id: Integer
    Output: Integer
    Body: {
        offset = Multiply(item_id, Item_Offsets.SIZE)
        base = Add(Item_State.item_db, offset)
        ReturnValue(GetByte(base, Item_Offsets.SLOT))
    }
}

Function.Item_GetValue {
    Input: item_id: Integer
    Output: Integer
    Body: {
        offset = Multiply(item_id, Item_Offsets.SIZE)
        base = Add(Item_State.item_db, offset)
        lo = GetByte(base, Item_Offsets.VALUE)
        hi = GetByte(base, Add(Item_Offsets.VALUE, 1))
        ReturnValue(Add(lo, Multiply(hi, 256)))
    }
}

Function.Item_GetAtkBonus {
    Input: item_id: Integer
    Output: Integer
    Body: {
        offset = Multiply(item_id, Item_Offsets.SIZE)
        base = Add(Item_State.item_db, offset)
        ReturnValue(GetByte(base, Item_Offsets.ATK_BONUS))
    }
}

Function.Item_GetDefBonus {
    Input: item_id: Integer
    Output: Integer
    Body: {
        offset = Multiply(item_id, Item_Offsets.SIZE)
        base = Add(Item_State.item_db, offset)
        ReturnValue(GetByte(base, Item_Offsets.DEF_BONUS))
    }
}

Function.Item_GetMagBonus {
    Input: item_id: Integer
    Output: Integer
    Body: {
        offset = Multiply(item_id, Item_Offsets.SIZE)
        base = Add(Item_State.item_db, offset)
        ReturnValue(GetByte(base, Item_Offsets.MAG_BONUS))
    }
}

Function.Item_GetRarity {
    Input: item_id: Integer
    Output: Integer
    Body: {
        offset = Multiply(item_id, Item_Offsets.SIZE)
        base = Add(Item_State.item_db, offset)
        ReturnValue(GetByte(base, Item_Offsets.RARITY))
    }
}

Function.Item_GetReqLevel {
    Input: item_id: Integer
    Output: Integer
    Body: {
        offset = Multiply(item_id, Item_Offsets.SIZE)
        base = Add(Item_State.item_db, offset)
        ReturnValue(GetByte(base, Item_Offsets.REQ_LEVEL))
    }
}

Function.Item_IsEquippable {
    Input: item_id: Integer
    Output: Integer
    Body: {
        slot = Item_GetSlot(item_id)
        IfCondition LessThan(slot, 6) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// ============================================
// INVENTORY FUNCTIONS
// ============================================

Function.Item_InvAdd {
    Input: item_id: Integer
    Input: quantity: Integer
    Output: Integer
    Body: {
        // Check if already in inventory
        i = 0
        WhileLoop LessThan(i, Item_Inventory.count) {
            offset = Multiply(i, InvEntry_Offsets.SIZE)
            base = Add(Item_Inventory.items, offset)
            
            existing_id = Add(GetByte(base, 0), Multiply(GetByte(base, 1), 256))
            IfCondition EqualTo(existing_id, item_id) ThenBlock: {
                // Add to existing stack
                qty = GetByte(base, InvEntry_Offsets.QUANTITY)
                new_qty = Add(qty, quantity)
                IfCondition GreaterThan(new_qty, 99) ThenBlock: {
                    new_qty = 99
                }
                SetByte(base, InvEntry_Offsets.QUANTITY, new_qty)
                ReturnValue(i)
            }
            i = Add(i, 1)
        }
        
        // Add new entry
        IfCondition GreaterEqual(Item_Inventory.count, Item_Limits.MAX_INVENTORY) ThenBlock: {
            ReturnValue(-1)  // Inventory full
        }
        
        offset = Multiply(Item_Inventory.count, InvEntry_Offsets.SIZE)
        base = Add(Item_Inventory.items, offset)
        
        SetByte(base, 0, BitwiseAnd(item_id, 255))
        SetByte(base, 1, RightShift(item_id, 8))
        SetByte(base, InvEntry_Offsets.QUANTITY, quantity)
        SetByte(base, InvEntry_Offsets.FLAGS, 0)
        
        Item_Inventory.count = Add(Item_Inventory.count, 1)
        ReturnValue(Subtract(Item_Inventory.count, 1))
    }
}

Function.Item_InvRemove {
    Input: inv_index: Integer
    Input: quantity: Integer
    Output: Integer
    Body: {
        IfCondition GreaterEqual(inv_index, Item_Inventory.count) ThenBlock: {
            ReturnValue(-1)
        }
        
        offset = Multiply(inv_index, InvEntry_Offsets.SIZE)
        base = Add(Item_Inventory.items, offset)
        
        qty = GetByte(base, InvEntry_Offsets.QUANTITY)
        new_qty = Subtract(qty, quantity)
        
        IfCondition LessEqual(new_qty, 0) ThenBlock: {
            // Remove entry entirely - shift remaining items
            i = inv_index
            last = Subtract(Item_Inventory.count, 1)
            WhileLoop LessThan(i, last) {
                src_offset = Multiply(Add(i, 1), InvEntry_Offsets.SIZE)
                dst_offset = Multiply(i, InvEntry_Offsets.SIZE)
                
                j = 0
                WhileLoop LessThan(j, InvEntry_Offsets.SIZE) {
                    ch = GetByte(Item_Inventory.items, Add(src_offset, j))
                    SetByte(Item_Inventory.items, Add(dst_offset, j), ch)
                    j = Add(j, 1)
                }
                i = Add(i, 1)
            }
            Item_Inventory.count = Subtract(Item_Inventory.count, 1)
        } ElseBlock: {
            SetByte(base, InvEntry_Offsets.QUANTITY, new_qty)
        }
        
        ReturnValue(0)
    }
}

Function.Item_InvGetItemId {
    Input: inv_index: Integer
    Output: Integer
    Body: {
        IfCondition GreaterEqual(inv_index, Item_Inventory.count) ThenBlock: {
            ReturnValue(0)
        }
        
        offset = Multiply(inv_index, InvEntry_Offsets.SIZE)
        base = Add(Item_Inventory.items, offset)
        
        item_id = Add(GetByte(base, 0), Multiply(GetByte(base, 1), 256))
        ReturnValue(item_id)
    }
}

Function.Item_InvGetQuantity {
    Input: inv_index: Integer
    Output: Integer
    Body: {
        IfCondition GreaterEqual(inv_index, Item_Inventory.count) ThenBlock: {
            ReturnValue(0)
        }
        
        offset = Multiply(inv_index, InvEntry_Offsets.SIZE)
        base = Add(Item_Inventory.items, offset)
        
        ReturnValue(GetByte(base, InvEntry_Offsets.QUANTITY))
    }
}

Function.Item_InvCount {
    Output: Integer
    Body: {
        ReturnValue(Item_Inventory.count)
    }
}

Function.Item_InvHasItem {
    Input: item_id: Integer
    Output: Integer
    Body: {
        i = 0
        WhileLoop LessThan(i, Item_Inventory.count) {
            inv_item = Item_InvGetItemId(i)
            IfCondition EqualTo(inv_item, item_id) ThenBlock: {
                ReturnValue(1)
            }
            i = Add(i, 1)
        }
        ReturnValue(0)
    }
}

// ============================================
// EQUIPMENT FUNCTIONS
// ============================================

Function.Item_GetEquipped {
    Input: slot: Integer
    Output: Integer
    Body: {
        IfCondition GreaterEqual(slot, 6) ThenBlock: {
            ReturnValue(0)
        }
        
        offset = Multiply(slot, 2)
        lo = GetByte(Item_Inventory.equipped, offset)
        hi = GetByte(Item_Inventory.equipped, Add(offset, 1))
        ReturnValue(Add(lo, Multiply(hi, 256)))
    }
}

Function.Item_SetEquipped {
    Input: slot: Integer
    Input: item_id: Integer
    Body: {
        IfCondition GreaterEqual(slot, 6) ThenBlock: {
            ReturnValue(-1)
        }
        
        offset = Multiply(slot, 2)
        SetByte(Item_Inventory.equipped, offset, BitwiseAnd(item_id, 255))
        SetByte(Item_Inventory.equipped, Add(offset, 1), RightShift(item_id, 8))
        ReturnValue(0)
    }
}

Function.Item_Equip {
    Input: item_id: Integer
    Output: Integer
    Body: {
        // Check if equippable
        slot = Item_GetSlot(item_id)
        IfCondition GreaterEqual(slot, 6) ThenBlock: {
            ReturnValue(-1)  // Not equippable
        }
        
        // Check if already equipped something in that slot
        current = Item_GetEquipped(slot)
        IfCondition GreaterThan(current, 0) ThenBlock: {
            // Unequip current item first (add to inventory)
            Item_InvAdd(current, 1)
        }
        
        // Equip new item
        Item_SetEquipped(slot, item_id)
        
        ReturnValue(slot)
    }
}

Function.Item_EquipFromInventory {
    Input: inv_index: Integer
    Output: Integer
    Body: {
        item_id = Item_InvGetItemId(inv_index)
        IfCondition EqualTo(item_id, 0) ThenBlock: {
            ReturnValue(-1)
        }
        
        slot = Item_GetSlot(item_id)
        IfCondition GreaterEqual(slot, 6) ThenBlock: {
            ReturnValue(-1)  // Not equippable
        }
        
        // Remove from inventory
        Item_InvRemove(inv_index, 1)
        
        // Handle currently equipped item
        current = Item_GetEquipped(slot)
        IfCondition GreaterThan(current, 0) ThenBlock: {
            Item_InvAdd(current, 1)
        }
        
        // Equip
        Item_SetEquipped(slot, item_id)
        
        ReturnValue(slot)
    }
}

Function.Item_Unequip {
    Input: slot: Integer
    Output: Integer
    Body: {
        IfCondition GreaterEqual(slot, 6) ThenBlock: {
            ReturnValue(-1)
        }
        
        current = Item_GetEquipped(slot)
        IfCondition EqualTo(current, 0) ThenBlock: {
            ReturnValue(0)  // Nothing equipped
        }
        
        // Add to inventory
        result = Item_InvAdd(current, 1)
        IfCondition LessThan(result, 0) ThenBlock: {
            ReturnValue(-2)  // Inventory full
        }
        
        // Clear slot
        Item_SetEquipped(slot, 0)
        
        ReturnValue(current)
    }
}

// ============================================
// STAT BONUS CALCULATIONS
// ============================================

Function.Item_GetTotalAtkBonus {
    Output: Integer
    Body: {
        total = 0
        slot = 0
        WhileLoop LessThan(slot, 6) {
            item_id = Item_GetEquipped(slot)
            IfCondition GreaterThan(item_id, 0) ThenBlock: {
                bonus = Item_GetAtkBonus(item_id)
                total = Add(total, bonus)
            }
            slot = Add(slot, 1)
        }
        ReturnValue(total)
    }
}

Function.Item_GetTotalDefBonus {
    Output: Integer
    Body: {
        total = 0
        slot = 0
        WhileLoop LessThan(slot, 6) {
            item_id = Item_GetEquipped(slot)
            IfCondition GreaterThan(item_id, 0) ThenBlock: {
                bonus = Item_GetDefBonus(item_id)
                total = Add(total, bonus)
            }
            slot = Add(slot, 1)
        }
        ReturnValue(total)
    }
}

Function.Item_GetTotalMagBonus {
    Output: Integer
    Body: {
        total = 0
        slot = 0
        WhileLoop LessThan(slot, 6) {
            item_id = Item_GetEquipped(slot)
            IfCondition GreaterThan(item_id, 0) ThenBlock: {
                bonus = Item_GetMagBonus(item_id)
                total = Add(total, bonus)
            }
            slot = Add(slot, 1)
        }
        ReturnValue(total)
    }
}

// ============================================
// DEFAULT ITEMS
// ============================================

Function.Item_RegisterDefaults {
    Body: {
        // ID 0 is reserved for "empty"
        
        // === WEAPONS (slot 0) ===
        Item_RegisterFull(1, "Rusty Sword", Item_Types.WEAPON, Item_Slots.WEAPON, 5, 3, 0, 0, 0, 0, 1, Item_Rarity.COMMON)
        Item_RegisterFull(2, "Iron Sword", Item_Types.WEAPON, Item_Slots.WEAPON, 25, 6, 0, 0, 0, 0, 1, Item_Rarity.COMMON)
        Item_RegisterFull(3, "Steel Sword", Item_Types.WEAPON, Item_Slots.WEAPON, 80, 10, 0, 0, 0, 0, 3, Item_Rarity.UNCOMMON)
        Item_RegisterFull(4, "Flame Blade", Item_Types.WEAPON, Item_Slots.WEAPON, 200, 12, 0, 5, 0, 0, 5, Item_Rarity.RARE)
        Item_RegisterFull(5, "Dagger", Item_Types.WEAPON, Item_Slots.WEAPON, 10, 4, 0, 0, 0, 0, 1, Item_Rarity.COMMON)
        Item_RegisterFull(6, "Battle Axe", Item_Types.WEAPON, Item_Slots.WEAPON, 60, 12, 0, 0, 0, 0, 3, Item_Rarity.UNCOMMON)
        Item_RegisterFull(7, "Staff", Item_Types.WEAPON, Item_Slots.WEAPON, 30, 2, 0, 8, 0, 10, 1, Item_Rarity.COMMON)
        Item_RegisterFull(8, "Mace", Item_Types.WEAPON, Item_Slots.WEAPON, 40, 7, 1, 0, 0, 0, 2, Item_Rarity.COMMON)
        
        // === ARMOR (slot 1) ===
        Item_RegisterFull(10, "Cloth Tunic", Item_Types.ARMOR, Item_Slots.ARMOR, 5, 0, 1, 0, 0, 0, 1, Item_Rarity.COMMON)
        Item_RegisterFull(11, "Leather Armor", Item_Types.ARMOR, Item_Slots.ARMOR, 30, 0, 4, 0, 0, 0, 1, Item_Rarity.COMMON)
        Item_RegisterFull(12, "Chain Mail", Item_Types.ARMOR, Item_Slots.ARMOR, 100, 0, 8, 0, 0, 0, 3, Item_Rarity.UNCOMMON)
        Item_RegisterFull(13, "Plate Armor", Item_Types.ARMOR, Item_Slots.ARMOR, 300, 0, 14, 0, 10, 0, 6, Item_Rarity.RARE)
        Item_RegisterFull(14, "Mage Robes", Item_Types.ARMOR, Item_Slots.ARMOR, 50, 0, 2, 6, 0, 15, 2, Item_Rarity.UNCOMMON)
        
        // === SHIELDS (slot 2) ===
        Item_RegisterFull(20, "Wooden Shield", Item_Types.SHIELD, Item_Slots.SHIELD, 10, 0, 2, 0, 0, 0, 1, Item_Rarity.COMMON)
        Item_RegisterFull(21, "Iron Shield", Item_Types.SHIELD, Item_Slots.SHIELD, 50, 0, 5, 0, 0, 0, 2, Item_Rarity.COMMON)
        Item_RegisterFull(22, "Tower Shield", Item_Types.SHIELD, Item_Slots.SHIELD, 150, 0, 10, 0, 5, 0, 5, Item_Rarity.UNCOMMON)
        
        // === HELMETS (slot 3) ===
        Item_RegisterFull(30, "Leather Cap", Item_Types.HELMET, Item_Slots.HELMET, 8, 0, 1, 0, 0, 0, 1, Item_Rarity.COMMON)
        Item_RegisterFull(31, "Iron Helm", Item_Types.HELMET, Item_Slots.HELMET, 40, 0, 3, 0, 0, 0, 2, Item_Rarity.COMMON)
        Item_RegisterFull(32, "Wizard Hat", Item_Types.HELMET, Item_Slots.HELMET, 35, 0, 0, 4, 0, 8, 2, Item_Rarity.UNCOMMON)
        
        // === RINGS (slot 4) ===
        Item_RegisterFull(40, "Copper Ring", Item_Types.RING, Item_Slots.RING, 15, 1, 0, 0, 0, 0, 1, Item_Rarity.COMMON)
        Item_RegisterFull(41, "Silver Ring", Item_Types.RING, Item_Slots.RING, 50, 2, 1, 1, 0, 0, 3, Item_Rarity.UNCOMMON)
        Item_RegisterFull(42, "Ring of Power", Item_Types.RING, Item_Slots.RING, 200, 5, 0, 3, 10, 0, 5, Item_Rarity.RARE)
        Item_RegisterFull(43, "Ring of Vitality", Item_Types.RING, Item_Slots.RING, 150, 0, 3, 0, 20, 0, 4, Item_Rarity.RARE)
        
        // === AMULETS (slot 5) ===
        Item_RegisterFull(50, "Wooden Pendant", Item_Types.AMULET, Item_Slots.AMULET, 10, 0, 0, 1, 0, 5, 1, Item_Rarity.COMMON)
        Item_RegisterFull(51, "Silver Amulet", Item_Types.AMULET, Item_Slots.AMULET, 75, 0, 2, 3, 5, 10, 3, Item_Rarity.UNCOMMON)
        Item_RegisterFull(52, "Amulet of Might", Item_Types.AMULET, Item_Slots.AMULET, 250, 6, 0, 0, 15, 0, 6, Item_Rarity.RARE)
        
        // === CONSUMABLES ===
        Item_Register(60, "Health Potion", Item_Types.POTION, Item_Slots.NONE, 25, 0, 0, 0)
        Item_Register(61, "Mana Potion", Item_Types.POTION, Item_Slots.NONE, 25, 0, 0, 0)
        Item_Register(62, "Elixir", Item_Types.POTION, Item_Slots.NONE, 100, 0, 0, 0)
        Item_Register(63, "Antidote", Item_Types.POTION, Item_Slots.NONE, 15, 0, 0, 0)
        
        Item_Register(70, "Rusty Key", Item_Types.KEY, Item_Slots.NONE, 0, 0, 0, 0)
        Item_Register(71, "Brass Key", Item_Types.KEY, Item_Slots.NONE, 0, 0, 0, 0)
        Item_Register(72, "Skeleton Key", Item_Types.KEY, Item_Slots.NONE, 50, 0, 0, 0)
        
        Item_Register(80, "Bread", Item_Types.FOOD, Item_Slots.NONE, 3, 0, 0, 0)
        Item_Register(81, "Meat", Item_Types.FOOD, Item_Slots.NONE, 8, 0, 0, 0)
        
        ReturnValue(0)
    }
}

// ============================================
// SLOT NAME HELPER
// ============================================

Function.Item_GetSlotName {
    Input: slot: Integer
    Output: Address
    Body: {
        IfCondition EqualTo(slot, 0) ThenBlock: { ReturnValue("Weapon") }
        IfCondition EqualTo(slot, 1) ThenBlock: { ReturnValue("Armor") }
        IfCondition EqualTo(slot, 2) ThenBlock: { ReturnValue("Shield") }
        IfCondition EqualTo(slot, 3) ThenBlock: { ReturnValue("Helmet") }
        IfCondition EqualTo(slot, 4) ThenBlock: { ReturnValue("Ring") }
        IfCondition EqualTo(slot, 5) ThenBlock: { ReturnValue("Amulet") }
        ReturnValue("None")
    }
}

Function.Item_GetRarityName {
    Input: rarity: Integer
    Output: Address
    Body: {
        IfCondition EqualTo(rarity, 1) ThenBlock: { ReturnValue("Common") }
        IfCondition EqualTo(rarity, 2) ThenBlock: { ReturnValue("Uncommon") }
        IfCondition EqualTo(rarity, 3) ThenBlock: { ReturnValue("Rare") }
        IfCondition EqualTo(rarity, 4) ThenBlock: { ReturnValue("Epic") }
        IfCondition EqualTo(rarity, 5) ThenBlock: { ReturnValue("Legendary") }
        ReturnValue("Unknown")
    }
}

Function.Item_GetRarityColor {
    Input: rarity: Integer
    Output: Integer
    Body: {
        IfCondition EqualTo(rarity, 1) ThenBlock: { ReturnValue(7) }  // White
        IfCondition EqualTo(rarity, 2) ThenBlock: { ReturnValue(2) }  // Green
        IfCondition EqualTo(rarity, 3) ThenBlock: { ReturnValue(4) }  // Blue
        IfCondition EqualTo(rarity, 4) ThenBlock: { ReturnValue(5) }  // Magenta
        IfCondition EqualTo(rarity, 5) ThenBlock: { ReturnValue(3) }  // Yellow
        ReturnValue(7)
    }
}


// ============================================
// MISSING ITEM GETTER FUNCTIONS
// Add these to Library.Item.ailang
// ============================================

// Get HP bonus from item
Function.Item_GetHPBonus {
    Input: item_id: Integer
    Output: Integer
    Body: {
        IfCondition Or(LessThan(item_id, 0), GreaterEqual(item_id, Item_State.item_count)) ThenBlock: {
            ReturnValue(0)
        }
        offset = Multiply(item_id, Item_Offsets.SIZE)
        base = Add(Item_State.item_db, offset)
        ReturnValue(GetByte(base, Item_Offsets.HP_BONUS))
    }
}

// Get MP bonus from item
Function.Item_GetMPBonus {
    Input: item_id: Integer
    Output: Integer
    Body: {
        IfCondition Or(LessThan(item_id, 0), GreaterEqual(item_id, Item_State.item_count)) ThenBlock: {
            ReturnValue(0)
        }
        offset = Multiply(item_id, Item_Offsets.SIZE)
        base = Add(Item_State.item_db, offset)
        ReturnValue(GetByte(base, Item_Offsets.MP_BONUS))
    }
}

// Get item name
Function.Item_GetName {
    Input: item_id: Integer
    Output: Address
    Body: {
        IfCondition Or(LessThan(item_id, 0), GreaterEqual(item_id, Item_State.item_count)) ThenBlock: {
            ReturnValue(0)
        }
        offset = Multiply(item_id, Item_Offsets.SIZE)
        base = Add(Item_State.item_db, offset)
        ReturnValue(base)  // Name is at offset 0
    }
}

// Get item type
Function.Item_GetType {
    Input: item_id: Integer
    Output: Integer
    Body: {
        IfCondition Or(LessThan(item_id, 0), GreaterEqual(item_id, Item_State.item_count)) ThenBlock: {
            ReturnValue(0)
        }
        offset = Multiply(item_id, Item_Offsets.SIZE)
        base = Add(Item_State.item_db, offset)
        ReturnValue(GetByte(base, Item_Offsets.TYPE))
    }
}

// Get item slot
Function.Item_GetSlot {
    Input: item_id: Integer
    Output: Integer
    Body: {
        IfCondition Or(LessThan(item_id, 0), GreaterEqual(item_id, Item_State.item_count)) ThenBlock: {
            ReturnValue(255)
        }
        offset = Multiply(item_id, Item_Offsets.SIZE)
        base = Add(Item_State.item_db, offset)
        ReturnValue(GetByte(base, Item_Offsets.SLOT))
    }
}

// Get item value (gold)
Function.Item_GetValue {
    Input: item_id: Integer
    Output: Integer
    Body: {
        IfCondition Or(LessThan(item_id, 0), GreaterEqual(item_id, Item_State.item_count)) ThenBlock: {
            ReturnValue(0)
        }
        offset = Multiply(item_id, Item_Offsets.SIZE)
        base = Add(Item_State.item_db, offset)
        lo = GetByte(base, Item_Offsets.VALUE)
        hi = GetByte(base, Add(Item_Offsets.VALUE, 1))
        ReturnValue(Add(lo, Multiply(hi, 256)))
    }
}

// Get attack bonus
Function.Item_GetAtkBonus {
    Input: item_id: Integer
    Output: Integer
    Body: {
        IfCondition Or(LessThan(item_id, 0), GreaterEqual(item_id, Item_State.item_count)) ThenBlock: {
            ReturnValue(0)
        }
        offset = Multiply(item_id, Item_Offsets.SIZE)
        base = Add(Item_State.item_db, offset)
        ReturnValue(GetByte(base, Item_Offsets.ATK_BONUS))
    }
}

// Get defense bonus
Function.Item_GetDefBonus {
    Input: item_id: Integer
    Output: Integer
    Body: {
        IfCondition Or(LessThan(item_id, 0), GreaterEqual(item_id, Item_State.item_count)) ThenBlock: {
            ReturnValue(0)
        }
        offset = Multiply(item_id, Item_Offsets.SIZE)
        base = Add(Item_State.item_db, offset)
        ReturnValue(GetByte(base, Item_Offsets.DEF_BONUS))
    }
}

// Get magic bonus
Function.Item_GetMagBonus {
    Input: item_id: Integer
    Output: Integer
    Body: {
        IfCondition Or(LessThan(item_id, 0), GreaterEqual(item_id, Item_State.item_count)) ThenBlock: {
            ReturnValue(0)
        }
        offset = Multiply(item_id, Item_Offsets.SIZE)
        base = Add(Item_State.item_db, offset)
        ReturnValue(GetByte(base, Item_Offsets.MAG_BONUS))
    }
}

// Get required level
Function.Item_GetReqLevel {
    Input: item_id: Integer
    Output: Integer
    Body: {
        IfCondition Or(LessThan(item_id, 0), GreaterEqual(item_id, Item_State.item_count)) ThenBlock: {
            ReturnValue(0)
        }
        offset = Multiply(item_id, Item_Offsets.SIZE)
        base = Add(Item_State.item_db, offset)
        ReturnValue(GetByte(base, Item_Offsets.REQ_LEVEL))
    }
}

// Get rarity
Function.Item_GetRarity {
    Input: item_id: Integer
    Output: Integer
    Body: {
        IfCondition Or(LessThan(item_id, 0), GreaterEqual(item_id, Item_State.item_count)) ThenBlock: {
            ReturnValue(0)
        }
        offset = Multiply(item_id, Item_Offsets.SIZE)
        base = Add(Item_State.item_db, offset)
        ReturnValue(GetByte(base, Item_Offsets.RARITY))
    }
}