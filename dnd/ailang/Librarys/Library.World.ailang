// ============================================
// Library.World.ailang
// World & Map Transition System
// ============================================
//
// Dragon Warrior style world structure:
//   - Overworld (towns/dungeons as tiles)
//   - Towns (enter from overworld)
//   - Dungeons (multiple floors via stairs)
//   - Buildings (enter from towns)
//
// Maps have PORTALS that warp to other maps
//
// ============================================

LibraryImport.TUI

// ============================================
// CONSTANTS
// ============================================

FixedPool.World_Limits {
    "MAX_MAPS": Initialize=32
    "MAX_PORTALS": Initialize=20      
    "MAP_NAME_LEN": Initialize=32
    "MAP_PATH_LEN": Initialize=64
}

// Map types
FixedPool.Map_Types {
    "OVERWORLD": Initialize=1
    "TOWN": Initialize=2
    "DUNGEON": Initialize=3
    "BUILDING": Initialize=4
    "CAVE": Initialize=5
}

// Portal types (what triggers transition)
FixedPool.Portal_Types {
    "STAIRS_DOWN": Initialize=1
    "STAIRS_UP": Initialize=2
    "DOOR": Initialize=3
    "ENTRANCE": Initialize=4     
    "EXIT": Initialize=5        
}

// ============================================
// PORTAL STRUCTURE (24 bytes)
// ============================================
// 0-1:   Source X (2 bytes)
// 2-3:   Source Y (2 bytes)
// 4:     Type (1 byte)
// 5:     Dest Map ID (1 byte)
// 6-7:   Dest X (2 bytes)
// 8-9:   Dest Y (2 bytes)
// 10:    Flags (1 byte) - locked, one-way, etc
// 11:    Key required (item ID, 0=none)
// 12-23: Reserved

FixedPool.Portal_Offsets {
    "SRC_X": Initialize=0
    "SRC_Y": Initialize=2
    "TYPE": Initialize=4
    "DEST_MAP": Initialize=5
    "DEST_X": Initialize=6
    "DEST_Y": Initialize=8
    "FLAGS": Initialize=10
    "KEY_ID": Initialize=11
    "SIZE": Initialize=24
}

// Portal flags
FixedPool.Portal_Flags {
    "LOCKED": Initialize=1
    "ONE_WAY": Initialize=2
    "HIDDEN": Initialize=4
    "REQUIRES_KEY": Initialize=8
}

// ============================================
// MAP DEFINITION (128 bytes)
// ============================================
// 0-31:   Name (32 bytes)
// 32-95:  File path (64 bytes)
// 96:     ID (1 byte)
// 97:     Type (1 byte)
// 98:     Parent map ID (1 byte) - for "exit" logic
// 99:     Parent X (return position)
// 100:    Parent Y
// 101:    Width (1 byte)
// 102:    Height (1 byte)
// 103:    Flags (1 byte)
// 104-105: Portal count (2 bytes)
// 106-127: Reserved

FixedPool.MapDef_Offsets {
    "NAME": Initialize=0
    "PATH": Initialize=32
    "ID": Initialize=96
    "TYPE": Initialize=97
    "PARENT_MAP": Initialize=98
    "PARENT_X": Initialize=99
    "PARENT_Y": Initialize=100
    "WIDTH": Initialize=101
    "HEIGHT": Initialize=102
    "FLAGS": Initialize=103
    "PORTAL_COUNT": Initialize=104
    "SIZE": Initialize=128
}

// ============================================
// WORLD STATE
// ============================================

FixedPool.World_State {
    "maps": Initialize=0          
    "map_count": Initialize=0
    "portals": Initialize=0        
    "current_map": Initialize=0    
    "map_data": Initialize=0      
    "map_width": Initialize=0
    "map_height": Initialize=0
    "initialized": Initialize=0
}

// Return stack for exiting maps
FixedPool.World_ReturnStack {
    "data": Initialize=0           
    "depth": Initialize=0         
    "max_depth": Initialize=8
}

// ============================================
// INITIALIZATION
// ============================================

Function.World_Init {
    Body: {
        // Allocate map definitions
        maps_size = Multiply(World_Limits.MAX_MAPS, MapDef_Offsets.SIZE)
        World_State.maps = Allocate(maps_size)
        World_State.map_count = 0
        
        // Clear maps
        i = 0
        WhileLoop LessThan(i, maps_size) {
            SetByte(World_State.maps, i, 0)
            i = Add(i, 1)
        }
        
        // Allocate portals (MAX_MAPS * MAX_PORTALS * Portal size)
        portals_size = Multiply(Multiply(World_Limits.MAX_MAPS, World_Limits.MAX_PORTALS), Portal_Offsets.SIZE)
        World_State.portals = Allocate(portals_size)
        
        // Clear portals
        i = 0
        WhileLoop LessThan(i, portals_size) {
            SetByte(World_State.portals, i, 0)
            i = Add(i, 1)
        }
        
        // Allocate map data (80x40 max)
        World_State.map_data = Allocate(3200)
        
        // Allocate return stack (8 entries * 4 bytes each)
        World_ReturnStack.data = Allocate(32)
        World_ReturnStack.depth = 0
        
        World_State.current_map = 0
        World_State.initialized = 1
        
        ReturnValue(0)
    }
}

Function.World_Cleanup {
    Body: {
        IfCondition NotEqual(World_State.maps, 0) ThenBlock: {
            maps_size = Multiply(World_Limits.MAX_MAPS, MapDef_Offsets.SIZE)
            Deallocate(World_State.maps, maps_size)
        }
        IfCondition NotEqual(World_State.portals, 0) ThenBlock: {
            portals_size = Multiply(Multiply(World_Limits.MAX_MAPS, World_Limits.MAX_PORTALS), Portal_Offsets.SIZE)
            Deallocate(World_State.portals, portals_size)
        }
        IfCondition NotEqual(World_State.map_data, 0) ThenBlock: {
            Deallocate(World_State.map_data, 3200)
        }
        IfCondition NotEqual(World_ReturnStack.data, 0) ThenBlock: {
            Deallocate(World_ReturnStack.data, 32)
        }
        ReturnValue(0)
    }
}

// ============================================
// MAP REGISTRATION
// ============================================

Function.World_RegisterMap {
    Input: id: Integer
    Input: name: Address
    Input: path: Address
    Input: map_type: Integer
    Input: parent_id: Integer
    Output: Integer
    Body: {
        IfCondition GreaterEqual(id, World_Limits.MAX_MAPS) ThenBlock: {
            ReturnValue(-1)
        }
        
        offset = Multiply(id, MapDef_Offsets.SIZE)
        base = Add(World_State.maps, offset)
        
        // Copy name
        i = 0
        WhileLoop LessThan(i, 31) {
            ch = GetByte(name, i)
            SetByte(base, i, ch)
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            i = Add(i, 1)
        }
        SetByte(base, 31, 0)
        
        // Copy path
        i = 0
        WhileLoop LessThan(i, 63) {
            ch = GetByte(path, i)
            SetByte(base, Add(MapDef_Offsets.PATH, i), ch)
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            i = Add(i, 1)
        }
        SetByte(base, Add(MapDef_Offsets.PATH, 63), 0)
        
        // Set properties
        SetByte(base, MapDef_Offsets.ID, id)
        SetByte(base, MapDef_Offsets.TYPE, map_type)
        SetByte(base, MapDef_Offsets.PARENT_MAP, parent_id)
        SetByte(base, MapDef_Offsets.PARENT_X, 0)
        SetByte(base, MapDef_Offsets.PARENT_Y, 0)
        SetByte(base, MapDef_Offsets.PORTAL_COUNT, 0)
        
        IfCondition GreaterEqual(id, World_State.map_count) ThenBlock: {
            World_State.map_count = Add(id, 1)
        }
        
        ReturnValue(id)
    }
}

// ============================================
// PORTAL MANAGEMENT
// ============================================

Function.World_GetPortalBase {
    Input: map_id: Integer
    Input: portal_idx: Integer
    Output: Address
    Body: {
        // Each map has MAX_PORTALS slots
        map_offset = Multiply(map_id, Multiply(World_Limits.MAX_PORTALS, Portal_Offsets.SIZE))
        portal_offset = Multiply(portal_idx, Portal_Offsets.SIZE)
        total_offset = Add(map_offset, portal_offset)
        ReturnValue(Add(World_State.portals, total_offset))
    }
}

Function.World_AddPortal {
    Input: map_id: Integer
    Input: src_x: Integer
    Input: src_y: Integer
    Input: portal_type: Integer
    Input: dest_map: Integer
    Input: dest_x: Integer
    Input: dest_y: Integer
    Output: Integer
    Body: {
        // Get portal count for this map
        map_offset = Multiply(map_id, MapDef_Offsets.SIZE)
        map_base = Add(World_State.maps, map_offset)
        portal_count = GetByte(map_base, MapDef_Offsets.PORTAL_COUNT)
        
        IfCondition GreaterEqual(portal_count, World_Limits.MAX_PORTALS) ThenBlock: {
            ReturnValue(-1)
        }
        
        // Add portal
        portal_base = World_GetPortalBase(map_id, portal_count)
        
        // Set source position
        SetByte(portal_base, Portal_Offsets.SRC_X, BitwiseAnd(src_x, 255))
        SetByte(portal_base, Add(Portal_Offsets.SRC_X, 1), RightShift(src_x, 8))
        SetByte(portal_base, Portal_Offsets.SRC_Y, BitwiseAnd(src_y, 255))
        SetByte(portal_base, Add(Portal_Offsets.SRC_Y, 1), RightShift(src_y, 8))
        
        // Set type and destination
        SetByte(portal_base, Portal_Offsets.TYPE, portal_type)
        SetByte(portal_base, Portal_Offsets.DEST_MAP, dest_map)
        SetByte(portal_base, Portal_Offsets.DEST_X, BitwiseAnd(dest_x, 255))
        SetByte(portal_base, Add(Portal_Offsets.DEST_X, 1), RightShift(dest_x, 8))
        SetByte(portal_base, Portal_Offsets.DEST_Y, BitwiseAnd(dest_y, 255))
        SetByte(portal_base, Add(Portal_Offsets.DEST_Y, 1), RightShift(dest_y, 8))
        
        SetByte(portal_base, Portal_Offsets.FLAGS, 0)
        SetByte(portal_base, Portal_Offsets.KEY_ID, 0)
        
        // Increment portal count
        SetByte(map_base, MapDef_Offsets.PORTAL_COUNT, Add(portal_count, 1))
        
        ReturnValue(portal_count)
    }
}

Function.World_AddLockedPortal {
    Input: map_id: Integer
    Input: src_x: Integer
    Input: src_y: Integer
    Input: portal_type: Integer
    Input: dest_map: Integer
    Input: dest_x: Integer
    Input: dest_y: Integer
    Input: key_id: Integer
    Output: Integer
    Body: {
        idx = World_AddPortal(map_id, src_x, src_y, portal_type, dest_map, dest_x, dest_y)
        IfCondition LessThan(idx, 0) ThenBlock: {
            ReturnValue(idx)
        }
        
        portal_base = World_GetPortalBase(map_id, idx)
        SetByte(portal_base, Portal_Offsets.FLAGS, Portal_Flags.REQUIRES_KEY)
        SetByte(portal_base, Portal_Offsets.KEY_ID, key_id)
        
        ReturnValue(idx)
    }
}

// ============================================
// PORTAL LOOKUP
// ============================================

Function.World_GetPortalAt {
    Input: map_id: Integer
    Input: x: Integer
    Input: y: Integer
    Output: Integer
    Body: {
        map_offset = Multiply(map_id, MapDef_Offsets.SIZE)
        map_base = Add(World_State.maps, map_offset)
        portal_count = GetByte(map_base, MapDef_Offsets.PORTAL_COUNT)
        
        i = 0
        WhileLoop LessThan(i, portal_count) {
            portal_base = World_GetPortalBase(map_id, i)
            
            px = Add(GetByte(portal_base, Portal_Offsets.SRC_X), Multiply(GetByte(portal_base, Add(Portal_Offsets.SRC_X, 1)), 256))
            py = Add(GetByte(portal_base, Portal_Offsets.SRC_Y), Multiply(GetByte(portal_base, Add(Portal_Offsets.SRC_Y, 1)), 256))
            
            IfCondition And(EqualTo(px, x), EqualTo(py, y)) ThenBlock: {
                ReturnValue(i)
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(-1)  // No portal at this position
    }
}

Function.World_GetPortalInfo {
    Input: map_id: Integer
    Input: portal_idx: Integer
    Input: info_type: Integer
    Output: Integer
    Body: {
        portal_base = World_GetPortalBase(map_id, portal_idx)
        
        // info_type: 0=type, 1=dest_map, 2=dest_x, 3=dest_y, 4=flags, 5=key_id
        IfCondition EqualTo(info_type, 0) ThenBlock: {
            ReturnValue(GetByte(portal_base, Portal_Offsets.TYPE))
        }
        IfCondition EqualTo(info_type, 1) ThenBlock: {
            ReturnValue(GetByte(portal_base, Portal_Offsets.DEST_MAP))
        }
        IfCondition EqualTo(info_type, 2) ThenBlock: {
            ReturnValue(Add(GetByte(portal_base, Portal_Offsets.DEST_X), Multiply(GetByte(portal_base, Add(Portal_Offsets.DEST_X, 1)), 256)))
        }
        IfCondition EqualTo(info_type, 3) ThenBlock: {
            ReturnValue(Add(GetByte(portal_base, Portal_Offsets.DEST_Y), Multiply(GetByte(portal_base, Add(Portal_Offsets.DEST_Y, 1)), 256)))
        }
        IfCondition EqualTo(info_type, 4) ThenBlock: {
            ReturnValue(GetByte(portal_base, Portal_Offsets.FLAGS))
        }
        IfCondition EqualTo(info_type, 5) ThenBlock: {
            ReturnValue(GetByte(portal_base, Portal_Offsets.KEY_ID))
        }
        
        ReturnValue(0)
    }
}

// ============================================
// RETURN STACK (for exiting maps)
// ============================================

Function.World_PushReturn {
    Input: map_id: Integer
    Input: x: Integer
    Input: y: Integer
    Body: {
        depth = World_ReturnStack.depth
        IfCondition GreaterEqual(depth, World_ReturnStack.max_depth) ThenBlock: {
            ReturnValue(-1)  // Stack full
        }
        
        // Each entry: 4 bytes (map_id, x, y, padding)
        offset = Multiply(depth, 4)
        base = Add(World_ReturnStack.data, offset)
        
        SetByte(base, 0, map_id)
        SetByte(base, 1, x)
        SetByte(base, 2, y)
        SetByte(base, 3, 0)
        
        World_ReturnStack.depth = Add(depth, 1)
        ReturnValue(0)
    }
}

Function.World_PopReturn {
    Output: Integer
    Body: {
        depth = World_ReturnStack.depth
        IfCondition EqualTo(depth, 0) ThenBlock: {
            ReturnValue(-1)  // Stack empty
        }
        
        World_ReturnStack.depth = Subtract(depth, 1)
        
        offset = Multiply(Subtract(depth, 1), 4)
        base = Add(World_ReturnStack.data, offset)
        
        // Pack into single int: map_id | (x << 8) | (y << 16)
        map_id = GetByte(base, 0)
        x = GetByte(base, 1)
        y = GetByte(base, 2)
        
        result = Add(map_id, Add(Multiply(x, 256), Multiply(y, 65536)))
        ReturnValue(result)
    }
}

Function.World_PeekReturnMap {
    Output: Integer
    Body: {
        depth = World_ReturnStack.depth
        IfCondition EqualTo(depth, 0) ThenBlock: {
            ReturnValue(-1)
        }
        
        offset = Multiply(Subtract(depth, 1), 4)
        base = Add(World_ReturnStack.data, offset)
        ReturnValue(GetByte(base, 0))
    }
}

// ============================================
// MAP ACCESSORS
// ============================================

Function.World_GetMapName {
    Input: map_id: Integer
    Output: Address
    Body: {
        offset = Multiply(map_id, MapDef_Offsets.SIZE)
        base = Add(World_State.maps, offset)
        ReturnValue(base)  // Name is at offset 0
    }
}

Function.World_GetMapPath {
    Input: map_id: Integer
    Output: Address
    Body: {
        offset = Multiply(map_id, MapDef_Offsets.SIZE)
        base = Add(World_State.maps, offset)
        ReturnValue(Add(base, MapDef_Offsets.PATH))
    }
}

Function.World_GetMapType {
    Input: map_id: Integer
    Output: Integer
    Body: {
        offset = Multiply(map_id, MapDef_Offsets.SIZE)
        base = Add(World_State.maps, offset)
        ReturnValue(GetByte(base, MapDef_Offsets.TYPE))
    }
}

Function.World_GetMapParent {
    Input: map_id: Integer
    Output: Integer
    Body: {
        offset = Multiply(map_id, MapDef_Offsets.SIZE)
        base = Add(World_State.maps, offset)
        ReturnValue(GetByte(base, MapDef_Offsets.PARENT_MAP))
    }
}

Function.World_GetCurrentMap {
    Output: Integer
    Body: {
        ReturnValue(World_State.current_map)
    }
}

Function.World_SetCurrentMap {
    Input: map_id: Integer
    Body: {
        World_State.current_map = map_id
        ReturnValue(0)
    }
}

// ============================================
// MAP TRANSITIONS
// ============================================

// Check if player can use a portal (key requirements, etc)
Function.World_CanUsePortal {
    Input: map_id: Integer
    Input: portal_idx: Integer
    Output: Integer
    Body: {
        flags = World_GetPortalInfo(map_id, portal_idx, 4)
        
        // Check if requires key
        IfCondition NotEqual(BitwiseAnd(flags, Portal_Flags.REQUIRES_KEY), 0) ThenBlock: {
            key_id = World_GetPortalInfo(map_id, portal_idx, 5)
            // Check if player has key (using Item library)
            // has_key = Item_InvHasItem(key_id)
            // For now, just return 0 if locked
            ReturnValue(0)
        }
        
        ReturnValue(1)
    }
}

// Get transition info when stepping on a portal tile
// Returns: 0 = no transition, 1 = can transition
Function.World_CheckTransition {
    Input: x: Integer
    Input: y: Integer
    Output: Integer
    Body: {
        map_id = World_State.current_map
        portal_idx = World_GetPortalAt(map_id, x, y)
        
        IfCondition LessThan(portal_idx, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        can_use = World_CanUsePortal(map_id, portal_idx)
        IfCondition EqualTo(can_use, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        ReturnValue(1)
    }
}

// Execute a map transition
// Returns packed value: dest_map | (dest_x << 8) | (dest_y << 16)
Function.World_DoTransition {
    Input: x: Integer
    Input: y: Integer
    Input: current_x: Integer
    Input: current_y: Integer
    Output: Integer
    Body: {
        map_id = World_State.current_map
        portal_idx = World_GetPortalAt(map_id, x, y)
        
        IfCondition LessThan(portal_idx, 0) ThenBlock: {
            ReturnValue(-1)
        }
        
        portal_type = World_GetPortalInfo(map_id, portal_idx, 0)
        dest_map = World_GetPortalInfo(map_id, portal_idx, 1)
        dest_x = World_GetPortalInfo(map_id, portal_idx, 2)
        dest_y = World_GetPortalInfo(map_id, portal_idx, 3)
        
        // Push return position for non-one-way portals
        flags = World_GetPortalInfo(map_id, portal_idx, 4)
        IfCondition EqualTo(BitwiseAnd(flags, Portal_Flags.ONE_WAY), 0) ThenBlock: {
            // For entrance/stairs down, save current position
            IfCondition Or(EqualTo(portal_type, Portal_Types.ENTRANCE), EqualTo(portal_type, Portal_Types.STAIRS_DOWN)) ThenBlock: {
                World_PushReturn(map_id, current_x, current_y)
            }
        }
        
        // Update current map
        World_State.current_map = dest_map
        
        // Return packed destination
        result = Add(dest_map, Add(Multiply(dest_x, 256), Multiply(dest_y, 65536)))
        ReturnValue(result)
    }
}

// Exit current map (go back to parent/return stack)
Function.World_ExitMap {
    Output: Integer
    Body: {
        // Try return stack first
        result = World_PopReturn()
        IfCondition GreaterEqual(result, 0) ThenBlock: {
            dest_map = BitwiseAnd(result, 255)
            World_State.current_map = dest_map
            ReturnValue(result)
        }
        
        // Fall back to parent map
        map_id = World_State.current_map
        parent = World_GetMapParent(map_id)
        
        IfCondition GreaterThan(parent, 0) ThenBlock: {
            offset = Multiply(map_id, MapDef_Offsets.SIZE)
            base = Add(World_State.maps, offset)
            
            parent_x = GetByte(base, MapDef_Offsets.PARENT_X)
            parent_y = GetByte(base, MapDef_Offsets.PARENT_Y)
            
            World_State.current_map = parent
            
            result = Add(parent, Add(Multiply(parent_x, 256), Multiply(parent_y, 65536)))
            ReturnValue(result)
        }
        
        ReturnValue(-1)  // Can't exit
    }
}

// ============================================
// HELPER: Unpack transition result
// ============================================

Function.World_UnpackMap {
    Input: packed: Integer
    Output: Integer
    Body: {
        ReturnValue(BitwiseAnd(packed, 255))
    }
}

Function.World_UnpackX {
    Input: packed: Integer
    Output: Integer
    Body: {
        ReturnValue(BitwiseAnd(RightShift(packed, 8), 255))
    }
}

Function.World_UnpackY {
    Input: packed: Integer
    Output: Integer
    Body: {
        ReturnValue(BitwiseAnd(RightShift(packed, 16), 255))
    }
}

// ============================================
// DEFAULT WORLD SETUP
// ============================================

Function.World_SetupDefault {
    Body: {
        // Map 0: Overworld
        World_RegisterMap(0, "Overworld", "maps/overworld.dndmap", Map_Types.OVERWORLD, 0)
        
        // Map 1: Starting Town
        World_RegisterMap(1, "Hometown", "maps/hometown.dndmap", Map_Types.TOWN, 0)
        
        // Map 2: Dungeon Level 1
        World_RegisterMap(2, "Dark Cave B1", "maps/cave_b1.dndmap", Map_Types.DUNGEON, 0)
        
        // Map 3: Dungeon Level 2
        World_RegisterMap(3, "Dark Cave B2", "maps/cave_b2.dndmap", Map_Types.DUNGEON, 2)
        
        // Map 4: Castle
        World_RegisterMap(4, "Castle", "maps/castle.dndmap", Map_Types.BUILDING, 0)
        
        // === PORTALS ===
        
        // Overworld entrances
        // Town entrance at overworld (10,10) -> Town (5,14)
        World_AddPortal(0, 10, 10, Portal_Types.ENTRANCE, 1, 5, 14)
        
        // Dungeon entrance at overworld (20,15) -> Cave B1 (3,3)
        World_AddPortal(0, 20, 15, Portal_Types.ENTRANCE, 2, 3, 3)
        
        // Castle entrance at overworld (15,5) -> Castle (10,18)
        World_AddPortal(0, 15, 5, Portal_Types.ENTRANCE, 4, 10, 18)
        
        // Town exit -> Overworld
        World_AddPortal(1, 5, 15, Portal_Types.EXIT, 0, 10, 11)
        
        // Dungeon B1 stairs down -> B2
        World_AddPortal(2, 15, 10, Portal_Types.STAIRS_DOWN, 3, 3, 3)
        
        // Dungeon B1 exit -> Overworld
        World_AddPortal(2, 3, 2, Portal_Types.EXIT, 0, 20, 16)
        
        // Dungeon B2 stairs up -> B1
        World_AddPortal(3, 3, 3, Portal_Types.STAIRS_UP, 2, 15, 11)
        
        // Castle exit
        World_AddPortal(4, 10, 19, Portal_Types.EXIT, 0, 15, 6)
        
        ReturnValue(0)
    }
}

// ============================================
// GET PORTAL TYPE NAME (for messages)
// ============================================

Function.World_GetPortalTypeName {
    Input: portal_type: Integer
    Output: Address
    Body: {
        IfCondition EqualTo(portal_type, Portal_Types.STAIRS_DOWN) ThenBlock: {
            ReturnValue("stairs leading down")
        }
        IfCondition EqualTo(portal_type, Portal_Types.STAIRS_UP) ThenBlock: {
            ReturnValue("stairs leading up")
        }
        IfCondition EqualTo(portal_type, Portal_Types.DOOR) ThenBlock: {
            ReturnValue("a door")
        }
        IfCondition EqualTo(portal_type, Portal_Types.ENTRANCE) ThenBlock: {
            ReturnValue("an entrance")
        }
        IfCondition EqualTo(portal_type, Portal_Types.EXIT) ThenBlock: {
            ReturnValue("an exit")
        }
        ReturnValue("a passage")
    }
}