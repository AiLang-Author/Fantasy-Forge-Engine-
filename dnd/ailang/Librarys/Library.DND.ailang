// ============================================
// Library.DND.ailang
// D&D-style RPG Game Engine
// Uses Library.TUI for display
// ============================================
//
// DATA FORMAT:
//   Maps: .dndmap files (ASCII grid + metadata)
//   Data: .dnddat files (CSV-like structured data)
//
// EXPANDABLE DESIGN:
//   - Add rooms by editing map files
//   - Add monsters/items via data files
//   - Supports multiple dungeons
//
// ============================================

LibraryImport.GameConfig
LibraryImport.TUI
LibraryImport.DICE
LibraryImport.Character
LibraryImport.Item
LibraryImport.EquipScreen
LibraryImport.World
LibraryImport.Save
LibraryImport.SaveScreen
LibraryImport.Inn
LibraryImport.Shop
LibraryImport.BattleScreen

// ============================================
// GAME CONSTANTS
// ============================================

FixedPool.DND_Limits {
    "MAX_MAP_WIDTH": Initialize=80
    "MAX_MAP_HEIGHT": Initialize=40
    "MAX_ROOMS": Initialize=50
    "MAX_ITEMS": Initialize=100
    "MAX_MONSTERS": Initialize=50
    "MAX_INVENTORY": Initialize=20
    "MAX_NAME_LEN": Initialize=32
    "MAX_DESC_LEN": Initialize=256
}

// Map tile types
FixedPool.DND_Tiles {
    "WALL": Initialize=35 
    "MAP_EXIT": Initialize=39       
    "FLOOR": Initialize=46        
    "DOOR": Initialize=43       
    "DOOR_OPEN": Initialize=45   
    "DOOR_LOCKED": Initialize=88  
    "STAIRS_UP": Initialize=60    
    "STAIRS_DOWN": Initialize=62 
    "WATER": Initialize=126      
    "TRAP": Initialize=94         
    "CHEST": Initialize=42       
    "PLAYER": Initialize=64      
    "MONSTER": Initialize=77     
    "NPC": Initialize=78          
    "ITEM": Initialize=33        
    "GOLD": Initialize=36         
    "EMPTY": Initialize=32
    "SHOP": Initialize=83
}

// Tile colors
FixedPool.DND_TileColors {
    "WALL_FG": Initialize=7      
    "FLOOR_FG": Initialize=7    
    "DOOR_FG": Initialize=3      
    "WATER_FG": Initialize=4      
    "TRAP_FG": Initialize=1     
    "PLAYER_FG": Initialize=2    
    "MONSTER_FG": Initialize=1    
    "ITEM_FG": Initialize=5       
    "GOLD_FG": Initialize=3
    "SHOP_FG": Initialize=6
}

// Character stats
FixedPool.DND_Stats {
    "STR": Initialize=0
    "DEX": Initialize=1
    "CON": Initialize=2
    "INT": Initialize=3
    "WIS": Initialize=4
    "CHA": Initialize=5
}

// Item types
FixedPool.DND_ItemTypes {
    "WEAPON": Initialize=1
    "ARMOR": Initialize=2
    "POTION": Initialize=3
    "SCROLL": Initialize=4
    "KEY": Initialize=5
    "GOLD": Initialize=6
    "FOOD": Initialize=7
    "MISC": Initialize=8
}

// Combat actions
FixedPool.DND_Actions {
    "ATTACK": Initialize=1
    "DEFEND": Initialize=2
    "CAST": Initialize=3
    "USE_ITEM": Initialize=4
    "FLEE": Initialize=5
}

// ============================================
// GAME STATE
// ============================================

FixedPool.DND_GameState {
    "running": Initialize=1
    "current_level": Initialize=1
    "turn_count": Initialize=0
    "game_mode": Initialize=0     
    "message_count": Initialize=0
}

// ============================================
// MONSTER SYSTEM
// ============================================

FixedPool.DND_MonsterLimits {
    "MAX_MONSTERS": Initialize=20
    "MONSTER_SIZE": Initialize=48   
}

// Monster structure offsets (48 bytes each)
// 0: alive (1 byte)
// 1: type (1 byte)  
// 2: x (2 bytes)
// 4: y (2 bytes)
// 6: hp (2 bytes)
// 8: max_hp (2 bytes)
// 10: ac (2 bytes)
// 12: damage_dice (1 byte)
// 13: damage_sides (1 byte)
// 14: damage_mod (1 byte)
// 15: xp_value (2 bytes)
// 17: symbol (1 byte)
// 18-47: name (30 bytes)

FixedPool.DND_Monsters {
    "data": Initialize=0
    "count": Initialize=0
}

// Player data - now uses Character library
FixedPool.DND_Player {
    "x": Initialize=5
    "y": Initialize=5
    "char_data": Initialize=0
    "gold": Initialize=0
}

// Quick accessors for common player stats
FixedPool.DND_PlayerCache {
    "name": Initialize=0
    "class_name": Initialize=0
}

// Current map
FixedPool.DND_Map {
    "data": Initialize=0
    "width": Initialize=0
    "height": Initialize=0
    "name": Initialize=0
    "level": Initialize=1
    "start_x": Initialize=5
    "start_y": Initialize=5
}

// View settings
FixedPool.DND_View {
    "map_start_row": Initialize=2
    "map_start_col": Initialize=1
    "map_view_width": Initialize=60
    "map_view_height": Initialize=20
    "stats_col": Initialize=62
    "msg_row": Initialize=23
    "input_row": Initialize=24
}

// Message buffer
FixedPool.DND_Messages {
    "buffer": Initialize=0
    "count": Initialize=0
    "max_messages": Initialize=5
}

// ============================================
// INITIALIZATION
// ============================================

Function.DND_Init {
    // NOTE: Map loading now happens in main via Config system!
    Body: {
        // Initialize TUI
        TUI_Init()
        
        // Initialize Dice
        Dice_Init()
        
        // Initialize Character system
        Char_Init()
        Char_LoadDefaults()  // Use defaults, or Char_LoadData("assets") for files
        
        // Initialize Item system
        Item_Init()
        Item_RegisterDefaults()
        
        // Initialize save system
        Save_Init()
        
        // Initialize inn system
        Inn_Init()
        Inn_RegisterDefaults()
        Battle_Init()
        
        // Initialize shop system
        Shop_Init()
        Shop_RegisterDefaults()
        
        // Allocate map data (max 80x40)
        map_size = Multiply(DND_Limits.MAX_MAP_WIDTH, DND_Limits.MAX_MAP_HEIGHT)
        DND_Map.data = Allocate(map_size)
        
        // Clear map to walls
        i = 0
        WhileLoop LessThan(i, map_size) {
            SetByte(DND_Map.data, i, DND_Tiles.WALL)
            i = Add(i, 1)
        }
        
        // Allocate message buffer
        DND_Messages.buffer = Allocate(Multiply(DND_Messages.max_messages, DND_Limits.MAX_DESC_LEN))
        DND_Messages.count = 0
        
        // Allocate map name
        DND_Map.name = Allocate(64)
        
        // Allocate monster array
        monster_size = Multiply(DND_MonsterLimits.MAX_MONSTERS, DND_MonsterLimits.MONSTER_SIZE)
        DND_Monsters.data = Allocate(monster_size)
        DND_Monsters.count = 0
        
        // Clear monster data
        i = 0
        WhileLoop LessThan(i, monster_size) {
            SetByte(DND_Monsters.data, i, 0)
            i = Add(i, 1)
        }
        
        // Create default character (will be replaced by char creation screen)
        DND_Player.char_data = Char_Create("Hero", Char_Classes.WARRIOR)
        DND_Player.gold = 0
        
        // Give player starting equipment
        DND_GiveStartingGear()
        
        // Give items from config
        i = 0
        WhileLoop LessThan(i, Config_State.start_item_count) {
            item_base = Add(Config_State.start_items, Multiply(i, 4)) // 4 bytes per item entry
            
            // Get item_id (2 bytes)
            item_id = Add(GetByte(item_base, 0), Multiply(GetByte(item_base, 1), 256))
            
            // Get quantity (2 bytes)
            qty = Add(GetByte(item_base, 2), Multiply(GetByte(item_base, 3), 256))
            
            IfCondition And(GreaterThan(item_id, 0), GreaterThan(qty, 0)) ThenBlock: {
                Item_InvAdd(item_id, qty)
            }
            
            i = Add(i, 1)
        }
        
        DND_GameState.running = 1
        
        
        ReturnValue(0)
    }
}

Function.DND_Cleanup {
    Body: {
        Battle_Cleanup()
        IfCondition NotEqual(DND_Map.data, 0) ThenBlock: {
            map_size = Multiply(DND_Limits.MAX_MAP_WIDTH, DND_Limits.MAX_MAP_HEIGHT)
            Deallocate(DND_Map.data, map_size)
        }
        IfCondition NotEqual(DND_Player.char_data, 0) ThenBlock: {
            Deallocate(DND_Player.char_data, Char_Offsets.SIZE)
        }
        IfCondition NotEqual(DND_Messages.buffer, 0) ThenBlock: {
            Deallocate(DND_Messages.buffer, Multiply(DND_Messages.max_messages, DND_Limits.MAX_DESC_LEN))
        }
        IfCondition NotEqual(DND_Map.name, 0) ThenBlock: {
            Deallocate(DND_Map.name, 64)
        }
        IfCondition NotEqual(DND_Monsters.data, 0) ThenBlock: {
            monster_size = Multiply(DND_MonsterLimits.MAX_MONSTERS, DND_MonsterLimits.MONSTER_SIZE)
            Deallocate(DND_Monsters.data, monster_size)
        }
        Shop_Cleanup()
        Item_Cleanup()
        World_Cleanup()
        Save_Cleanup()
        Char_Cleanup()
        TUI_Shutdown()
        ReturnValue(0)
    }
}

Function.DND_GiveStartingGear {
    Body: {
        // Give starting weapon based on class
        char_data = DND_Player.char_data
        class_id = Char_GetClass(char_data)
        
        IfCondition EqualTo(class_id, Char_Classes.WARRIOR) ThenBlock: {
            Item_Equip(2)      // Iron Sword
            Item_Equip(11)     // Leather Armor
            Item_Equip(20)     // Wooden Shield
        }
        IfCondition EqualTo(class_id, Char_Classes.MAGE) ThenBlock: {
            Item_Equip(7)      // Staff
            Item_Equip(14)     // Mage Robes
            Item_Equip(32)     // Wizard Hat
        }
        IfCondition EqualTo(class_id, Char_Classes.ROGUE) ThenBlock: {
            Item_Equip(5)      // Dagger
            Item_Equip(11)     // Leather Armor
            Item_Equip(30)     // Leather Cap
        }
        IfCondition EqualTo(class_id, Char_Classes.CLERIC) ThenBlock: {
            Item_Equip(8)      // Mace
            Item_Equip(12)     // Chain Mail
            Item_Equip(21)     // Iron Shield
        }
        IfCondition EqualTo(class_id, Char_Classes.RANGER) ThenBlock: {
            Item_Equip(2)      // Iron Sword
            Item_Equip(11)     // Leather Armor
            Item_Equip(30)     // Leather Cap
        }
        
        // Give some starting potions
        Item_InvAdd(60, 3)     // 3 Health Potions
        Item_InvAdd(61, 2)     // 2 Mana Potions
        
        ReturnValue(0)
    }
}

Function.DND_GetInnAtPlayer {
    Output: Integer
    Body: {
        current_map = DND_Map.level
        inn_id = Inn_GetAtPosition(current_map, DND_Player.x, DND_Player.y)
        ReturnValue(inn_id)
    }
}

Function.DND_InteractInn {
    Input: inn_id: Integer
    Body: {
        map_name = DND_Map.name
        
        // Create temporary pointer for gold (can't AddressOf a FixedPool field)
        gold_ptr = Allocate(8)
        StoreValue(gold_ptr, DND_Player.gold)
        
        Inn_ShowMenu_v2(inn_id, DND_Player.char_data, 0, 1, gold_ptr, DND_Player.x, DND_Player.y, DND_Map.level)
        
        // Write modified gold back to FixedPool
        DND_Player.gold = Dereference(gold_ptr)
        Deallocate(gold_ptr, 8)
        
        ReturnValue(0)
    }
}

Function.DND_InteractInn_Party {
    Input: inn_id: Integer
    Input: party: Address
    Input: party_count: Integer
    Body: {
        map_name = DND_Map.name
        
        // Create temporary pointer for gold
        gold_ptr = Allocate(8)
        StoreValue(gold_ptr, DND_Player.gold)
        
        Inn_ShowMenu_v2(inn_id, Dereference(party), party, party_count, gold_ptr, DND_Player.x, DND_Player.y, DND_Map.level)
        
        // Write back to FixedPool
        DND_Player.gold = Dereference(gold_ptr)
        Deallocate(gold_ptr, 8)
        
        ReturnValue(0)
    }
}

Function.DND_GetShopAtPlayer {
    Output: Integer
    Body: {
        current_map = DND_Map.level
        shop_id = Shop_GetAtPosition(current_map, DND_Player.x, DND_Player.y)
        ReturnValue(shop_id)
    }
}

Function.DND_InteractShop {
    Input: shop_id: Integer
    Body: {
        shop_name = Shop_GetName(shop_id)
        shop_type = Shop_GetType(shop_id)
        
        // Show shopkeeper greeting
        DND_ShowShopGreeting(shop_name, shop_type)
        
        // Create temp pointer for gold
        gold_ptr = Allocate(8)
        StoreValue(gold_ptr, DND_Player.gold)
        
        // Open shop UI
        Shop_Open(shop_id, gold_ptr)
        
        // Write back
        DND_Player.gold = Dereference(gold_ptr)
        Deallocate(gold_ptr, 8)
        
        ReturnValue(0)
    }
}

Function.DND_ShowShopGreeting {
    Input: shop_name: Address
    Input: shop_type: Integer
    Body: {
        TUI_Clear()
        
        width = TUI_GetWidth()
        
        // Shop name header
        TUI_SetFG(6)  // Cyan
        TUI_Bold()
        TUI_CenterText(6, shop_name, width)
        TUI_ResetColor()
        
        // Shopkeeper sprite (ASCII art based on type)
        TUI_SetFG(7)
        IfCondition EqualTo(shop_type, Shop_Types.WEAPON) ThenBlock: {
            TUI_CenterText(9,  "    ___    ", width)
            TUI_CenterText(10, "   /   \\   ", width)
            TUI_CenterText(11, "  | o o |  ", width)
            TUI_CenterText(12, "  |  ^  |  ", width)
            TUI_CenterText(13, "  | === |  ", width)
            TUI_CenterText(14, "   \\___/   ", width)
            TUI_CenterText(15, "  /|   |\\  ", width)
            TUI_CenterText(16, " / | X | \\ ", width)
        }
        IfCondition EqualTo(shop_type, Shop_Types.ARMOR) ThenBlock: {
            TUI_CenterText(9,  "    ___    ", width)
            TUI_CenterText(10, "   /   \\   ", width)
            TUI_CenterText(11, "  | o o |  ", width)
            TUI_CenterText(12, "  |  ^  |  ", width)
            TUI_CenterText(13, "  | === |  ", width)
            TUI_CenterText(14, "   \\___/   ", width)
            TUI_CenterText(15, "  [=====]  ", width)
            TUI_CenterText(16, "  |     |  ", width)
        }
        IfCondition EqualTo(shop_type, Shop_Types.MAGIC) ThenBlock: {
            TUI_CenterText(9,  "    /\\     ", width)
            TUI_CenterText(10, "   /  \\    ", width)
            TUI_CenterText(11, "  | ** |   ", width)
            TUI_CenterText(12, "  | o o|   ", width)
            TUI_CenterText(13, "  |  ^ |   ", width)
            TUI_CenterText(14, "   \\==/    ", width)
            TUI_CenterText(15, "    ||     ", width)
            TUI_CenterText(16, "   /||\\    ", width)
        }
        IfCondition EqualTo(shop_type, Shop_Types.GENERAL) ThenBlock: {
            TUI_CenterText(9,  "    ___    ", width)
            TUI_CenterText(10, "   /   \\   ", width)
            TUI_CenterText(11, "  | o o |  ", width)
            TUI_CenterText(12, "  |  ^  |  ", width)
            TUI_CenterText(13, "  | \\_/ |  ", width)
            TUI_CenterText(14, "   \\___/   ", width)
            TUI_CenterText(15, "   /| |\\   ", width)
            TUI_CenterText(16, "  / | | \\  ", width)
        }
        TUI_ResetColor()
        
        // Greeting text
        TUI_MoveTo(18, 0)
        TUI_SetFG(3)  // Yellow for speech
        
        IfCondition EqualTo(shop_type, Shop_Types.WEAPON) ThenBlock: {
            TUI_CenterText(18, "\"Welcome, warrior! Looking for a fine blade?\"", width)
        }
        IfCondition EqualTo(shop_type, Shop_Types.ARMOR) ThenBlock: {
            TUI_CenterText(18, "\"Step right up! Best armor in the kingdom!\"", width)
        }
        IfCondition EqualTo(shop_type, Shop_Types.MAGIC) ThenBlock: {
            TUI_CenterText(18, "\"Ah, a seeker of arcane knowledge...\"", width)
        }
        IfCondition EqualTo(shop_type, Shop_Types.GENERAL) ThenBlock: {
            TUI_CenterText(18, "\"Hello there! What can I get for you today?\"", width)
        }
        TUI_ResetColor()
        
        TUI_Dim()
        TUI_CenterText(21, "Press any key to browse wares...", width)
        TUI_ResetColor()
        
        TUI_Refresh()
        TUI_WaitKey()
        
        ReturnValue(0)
    }
}

Function.DND_LoadMap {
    Input: map_id: Integer
    Output: Integer
    Body: {
        path = Config_GetMapPath(map_id)
        result = DND_LoadMapFile(path, map_id)
        
        IfCondition LessThan(result, 0) ThenBlock: {
            DND_AddMessage("Error: Could not load map.")
            ReturnValue(-1)
        }
        
        map_name = Config_GetMapName(map_id)
        i = 0
        WhileLoop LessThan(i, 63) {
            ch = GetByte(map_name, i)
            SetByte(DND_Map.name, i, ch)
            IfCondition EqualTo(ch, 0) ThenBlock: { BreakLoop }
            i = Add(i, 1)
        }
        SetByte(DND_Map.name, 63, 0)
        
        Config_State.current_map = map_id
        DND_Map.level = map_id
        
        ReturnValue(0)
    }
}

// ============================================
// MAP FUNCTIONS
// ============================================

Function.DND_LoadMapFile {
    Input: filepath: Address
    Output: Integer
    Body: {
        fd = SystemCall(257, -100, filepath, 0, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(-1)
        }
        
        buffer = Allocate(8192)
        bytes = SystemCall(0, fd, buffer, 8192)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes, 0) ThenBlock: {
            Deallocate(buffer, 8192)
            ReturnValue(-2)
        }
        
        // Clear existing monsters
        DND_ClearMonsters()
        
        // Parse map
        result = DND_LoadMapFromBuffer(buffer, bytes)
        
        Deallocate(buffer, 8192)
        ReturnValue(result)
    }
}

Function.DND_ClearMonsters {
    Body: {
        DND_Monsters.count = 0
        ReturnValue(0)
    }
}

Function.DND_GetTile {
    Input: x: Integer
    Input: y: Integer
    Output: Integer
    Body: {
        IfCondition Or(LessThan(x, 0), GreaterEqual(x, DND_Map.width)) ThenBlock: {
            ReturnValue(DND_Tiles.WALL)
        }
        IfCondition Or(LessThan(y, 0), GreaterEqual(y, DND_Map.height)) ThenBlock: {
            ReturnValue(DND_Tiles.WALL)
        }
        
        offset = Add(Multiply(y, DND_Map.width), x)
        tile = GetByte(DND_Map.data, offset)
        ReturnValue(tile)
    }
}

Function.DND_SetTile {
    Input: x: Integer
    Input: y: Integer
    Input: tile: Integer
    Body: {
        IfCondition Or(LessThan(x, 0), GreaterEqual(x, DND_Map.width)) ThenBlock: {
            ReturnValue(0)
        }
        IfCondition Or(LessThan(y, 0), GreaterEqual(y, DND_Map.height)) ThenBlock: {
            ReturnValue(0)
        }
        
        offset = Add(Multiply(y, DND_Map.width), x)
        SetByte(DND_Map.data, offset, tile)
        ReturnValue(1)
    }
}

Function.DND_IsWalkable {
    Input: x: Integer
    Input: y: Integer
    Output: Integer
    Body: {
        tile = DND_GetTile(x, y)
        
        IfCondition EqualTo(tile, DND_Tiles.FLOOR) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(tile, DND_Tiles.DOOR_OPEN) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(tile, DND_Tiles.MAP_EXIT) ThenBlock: { ReturnValue(1) } 
        IfCondition EqualTo(tile, DND_Tiles.STAIRS_UP) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(tile, DND_Tiles.STAIRS_DOWN) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(tile, DND_Tiles.ITEM) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(tile, DND_Tiles.GOLD) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(tile, DND_Tiles.CHEST) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(tile, DND_Tiles.SHOP) ThenBlock: { ReturnValue(1) }
        
        // Inn and shop tiles
        IfCondition EqualTo(tile, 73) ThenBlock: { ReturnValue(1) }  // I
        IfCondition EqualTo(tile, 87) ThenBlock: { ReturnValue(1) }  // W
        IfCondition EqualTo(tile, 65) ThenBlock: { ReturnValue(1) }  // A
        
        ReturnValue(0)
    }
}

// ============================================
// MAP LOADING (Simple ASCII format)
// ============================================
//
// MAP FILE FORMAT (.dndmap):
// Line 1: NAME:Dungeon Level 1
// Line 2: SIZE:20,15
// Line 3: START:5,5
// Line 4+: Map data (ASCII)
//
// ============================================

Function.DND_LoadMapFromBuffer {
    Input: buffer: Address
    Input: buflen: Integer
    Input: map_id: Integer
    Body: {
        pos = 0
        width = 0
        height = 0
        data_start = 0
        
        // Parse header lines until we hit map data
        WhileLoop LessThan(pos, buflen) {
            ch = GetByte(buffer, pos)
            
            // NAME: (N = 78)
            IfCondition EqualTo(ch, 78) ThenBlock: {
                pos = Add(pos, 5)  // Skip "NAME:"
                name_pos = 0
                WhileLoop And(LessThan(pos, buflen), NotEqual(GetByte(buffer, pos), 10)) {
                    IfCondition NotEqual(GetByte(buffer, pos), 13) ThenBlock: {
                        SetByte(DND_Map.name, name_pos, GetByte(buffer, pos))
                        name_pos = Add(name_pos, 1)
                    }
                    pos = Add(pos, 1)
                }
                SetByte(DND_Map.name, name_pos, 0)
                pos = Add(pos, 1)
            } ElseBlock: {
            
            // SIZE: or START: (S = 83)
            IfCondition EqualTo(ch, 83) ThenBlock: {
                ch2 = GetByte(buffer, Add(pos, 1))
                
                // SIZE: (I = 73)
                IfCondition EqualTo(ch2, 73) ThenBlock: {
                    pos = Add(pos, 5)  // Skip "SIZE:"
                    width = 0
                    WhileLoop And(LessThan(pos, buflen), NotEqual(GetByte(buffer, pos), 44)) {
                        digit = GetByte(buffer, pos)
                        IfCondition And(GreaterEqual(digit, 48), LessEqual(digit, 57)) ThenBlock: {
                            width = Add(Multiply(width, 10), Subtract(digit, 48))
                        }
                        pos = Add(pos, 1)
                    }
                    pos = Add(pos, 1)  // Skip comma
                    height = 0
                    WhileLoop And(LessThan(pos, buflen), NotEqual(GetByte(buffer, pos), 10)) {
                        digit = GetByte(buffer, pos)
                        IfCondition And(GreaterEqual(digit, 48), LessEqual(digit, 57)) ThenBlock: {
                            height = Add(Multiply(height, 10), Subtract(digit, 48))
                        }
                        pos = Add(pos, 1)
                    }
                    pos = Add(pos, 1)
                    DND_Map.width = width
                    DND_Map.height = height
                } ElseBlock: {
                
                // START: (T = 84)
                IfCondition EqualTo(ch2, 84) ThenBlock: {
                    pos = Add(pos, 6)  // Skip "START:"
                    start_x = 0
                    WhileLoop And(LessThan(pos, buflen), NotEqual(GetByte(buffer, pos), 44)) {
                        digit = GetByte(buffer, pos)
                        IfCondition And(GreaterEqual(digit, 48), LessEqual(digit, 57)) ThenBlock: {
                            start_x = Add(Multiply(start_x, 10), Subtract(digit, 48))
                        }
                        pos = Add(pos, 1)
                    }
                    pos = Add(pos, 1)
                    start_y = 0
                    WhileLoop And(LessThan(pos, buflen), NotEqual(GetByte(buffer, pos), 10)) {
                        digit = GetByte(buffer, pos)
                        IfCondition And(GreaterEqual(digit, 48), LessEqual(digit, 57)) ThenBlock: {
                            start_y = Add(Multiply(start_y, 10), Subtract(digit, 48))
                        }
                        pos = Add(pos, 1)
                    }
                    pos = Add(pos, 1)
                    DND_Map.start_x = start_x
                    DND_Map.start_y = start_y
                } ElseBlock: {
                    // Unknown S-line, skip
                    WhileLoop And(LessThan(pos, buflen), NotEqual(GetByte(buffer, pos), 10)) {
                        pos = Add(pos, 1)
                    }
                    pos = Add(pos, 1)
                }
                }
            } ElseBlock: {
            
            // TYPE: (T = 84)
            IfCondition EqualTo(ch, 84) ThenBlock: {
                // Skip TYPE: line (config already has this)
                WhileLoop And(LessThan(pos, buflen), NotEqual(GetByte(buffer, pos), 10)) {
                    pos = Add(pos, 1)
                }
                pos = Add(pos, 1)
            } ElseBlock: {
            
            // PORTAL: (P = 80) - NEW!
            IfCondition EqualTo(ch, 80) ThenBlock: {
                pos = Add(pos, 7)  // Skip "PORTAL:"
                
                portal_name = Allocate(32)
                portal_x = 0
                portal_y = 0
                name_pos = 0
                
                // Read portal name until comma
                WhileLoop And(LessThan(pos, buflen), NotEqual(GetByte(buffer, pos), 44)) {
                    ch_p = GetByte(buffer, pos)
                    IfCondition LessThan(name_pos, 31) ThenBlock: {
                        SetByte(portal_name, name_pos, ch_p)
                        name_pos = Add(name_pos, 1)
                    }
                    pos = Add(pos, 1)
                }
                SetByte(portal_name, name_pos, 0)
                pos = Add(pos, 1)  // Skip comma
                
                // Read X coordinate
                WhileLoop And(LessThan(pos, buflen), NotEqual(GetByte(buffer, pos), 44)) {
                    digit = GetByte(buffer, pos)
                    IfCondition And(GreaterEqual(digit, 48), LessEqual(digit, 57)) ThenBlock: {
                        portal_x = Add(Multiply(portal_x, 10), Subtract(digit, 48))
                    }
                    pos = Add(pos, 1)
                }
                pos = Add(pos, 1)  // Skip comma
                
                // Read Y coordinate
                WhileLoop And(LessThan(pos, buflen), And(NotEqual(GetByte(buffer, pos), 10), NotEqual(GetByte(buffer, pos), 13))) {
                    digit = GetByte(buffer, pos)
                    IfCondition And(GreaterEqual(digit, 48), LessEqual(digit, 57)) ThenBlock: {
                        portal_y = Add(Multiply(portal_y, 10), Subtract(digit, 48))
                    }
                    pos = Add(pos, 1)
                }
                
                // Register portal location!
                Portal_RegisterLocation(portal_name, map_id, portal_x, portal_y)
                
                Deallocate(portal_name, 32)
                
                // Skip to end of line
                WhileLoop And(LessThan(pos, buflen), NotEqual(GetByte(buffer, pos), 10)) {
                    pos = Add(pos, 1)
                }
                pos = Add(pos, 1)
            } ElseBlock: {
            
            // Not a header line - must be map data
            data_start = pos
            BreakLoop
            
            }
            }
            }
            }
        }
        
        // Allocate map data if needed
        IfCondition EqualTo(DND_Map.data, 0) ThenBlock: {
            DND_Map.data = Allocate(3200)
        }
        
        // Clear map data
        i = 0
        WhileLoop LessThan(i, 3200) {
            SetByte(DND_Map.data, i, 0)
            i = Add(i, 1)
        }
        
        // Parse map data
        map_x = 0
        map_y = 0
        
        WhileLoop LessThan(pos, buflen) {
            ch = GetByte(buffer, pos)
            
            IfCondition EqualTo(ch, 10) ThenBlock: {
                map_y = Add(map_y, 1)
                map_x = 0
            } ElseBlock: {
            IfCondition NotEqual(ch, 13) ThenBlock: {
                IfCondition And(LessThan(map_x, width), LessThan(map_y, height)) ThenBlock: {
                    offset = Add(Multiply(map_y, width), map_x)
                    SetByte(DND_Map.data, offset, ch)
                    
                    // Check for monsters (M, G, O, D, S, T)
                    IfCondition Or(EqualTo(ch, 77), Or(EqualTo(ch, 71), Or(EqualTo(ch, 79), Or(EqualTo(ch, 68), Or(EqualTo(ch, 83), EqualTo(ch, 84)))))) ThenBlock: {
                        DND_SpawnMonster(ch, map_x, map_y)
                        SetByte(DND_Map.data, offset, DND_Tiles.FLOOR)
                    }
                }
                map_x = Add(map_x, 1)
            }
            }
            
            pos = Add(pos, 1)
        }
        
        ReturnValue(0)
    }
}

// ============================================
// Also update DND_LoadMapFile to pass map_id:
// ============================================

Function.DND_LoadMapFile {
    Input: filepath: Address
    Input: map_id: Integer
    Output: Integer
    Body: {
        fd = SystemCall(257, -100, filepath, 0, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(-1)
        }
        
        buffer = Allocate(8192)
        bytes = SystemCall(0, fd, buffer, 8192)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes, 0) ThenBlock: {
            Deallocate(buffer, 8192)
            ReturnValue(-2)
        }
        
        DND_ClearMonsters()
        result = DND_LoadMapFromBuffer(buffer, bytes, map_id)
        
        Deallocate(buffer, 8192)
        ReturnValue(result)
    }
}

// ============================================
// RENDERING
// ============================================

// ============================================
// MONSTER FUNCTIONS  
// ============================================

Function.DND_GetMonsterOffset {
    Input: index: Integer
    Output: Integer
    Body: {
        offset = Multiply(index, DND_MonsterLimits.MONSTER_SIZE)
        ReturnValue(offset)
    }
}

Function.DND_SpawnMonster {
    Input: x: Integer
    Input: y: Integer
    Input: monster_type: Integer
    Output: Integer
    Body: {
        // Find free slot
        slot = -1
        i = 0
        WhileLoop LessThan(i, DND_MonsterLimits.MAX_MONSTERS) {
            offset = DND_GetMonsterOffset(i)
            alive = GetByte(DND_Monsters.data, offset)
            IfCondition EqualTo(alive, 0) ThenBlock: {
                slot = i
                BreakLoop
            }
            i = Add(i, 1)
        }
        
        IfCondition LessThan(slot, 0) ThenBlock: {
            ReturnValue(-1)  // No free slots
        }
        
        offset = DND_GetMonsterOffset(slot)
        base = Add(DND_Monsters.data, offset)
        
        // Set alive
        SetByte(base, 0, 1)
        
        // Set type
        SetByte(base, 1, monster_type)
        
        // Set position (x at offset 2-3, y at offset 4-5)
        SetByte(base, 2, BitwiseAnd(x, 255))
        SetByte(base, 3, RightShift(x, 8))
        SetByte(base, 4, BitwiseAnd(y, 255))
        SetByte(base, 5, RightShift(y, 8))
        
        // Set stats based on type
        // Type 1: Goblin - HP 8, AC 12, 1d6, 25xp, 'g'
        // Type 2: Orc - HP 15, AC 13, 1d8, 50xp, 'o'
        // Type 3: Troll - HP 30, AC 15, 2d6, 100xp, 'T'
        
        IfCondition EqualTo(monster_type, 1) ThenBlock: {
            // Goblin
            SetByte(base, 6, 8)    // hp low
            SetByte(base, 7, 0)    // hp high
            SetByte(base, 8, 8)    // max_hp low
            SetByte(base, 9, 0)    // max_hp high
            SetByte(base, 10, 12)  // ac low
            SetByte(base, 11, 0)   // ac high
            SetByte(base, 12, 1)   // damage dice
            SetByte(base, 13, 6)   // damage sides
            SetByte(base, 14, 0)   // damage mod
            SetByte(base, 15, 25)  // xp low
            SetByte(base, 16, 0)   // xp high
            SetByte(base, 17, 103) // symbol 'g'
            // Name: "Goblin"
            SetByte(base, 18, 71)  // G
            SetByte(base, 19, 111) // o
            SetByte(base, 20, 98)  // b
            SetByte(base, 21, 108) // l
            SetByte(base, 22, 105) // i
            SetByte(base, 23, 110) // n
            SetByte(base, 24, 0)
        }
        IfCondition EqualTo(monster_type, 2) ThenBlock: {
            // Orc
            SetByte(base, 6, 15)
            SetByte(base, 7, 0)
            SetByte(base, 8, 15)
            SetByte(base, 9, 0)
            SetByte(base, 10, 13)
            SetByte(base, 11, 0)
            SetByte(base, 12, 1)
            SetByte(base, 13, 8)
            SetByte(base, 14, 1)
            SetByte(base, 15, 50)
            SetByte(base, 16, 0)
            SetByte(base, 17, 111) // 'o'
            SetByte(base, 18, 79)  // O
            SetByte(base, 19, 114) // r
            SetByte(base, 20, 99)  // c
            SetByte(base, 21, 0)
        }
        IfCondition EqualTo(monster_type, 3) ThenBlock: {
            // Troll
            SetByte(base, 6, 30)
            SetByte(base, 7, 0)
            SetByte(base, 8, 30)
            SetByte(base, 9, 0)
            SetByte(base, 10, 15)
            SetByte(base, 11, 0)
            SetByte(base, 12, 2)
            SetByte(base, 13, 6)
            SetByte(base, 14, 2)
            SetByte(base, 15, 100)
            SetByte(base, 16, 0)
            SetByte(base, 17, 84) // 'T'
            SetByte(base, 18, 84)  // T
            SetByte(base, 19, 114) // r
            SetByte(base, 20, 111) // o
            SetByte(base, 21, 108) // l
            SetByte(base, 22, 108) // l
            SetByte(base, 23, 0)
        }
        
        DND_Monsters.count = Add(DND_Monsters.count, 1)
        ReturnValue(slot)
    }
}

Function.DND_GetMonsterAt {
    Input: x: Integer
    Input: y: Integer
    Output: Integer
    Body: {
        i = 0
        WhileLoop LessThan(i, DND_MonsterLimits.MAX_MONSTERS) {
            offset = DND_GetMonsterOffset(i)
            base = Add(DND_Monsters.data, offset)
            
            alive = GetByte(base, 0)
            IfCondition EqualTo(alive, 1) ThenBlock: {
                mx = Add(GetByte(base, 2), Multiply(GetByte(base, 3), 256))
                my = Add(GetByte(base, 4), Multiply(GetByte(base, 5), 256))
                
                IfCondition And(EqualTo(mx, x), EqualTo(my, y)) ThenBlock: {
                    ReturnValue(i)
                }
            }
            i = Add(i, 1)
        }
        ReturnValue(-1)
    }
}

Function.DND_GetMonsterHP {
    Input: index: Integer
    Output: Integer
    Body: {
        offset = DND_GetMonsterOffset(index)
        base = Add(DND_Monsters.data, offset)
        hp = Add(GetByte(base, 6), Multiply(GetByte(base, 7), 256))
        ReturnValue(hp)
    }
}

Function.DND_SetMonsterHP {
    Input: index: Integer
    Input: hp: Integer
    Body: {
        offset = DND_GetMonsterOffset(index)
        base = Add(DND_Monsters.data, offset)
        SetByte(base, 6, BitwiseAnd(hp, 255))
        SetByte(base, 7, RightShift(hp, 8))
        ReturnValue(0)
    }
}

Function.DND_GetMonsterAC {
    Input: index: Integer
    Output: Integer
    Body: {
        offset = DND_GetMonsterOffset(index)
        base = Add(DND_Monsters.data, offset)
        ac = Add(GetByte(base, 10), Multiply(GetByte(base, 11), 256))
        ReturnValue(ac)
    }
}

Function.DND_GetMonsterSymbol {
    Input: index: Integer
    Output: Integer
    Body: {
        offset = DND_GetMonsterOffset(index)
        base = Add(DND_Monsters.data, offset)
        ReturnValue(GetByte(base, 17))
    }
}

Function.DND_GetMonsterName {
    Input: index: Integer
    Output: Address
    Body: {
        offset = DND_GetMonsterOffset(index)
        base = Add(DND_Monsters.data, offset)
        ReturnValue(Add(base, 18))
    }
}

Function.DND_GetMonsterXP {
    Input: index: Integer
    Output: Integer
    Body: {
        offset = DND_GetMonsterOffset(index)
        base = Add(DND_Monsters.data, offset)
        xp = Add(GetByte(base, 15), Multiply(GetByte(base, 16), 256))
        ReturnValue(xp)
    }
}

Function.DND_KillMonster {
    Input: index: Integer
    Body: {
        offset = DND_GetMonsterOffset(index)
        base = Add(DND_Monsters.data, offset)
        SetByte(base, 0, 0)  // Set alive = 0
        DND_Monsters.count = Subtract(DND_Monsters.count, 1)
        ReturnValue(0)
    }
}

Function.DND_IsMonsterAlive {
    Input: index: Integer
    Output: Integer
    Body: {
        offset = DND_GetMonsterOffset(index)
        base = Add(DND_Monsters.data, offset)
        ReturnValue(GetByte(base, 0))
    }
}

// ============================================
// COMBAT FUNCTIONS
// ============================================







Function.DND_StartBattle {
    Input: monster_idx: Integer
    Output: Integer
    Body: {
        offset = DND_GetMonsterOffset(monster_idx)
        base = Add(DND_Monsters.data, offset)
        
        hp = Add(GetByte(base, 6), Multiply(GetByte(base, 7), 256))
        max_hp = Add(GetByte(base, 8), Multiply(GetByte(base, 9), 256))
        ac = Add(GetByte(base, 10), Multiply(GetByte(base, 11), 256))
        xp = Add(GetByte(base, 15), Multiply(GetByte(base, 16), 256))
        name = Add(base, 18)
        
        Battle_Start(monster_idx, hp, max_hp, ac, xp, name)
        
        // Set the extra fields directly
        Battle_Enemy.damage_dice = GetByte(base, 12)
        Battle_Enemy.damage_sides = GetByte(base, 13)
        Battle_Enemy.damage_mod = GetByte(base, 14)
        Battle_Enemy.symbol = GetByte(base, 17)
        
        gold_ptr = Allocate(8)
        StoreValue(gold_ptr, DND_Player.gold)
        
        result = Battle_Run(DND_Player.char_data, gold_ptr)
        
        DND_Player.gold = Dereference(gold_ptr)
        Deallocate(gold_ptr, 8)
        
        IfCondition EqualTo(result, Battle_Results.VICTORY) ThenBlock: {
            DND_KillMonster(monster_idx)
        }
        
        ReturnValue(result)
    }
}





// ============================================

Function.DND_GetTileColor {
    Input: tile: Integer
    Output: Integer
    Body: {
        IfCondition EqualTo(tile, DND_Tiles.WALL) ThenBlock: { ReturnValue(7) }
        IfCondition EqualTo(tile, DND_Tiles.FLOOR) ThenBlock: { ReturnValue(7) }
        IfCondition EqualTo(tile, DND_Tiles.DOOR) ThenBlock: { ReturnValue(3) }
        IfCondition EqualTo(tile, DND_Tiles.DOOR_OPEN) ThenBlock: { ReturnValue(3) }
        IfCondition EqualTo(tile, DND_Tiles.DOOR_LOCKED) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(tile, DND_Tiles.STAIRS_UP) ThenBlock: { ReturnValue(6) }
        IfCondition EqualTo(tile, DND_Tiles.STAIRS_DOWN) ThenBlock: { ReturnValue(6) }
        IfCondition EqualTo(tile, DND_Tiles.WATER) ThenBlock: { ReturnValue(4) }
        IfCondition EqualTo(tile, DND_Tiles.TRAP) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(tile, DND_Tiles.CHEST) ThenBlock: { ReturnValue(3) }
        IfCondition EqualTo(tile, DND_Tiles.ITEM) ThenBlock: { ReturnValue(5) }
        IfCondition EqualTo(tile, DND_Tiles.GOLD) ThenBlock: { ReturnValue(3) }
        IfCondition EqualTo(tile, DND_Tiles.MONSTER) ThenBlock: { ReturnValue(1) }
        
        // === NEW: Shop tile color ===
        IfCondition EqualTo(tile, DND_Tiles.SHOP) ThenBlock: { 
            ReturnValue(DND_TileColors.SHOP_FG) 
        }
        
        ReturnValue(7)
    }
}

Function.DND_DrawMap {
    Body: {
        // Calculate view offset (center on player)
        view_x = Subtract(DND_Player.x, Divide(DND_View.map_view_width, 2))
        view_y = Subtract(DND_Player.y, Divide(DND_View.map_view_height, 2))
        
        // Clamp to map bounds
        IfCondition LessThan(view_x, 0) ThenBlock: { view_x = 0 }
        IfCondition LessThan(view_y, 0) ThenBlock: { view_y = 0 }
        
        max_view_x = Subtract(DND_Map.width, DND_View.map_view_width)
        max_view_y = Subtract(DND_Map.height, DND_View.map_view_height)
        
        IfCondition GreaterThan(view_x, max_view_x) ThenBlock: { 
            IfCondition GreaterThan(max_view_x, 0) ThenBlock: {
                view_x = max_view_x 
            } ElseBlock: {
                view_x = 0
            }
        }
        IfCondition GreaterThan(view_y, max_view_y) ThenBlock: { 
            IfCondition GreaterThan(max_view_y, 0) ThenBlock: {
                view_y = max_view_y 
            } ElseBlock: {
                view_y = 0
            }
        }
        
        // Draw visible portion of map
        screen_y = 0
        WhileLoop LessThan(screen_y, DND_View.map_view_height) {
            TUI_MoveTo(Add(DND_View.map_start_row, screen_y), DND_View.map_start_col)
            
            screen_x = 0
            WhileLoop LessThan(screen_x, DND_View.map_view_width) {
                map_x = Add(view_x, screen_x)
                map_y = Add(view_y, screen_y)
                
                // Check if player is here
                IfCondition And(EqualTo(map_x, DND_Player.x), EqualTo(map_y, DND_Player.y)) ThenBlock: {
                    TUI_SetFG(DND_TileColors.PLAYER_FG)
                    TUI_Bold()
                    TUI_PrintChar(DND_Tiles.PLAYER)
                    TUI_ResetColor()
                } ElseBlock: {
                    // Check if monster is here
                    monster_idx = DND_GetMonsterAt(map_x, map_y)
                    IfCondition GreaterEqual(monster_idx, 0) ThenBlock: {
                        monster_symbol = DND_GetMonsterSymbol(monster_idx)
                        TUI_SetFG(DND_TileColors.MONSTER_FG)
                        TUI_Bold()
                        TUI_PrintChar(monster_symbol)
                        TUI_ResetColor()
                    } ElseBlock: {
                        tile = DND_GetTile(map_x, map_y)
                        color = DND_GetTileColor(tile)
                        
                        IfCondition EqualTo(tile, DND_Tiles.FLOOR) ThenBlock: {
                            TUI_Dim()
                        }
                        TUI_SetFG(color)
                        TUI_PrintChar(tile)
                        TUI_ResetColor()
                    }
                }
                
                screen_x = Add(screen_x, 1)
            }
            screen_y = Add(screen_y, 1)
        }
        
        ReturnValue(0)
    }
}

Function.DND_DrawStats {
    Body: {
        col = DND_View.stats_col
        char_data = DND_Player.char_data
        
        // Player name, class, and level
        TUI_MoveTo(2, col)
        TUI_Bold()
        player_name = Char_GetName(char_data)
        TUI_Print(player_name)
        TUI_ResetColor()
        
        TUI_MoveTo(3, col)
        TUI_Dim()
        class_id = Char_GetClass(char_data)
        class_name = Char_GetClassName(class_id)
        TUI_Print(class_name)
        TUI_Print(" Lvl ")
        TUI_PrintNum(Char_GetLevel(char_data))
        TUI_ResetColor()
        
        // HP
        TUI_MoveTo(5, col)
        TUI_Print("HP: ")
        hp = Char_GetHP(char_data)
        max_hp = Char_GetMaxHP(char_data)
        IfCondition LessThan(hp, Divide(max_hp, 4)) ThenBlock: {
            TUI_SetFG(1)  // Red for low HP
        } ElseBlock: {
            TUI_SetFG(2)  // Green
        }
        TUI_PrintNum(hp)
        TUI_ResetColor()
        TUI_Print("/")
        TUI_PrintNum(max_hp)
        
        // MP
        TUI_MoveTo(6, col)
        TUI_Print("MP: ")
        TUI_SetFG(4)
        TUI_PrintNum(Char_GetMP(char_data))
        TUI_ResetColor()
        TUI_Print("/")
        TUI_PrintNum(Char_GetMaxMP(char_data))
        
        // Attack/Defense with equipment bonuses
        TUI_MoveTo(7, col)
        TUI_Print("ATK: ")
        base_atk = Char_GetAttack(char_data)
        equip_atk = Item_GetTotalAtkBonus()
        TUI_PrintNum(base_atk)
        IfCondition GreaterThan(equip_atk, 0) ThenBlock: {
            TUI_SetFG(2)  // Green for bonus
            TUI_Print("+")
            TUI_PrintNum(equip_atk)
            TUI_ResetColor()
        }
        
        TUI_Print(" DEF: ")
        base_def = Char_GetDefense(char_data)
        equip_def = Item_GetTotalDefBonus()
        TUI_PrintNum(base_def)
        IfCondition GreaterThan(equip_def, 0) ThenBlock: {
            TUI_SetFG(2)
            TUI_Print("+")
            TUI_PrintNum(equip_def)
            TUI_ResetColor()
        }
        
        // XP and Gold
        TUI_MoveTo(9, col)
        TUI_Print("XP: ")
        total_xp = Char_GetStat16(char_data, Char_Offsets.TOTAL_XP)
        TUI_PrintNum(total_xp)
        
        TUI_MoveTo(10, col)
        TUI_SetFG(3)
        TUI_Print("Gold: ")
        TUI_PrintNum(DND_Player.gold)
        TUI_ResetColor()
        
        // Core Stats
        TUI_MoveTo(12, col)
        TUI_Print("STR:")
        TUI_PrintNum(Char_GetStat16(char_data, Char_Offsets.STR))
        TUI_Print(" AGI:")
        TUI_PrintNum(Char_GetStat16(char_data, Char_Offsets.AGI))
        
        TUI_MoveTo(13, col)
        TUI_Print("VIT:")
        TUI_PrintNum(Char_GetStat16(char_data, Char_Offsets.VIT))
        TUI_Print(" INT:")
        TUI_PrintNum(Char_GetStat16(char_data, Char_Offsets.INT))
        
        TUI_MoveTo(14, col)
        TUI_Print("LUK:")
        TUI_PrintNum(Char_GetStat16(char_data, Char_Offsets.LUK))
        
        // Show equipped weapon
        TUI_MoveTo(15, col)
        TUI_Dim()
        TUI_Print("Weapon: ")
        TUI_ResetColor()
        weapon_id = Item_GetEquipped(Item_Slots.WEAPON)
        IfCondition GreaterThan(weapon_id, 0) ThenBlock: {
            weapon_name = Item_GetName(weapon_id)
            rarity = Item_GetRarity(weapon_id)
            TUI_SetFG(Item_GetRarityColor(rarity))
            TUI_Print(weapon_name)
            TUI_ResetColor()
        } ElseBlock: {
            TUI_Dim()
            TUI_Print("(none)")
            TUI_ResetColor()
        }
        
        // Dungeon info
        TUI_MoveTo(16, col)
        TUI_Dim()
        TUI_Print("Dungeon: ")
        TUI_Print(DND_Map.name)
        TUI_ResetColor()
        
        TUI_MoveTo(17, col)
        TUI_Dim()
        TUI_Print("Turn: ")
        TUI_PrintNum(DND_GameState.turn_count)
        TUI_ResetColor()
        
        // Show if at shop
        shop_id = DND_GetShopAtPlayer()
        IfCondition GreaterEqual(shop_id, 0) ThenBlock: {
            TUI_MoveTo(18, DND_View.stats_col)
            TUI_SetFG(6)  // Cyan
            TUI_Print("[SHOP]")
            TUI_ResetColor()
            
            TUI_MoveTo(19, DND_View.stats_col)
            TUI_Dim()
            TUI_Print("i:Browse")
            TUI_ResetColor()
        } ElseBlock: {
            // Check for inn (existing code)
            inn_id = DND_GetInnAtPlayer()
            IfCondition GreaterEqual(inn_id, 0) ThenBlock: {
                TUI_MoveTo(18, DND_View.stats_col)
                TUI_SetFG(3)  // Yellow
                TUI_Print("[INN]")
                TUI_ResetColor()
                
                can_save = Inn_CanSave(inn_id)
                IfCondition EqualTo(can_save, 1) ThenBlock: {
                    TUI_MoveTo(19, DND_View.stats_col)
                    TUI_Dim()
                    TUI_Print("i:Rest/Save")
                    TUI_ResetColor()
                } ElseBlock: {
                    TUI_MoveTo(19, DND_View.stats_col)
                    TUI_Dim()
                    TUI_Print("i:Rest")
                    TUI_ResetColor()
                }
            }
        }
        
        // Show combat info if in combat
        
        ReturnValue(0)
    }
}

Function.DND_DrawUI {
    Body: {
        TUI_Clear()
        
        // Title bar
        TUI_StatusBar("=== AILANG DUNGEON CRAWLER === [h]elp [q]uit", 1, TUI_State.screen_width)
        
        // Draw map
        DND_DrawMap()
        
        // Draw stats panel
        DND_DrawStats()
        
        // Draw message area border
        TUI_MoveTo(22, 1)
        TUI_Dim()
        i = 0
        WhileLoop LessThan(i, 60) {
            TUI_PrintChar(45)
            i = Add(i, 1)
        }
        TUI_ResetColor()
        
        // UPDATE: Controls line
        TUI_MoveTo(DND_View.input_row, 1)
        TUI_Dim()
        TUI_Print("Move:Arrows e:Equip i:Interact s:Save l:Load ?:Help q:Quit")
        TUI_ResetColor()
        
        TUI_Refresh()
        ReturnValue(0)
    }
}

// ============================================
// MESSAGES
// ============================================

Function.DND_AddMessage {
    Input: msg: Address
    Body: {
        // Simple message display at bottom
        TUI_MoveTo(23, 1)
        TUI_ClearLine(23)
        TUI_MoveTo(23, 1)
        TUI_Print(msg)
        TUI_Refresh()
        ReturnValue(0)
    }
}

// ============================================
// PLAYER MOVEMENT
// ============================================

Function.DND_MovePlayer {
    Input: dx: Integer
    Input: dy: Integer
    Body: {
        new_x = Add(DND_Player.x, dx)
        new_y = Add(DND_Player.y, dy)
        
        // Check for monster
        monster_idx = DND_GetMonsterAt(new_x, new_y)
        IfCondition GreaterEqual(monster_idx, 0) ThenBlock: {
            battle_result = DND_StartBattle(monster_idx)
            DND_GameState.turn_count = Add(DND_GameState.turn_count, 1)
            IfCondition EqualTo(battle_result, Battle_Results.DEFEAT) ThenBlock: {
                result = DND_HandleDeath()
                IfCondition EqualTo(result, 0) ThenBlock: {
                    DND_GameState.running = 0
                }
            }
            ReturnValue(1)
        }
        
        tile = DND_GetTile(new_x, new_y)
        
        // Closed door - open it
        IfCondition EqualTo(tile, DND_Tiles.DOOR) ThenBlock: {
            DND_SetTile(new_x, new_y, DND_Tiles.DOOR_OPEN)
            DND_AddMessage("You open the door.")
            DND_GameState.turn_count = Add(DND_GameState.turn_count, 1)
            ReturnValue(1)
        }
        
        // Locked door
        IfCondition EqualTo(tile, DND_Tiles.DOOR_LOCKED) ThenBlock: {
            DND_AddMessage("The door is locked!")
            ReturnValue(0)
        }
        
        // Check walkable
        walkable = DND_IsWalkable(new_x, new_y)
        IfCondition EqualTo(walkable, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Gold
        IfCondition EqualTo(tile, DND_Tiles.GOLD) ThenBlock: {
            DND_Player.gold = Add(DND_Player.gold, 5)
            DND_SetTile(new_x, new_y, DND_Tiles.FLOOR)
            DND_AddMessage("You found 5 gold!")
        }
        
        // Item
        IfCondition EqualTo(tile, DND_Tiles.ITEM) ThenBlock: {
            random_item = Add(Modulo(Dice_D20(), 5), 1)
            result = Item_InvAdd(random_item, 1)
            IfCondition GreaterEqual(result, 0) ThenBlock: {
                DND_AddMessage("You found an item!")
            } ElseBlock: {
                DND_AddMessage("Inventory full!")
            }
            DND_SetTile(new_x, new_y, DND_Tiles.FLOOR)
        }
        
        // Chest
        IfCondition EqualTo(tile, DND_Tiles.CHEST) ThenBlock: {
            DND_Player.gold = Add(DND_Player.gold, 20)
            random_item = Add(Modulo(Dice_D20(), 10), 10)
            Item_InvAdd(random_item, 1)
            DND_SetTile(new_x, new_y, DND_Tiles.FLOOR)
            DND_AddMessage("Chest contained treasure!")
        }
        
        // Move player
        DND_Player.x = new_x
        DND_Player.y = new_y
        DND_GameState.turn_count = Add(DND_GameState.turn_count, 1)
        
        ReturnValue(1)
    }
}

// ============================================
// INPUT HANDLING
// ============================================

Function.DND_HandleInput {
    Input: key: Integer
    Output: Integer
    Body: {
        // Movement keys
        IfCondition EqualTo(key, TUI_Keys.KEY_UP) ThenBlock: {
            DND_MovePlayer(0, -1)
            ReturnValue(1)
        }
        IfCondition EqualTo(key, TUI_Keys.KEY_DOWN) ThenBlock: {
            DND_MovePlayer(0, 1)
            ReturnValue(1)
        }
        IfCondition EqualTo(key, TUI_Keys.KEY_LEFT) ThenBlock: {
            DND_MovePlayer(-1, 0)
            ReturnValue(1)
        }
        IfCondition EqualTo(key, TUI_Keys.KEY_RIGHT) ThenBlock: {
            DND_MovePlayer(1, 0)
            ReturnValue(1)
        }
        
        // Vi keys (hjkl)
        IfCondition EqualTo(key, 104) ThenBlock: {  // h
            DND_MovePlayer(-1, 0)
            ReturnValue(1)
        }
        IfCondition EqualTo(key, 106) ThenBlock: {  // j
            DND_MovePlayer(0, 1)
            ReturnValue(1)
        }
        IfCondition EqualTo(key, 107) ThenBlock: {  // k
            DND_MovePlayer(0, -1)
            ReturnValue(1)
        }
        // 'l' key - Load (for testing/debug)
        IfCondition EqualTo(key, 108) ThenBlock: {
            // Show load screen
            loaded_char = 0
            loaded_x = 0
            loaded_y = 0
            loaded_map = 0
            loaded_gold = 0
            
            slot = SaveScreen_Load(AddressOf(loaded_char),
                                  AddressOf(loaded_x),
                                  AddressOf(loaded_y),
                                  AddressOf(loaded_map),
                                  AddressOf(loaded_gold))
            
            IfCondition GreaterEqual(slot, 0) ThenBlock: {
                // Apply loaded state
                IfCondition NotEqual(loaded_char, 0) ThenBlock: {
                    // Free old character if different
                    IfCondition NotEqual(DND_Player.char_data, loaded_char) ThenBlock: {
                        Deallocate(DND_Player.char_data, Char_Offsets.SIZE)
                    }
                    DND_Player.char_data = loaded_char
                }
                DND_Player.x = loaded_x
                DND_Player.y = loaded_y
                DND_Player.gold = loaded_gold
                
                // Load the map
                DND_LoadMap(loaded_map)
                
                DND_AddMessage("Game loaded!")
            }
            ReturnValue(1)
        }
        
        // 'e' to open equipment screen
        IfCondition EqualTo(key, 101) ThenBlock: {
            EqScreen_Show(DND_Player.char_data)
            ReturnValue(1)
        }
        
        // 'i' key - Interact (inn, shop, NPC)
        IfCondition EqualTo(key, 105) ThenBlock: {
            // Check for inn first
            inn_id = DND_GetInnAtPlayer()
            IfCondition GreaterEqual(inn_id, 0) ThenBlock: {
                DND_InteractInn(inn_id)
                ReturnValue(1)
            }
            
            // Check for shop
            shop_id = DND_GetShopAtPlayer()
            IfCondition GreaterEqual(shop_id, 0) ThenBlock: {
                DND_InteractShop(shop_id)
                ReturnValue(1)
            }
            
            // Could add NPC check here later
            
            DND_AddMessage("Nothing to interact with here.")
            ReturnValue(1)
        }
        
        // 's' key - Save (only at inn with save enabled)
        IfCondition EqualTo(key, 115) ThenBlock: {
            inn_id = DND_GetInnAtPlayer()
            IfCondition GreaterEqual(inn_id, 0) ThenBlock: {
                can_save = Inn_CanSave(inn_id)
                IfCondition EqualTo(can_save, 1) ThenBlock: {
                    // Open save screen
                    slot = SaveScreen_Save(DND_Player.char_data,
                                          DND_Player.x,
                                          DND_Player.y,
                                          DND_Map.level,
                                          DND_Player.gold,
                                          DND_Map.name)
                    IfCondition GreaterEqual(slot, 0) ThenBlock: {
                        DND_AddMessage("Game saved!")
                    }
                    ReturnValue(1)
                }
            }
            DND_AddMessage("Find an inn to save your game.")
            ReturnValue(1)
        }
        
        // Quit
        IfCondition EqualTo(key, 113) ThenBlock: {  // q
            DND_GameState.running = 0
            ReturnValue(1)
        }
        
        // ESC also quits
        IfCondition EqualTo(key, TUI_Keys.KEY_ESC) ThenBlock: {
            DND_GameState.running = 0
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}

Function.DND_LoadSavedGame {
    Input: slot: Integer
    Output: Integer
    Body: {
        // Temp storage for output values
        x_ptr = Allocate(8)
        y_ptr = Allocate(8)
        map_ptr = Allocate(8)
        gold_ptr = Allocate(8)
        
        result = Save_LoadSingle(slot, DND_Player.char_data, x_ptr, y_ptr, map_ptr, gold_ptr)
        
        IfCondition LessThan(result, 0) ThenBlock: {
            Deallocate(x_ptr, 8)
            Deallocate(y_ptr, 8)
            Deallocate(map_ptr, 8)
            Deallocate(gold_ptr, 8)
            ReturnValue(result)
        }
        
        // Apply loaded state
        DND_Player.x = Dereference(x_ptr)
        DND_Player.y = Dereference(y_ptr)
        DND_Player.gold = Dereference(gold_ptr)
        map_id = Dereference(map_ptr)
        
        Deallocate(x_ptr, 8)
        Deallocate(y_ptr, 8)
        Deallocate(map_ptr, 8)
        Deallocate(gold_ptr, 8)
        
        // Load the saved map
        DND_LoadMap(map_id)
        
        ReturnValue(0)
    }
}

Function.DND_HandleDeath {
    Body: {
        // Show death message
        TUI_Clear()
        
        width = TUI_GetWidth()
        
        TUI_SetFG(1)  // Red
        TUI_Bold()
        TUI_CenterText(8, "=== YOU HAVE FALLEN ===", width)
        TUI_ResetColor()
        
        TUI_CenterText(10, "Your adventure has come to an end...", width)
        TUI_CenterText(11, "But all is not lost!", width)
        
        // Menu options
        TUI_CenterText(14, "What would you like to do?", width)
        
        cursor = 0
        running = 1
        
        WhileLoop EqualTo(running, 1) {
            // Option 1: Load save
            TUI_MoveTo(16, Subtract(Divide(width, 2), 12))
            IfCondition EqualTo(cursor, 0) ThenBlock: {
                TUI_SetFG(2)
                TUI_Bold()
                TUI_Print("> Load Last Save")
            } ElseBlock: {
                TUI_Dim()
                TUI_Print("  Load Last Save")
            }
            TUI_ResetColor()
            
            // Option 2: Respawn at inn
            TUI_MoveTo(17, Subtract(Divide(width, 2), 12))
            IfCondition EqualTo(cursor, 1) ThenBlock: {
                TUI_SetFG(2)
                TUI_Bold()
                TUI_Print("> Respawn at Inn")
            } ElseBlock: {
                TUI_Dim()
                TUI_Print("  Respawn at Inn")
            }
            TUI_ResetColor()
            
            // Option 3: Quit
            TUI_MoveTo(18, Subtract(Divide(width, 2), 12))
            IfCondition EqualTo(cursor, 2) ThenBlock: {
                TUI_SetFG(2)
                TUI_Bold()
                TUI_Print("> Give Up")
            } ElseBlock: {
                TUI_Dim()
                TUI_Print("  Give Up")
            }
            TUI_ResetColor()
            
            TUI_Refresh()
            
            key = TUI_WaitKey()
            
            IfCondition Or(EqualTo(key, TUI_Keys.KEY_UP), EqualTo(key, 107)) ThenBlock: {
                IfCondition GreaterThan(cursor, 0) ThenBlock: {
                    cursor = Subtract(cursor, 1)
                }
            }
            IfCondition Or(EqualTo(key, TUI_Keys.KEY_DOWN), EqualTo(key, 106)) ThenBlock: {
                IfCondition LessThan(cursor, 2) ThenBlock: {
                    cursor = Add(cursor, 1)
                }
            }
            
            IfCondition EqualTo(key, 10) ThenBlock: {
                running = 0
            }
        }
        
        // Handle choice
        IfCondition EqualTo(cursor, 0) ThenBlock: {
            // Load save
            DND_TryLoadSave()
            ReturnValue(1)  // Continue playing
        }
        
        IfCondition EqualTo(cursor, 1) ThenBlock: {
            // Respawn at inn
            DND_RespawnAtInn()
            ReturnValue(1)  // Continue playing
        }
        
        // Quit
        DND_GameState.running = 0
        ReturnValue(0)
    }
}

Function.DND_TryLoadSave {
    Body: {
        loaded_char = 0
        loaded_x = 0
        loaded_y = 0
        loaded_map = 0
        loaded_gold = 0
        
        slot = SaveScreen_Load(AddressOf(loaded_char),
                              AddressOf(loaded_x),
                              AddressOf(loaded_y),
                              AddressOf(loaded_map),
                              AddressOf(loaded_gold))
        
        IfCondition GreaterEqual(slot, 0) ThenBlock: {
            // Apply loaded state
            IfCondition NotEqual(loaded_char, 0) ThenBlock: {
                IfCondition NotEqual(DND_Player.char_data, loaded_char) ThenBlock: {
                    Deallocate(DND_Player.char_data, Char_Offsets.SIZE)
                }
                DND_Player.char_data = loaded_char
            }
            DND_Player.x = loaded_x
            DND_Player.y = loaded_y
            DND_Player.gold = loaded_gold
            DND_LoadMap(loaded_map)
        } ElseBlock: {
            // No save or cancelled - respawn instead
            DND_RespawnAtInn()
        }
        
        ReturnValue(0)
    }
}

Function.DND_RespawnAtInn {
    Body: {
        // Get last inn checkpoint
        map_id = 0
        x = 0
        y = 0
        Save_GetInnCheckpoint(AddressOf(map_id), AddressOf(x), AddressOf(y))
        
        // Default if no checkpoint
        IfCondition And(EqualTo(x, 0), EqualTo(y, 0)) ThenBlock: {
            map_id = 1   // Hometown
            x = 5
            y = 14
        }
        
        // Revive with 1 HP (harsh but fair!)
        Char_SetStat16(DND_Player.char_data, Char_Offsets.HP, 1)
        
        // Lose half gold (Dragon Quest style penalty)
        DND_Player.gold = Divide(DND_Player.gold, 2)
        
        // Teleport to inn
        DND_Player.x = x
        DND_Player.y = y
        DND_LoadMap(map_id)
        
        DND_AddMessage("You wake at the inn...")
        DND_AddMessage("You lost half your gold!")
        
        ReturnValue(0)
    }
}

Function.DND_SetQuestFlag {
    Input: name: Address
    Input: value: Integer
    Body: {
        Save_SetFlag(name, value)
        ReturnValue(0)
    }
}

Function.DND_GetQuestFlag {
    Input: name: Address
    Output: Integer
    Body: {
        ReturnValue(Save_GetFlag(name))
    }
}

// ============================================
// MAIN GAME LOOP
// ============================================

Function.DND_Run {
    Body: {
        DND_DrawUI()
        DND_AddMessage("Welcome to the dungeon! Use arrows or hjkl to move.")
        
        WhileLoop EqualTo(DND_GameState.running, 1) {
            key = TUI_GetKey()
            
            IfCondition NotEqual(key, TUI_Keys.KEY_NONE) ThenBlock: {
                DND_HandleInput(key)
                DND_DrawUI()
            }
        }
        
        ReturnValue(0)
    }
}