// ============================================
// Library.Character.ailang
// Flexible Character & Progression System
// DATA-DRIVEN - All values loaded from files!
// ============================================
//
// DATA FILES:
//   classes.dnddat     - Class base stats
//   xp_table.dnddat    - XP per level
//   level_gains.dnddat - Stat gains & skills per level
//   skills.dnddat      - Skill definitions
//
// All progression can be modded without recompiling!
//
// ============================================

LibraryImport.DICE

// ============================================
// CONSTANTS
// ============================================

FixedPool.Char_Limits {
    "MAX_LEVEL": Initialize=30
    "MAX_SKILLS": Initialize=20
    "MAX_EQUIPPED": Initialize=6
    "NAME_LEN": Initialize=24
    "SKILL_NAME_LEN": Initialize=20
}

// Equipment slots
FixedPool.Char_Slots {
    "WEAPON": Initialize=0
    "ARMOR": Initialize=1
    "SHIELD": Initialize=2
    "HELMET": Initialize=3
    "RING": Initialize=4
    "AMULET": Initialize=5
}

// Character classes
FixedPool.Char_Classes {
    "WARRIOR": Initialize=1
    "MAGE": Initialize=2
    "ROGUE": Initialize=3
    "CLERIC": Initialize=4
    "RANGER": Initialize=5
}

// Skill types
FixedPool.Skill_Types {
    "ATTACK": Initialize=1      
    "HEAL": Initialize=2       
    "BUFF": Initialize=3       
    "DEBUFF": Initialize=4      
    "UTILITY": Initialize=5     
    "PASSIVE": Initialize=6     
}

// Skill targets
FixedPool.Skill_Targets {
    "SELF": Initialize=1
    "SINGLE_ENEMY": Initialize=2
    "ALL_ENEMIES": Initialize=3
    "SINGLE_ALLY": Initialize=4
    "ALL_ALLIES": Initialize=5
}

// ============================================
// CHARACTER STRUCTURE
// ============================================
// Total: 256 bytes per character
//
// 0-23:    Name (24 bytes)
// 24:      Class (1 byte)
// 25:      Level (1 byte)
// 26-27:   XP (2 bytes) - current XP towards next level
// 28-31:   Total XP (4 bytes)
// 32-33:   HP (2 bytes)
// 34-35:   Max HP (2 bytes)
// 36-37:   MP (2 bytes)
// 38-39:   Max MP (2 bytes)
// 40-41:   Strength (2 bytes)
// 42-43:   Agility (2 bytes)
// 44-45:   Vitality (2 bytes)
// 46-47:   Intelligence (2 bytes)
// 48-49:   Luck (2 bytes)
// 50-51:   Attack (2 bytes) - derived
// 52-53:   Defense (2 bytes) - derived
// 54-55:   Speed (2 bytes) - derived (for initiative)
// 56-57:   Magic Attack (2 bytes) - derived
// 58-59:   Magic Defense (2 bytes) - derived
// 60-107:  Equipment (6 slots x 8 bytes each)
// 108-147: Known Skills (20 skills x 2 bytes: skill_id)
// 148:     Skill Count (1 byte)
// 149-255: Reserved

FixedPool.Char_Offsets {
    "NAME": Initialize=0
    "CLASS": Initialize=24
    "LEVEL": Initialize=25
    "XP": Initialize=26
    "TOTAL_XP": Initialize=28
    "HP": Initialize=32
    "MAX_HP": Initialize=34
    "MP": Initialize=36
    "MAX_MP": Initialize=38
    "STR": Initialize=40
    "AGI": Initialize=42
    "VIT": Initialize=44
    "INT": Initialize=46
    "LUK": Initialize=48
    "ATK": Initialize=50
    "DEF": Initialize=52
    "SPD": Initialize=54
    "MATK": Initialize=56
    "MDEF": Initialize=58
    "EQUIPMENT": Initialize=60
    "SKILLS": Initialize=108
    "SKILL_COUNT": Initialize=148
    "SIZE": Initialize=256
}

// ============================================
// SKILL STRUCTURE  
// ============================================
// 32 bytes per skill definition
//
// 0-19:    Name (20 bytes)
// 20:      Type (1 byte)
// 21:      Target (1 byte)
// 22:      MP Cost (1 byte)
// 23:      Power (1 byte) - base damage/heal
// 24:      Accuracy (1 byte) - % chance to hit
// 25:      Element (1 byte) - 0=none, 1=fire, 2=ice, etc
// 26:      Status Effect (1 byte)
// 27:      Status Chance (1 byte)
// 28-31:   Reserved

FixedPool.Skill_Offsets {
    "NAME": Initialize=0
    "TYPE": Initialize=20
    "TARGET": Initialize=21
    "MP_COST": Initialize=22
    "POWER": Initialize=23
    "ACCURACY": Initialize=24
    "ELEMENT": Initialize=25
    "STATUS": Initialize=26
    "STATUS_CHANCE": Initialize=27
    "SIZE": Initialize=32
}

// ============================================
// LEVEL UP TABLE STRUCTURE
// ============================================
// Per class, per level: what stats increase
// 8 bytes per level entry:
//   0: HP gain
//   1: MP gain
//   2: STR gain
//   3: AGI gain
//   4: VIT gain
//   5: INT gain
//   6: Skill learned (skill ID, 0=none)
//   7: Reserved

FixedPool.LevelTable_Offsets {
    "HP": Initialize=0
    "MP": Initialize=1
    "STR": Initialize=2
    "AGI": Initialize=3
    "VIT": Initialize=4
    "INT": Initialize=5
    "SKILL": Initialize=6
    "SIZE": Initialize=8
}

// ============================================
// GLOBAL STATE
// ============================================

FixedPool.Char_State {
    "skill_table": Initialize=0       
    "skill_count": Initialize=0
    "level_tables": Initialize=0     
    "xp_table": Initialize=0         
    "class_table": Initialize=0      
    "class_count": Initialize=0
    "initialized": Initialize=0
    "data_loaded": Initialize=0      
}

// Class table: 64 bytes per class
// 0-23: Name
// 24-25: Base HP
// 26-27: Base MP
// 28-29: Base STR
// 30-31: Base AGI
// 32-33: Base VIT
// 34-35: Base INT
// 36-37: Base LUK
// 38-63: Reserved
FixedPool.ClassTable_Offsets {
    "NAME": Initialize=0
    "HP": Initialize=24
    "MP": Initialize=26
    "STR": Initialize=28
    "AGI": Initialize=30
    "VIT": Initialize=32
    "INT": Initialize=34
    "LUK": Initialize=36
    "SIZE": Initialize=64
}

// ============================================
// INITIALIZATION
// ============================================

Function.Char_Init {
    Body: {
        // Allocate skill table (64 skills max)
        Char_State.skill_table = Allocate(Multiply(64, Skill_Offsets.SIZE))
        Char_State.skill_count = 0
        
        // Allocate level tables (5 classes x 30 levels x 8 bytes)
        table_size = Multiply(Multiply(5, 30), LevelTable_Offsets.SIZE)
        Char_State.level_tables = Allocate(table_size)
        
        // Allocate XP table (30 levels x 4 bytes each)
        Char_State.xp_table = Allocate(Multiply(30, 4))
        
        // Allocate class table (10 classes x 64 bytes)
        Char_State.class_table = Allocate(Multiply(10, ClassTable_Offsets.SIZE))
        Char_State.class_count = 0
        
        // Clear tables
        i = 0
        WhileLoop LessThan(i, table_size) {
            SetByte(Char_State.level_tables, i, 0)
            i = Add(i, 1)
        }
        
        // Clear XP table
        i = 0
        WhileLoop LessThan(i, Multiply(30, 4)) {
            SetByte(Char_State.xp_table, i, 0)
            i = Add(i, 1)
        }
        
        // Clear class table
        i = 0
        WhileLoop LessThan(i, Multiply(10, ClassTable_Offsets.SIZE)) {
            SetByte(Char_State.class_table, i, 0)
            i = Add(i, 1)
        }
        
        Char_State.initialized = 1
        Char_State.data_loaded = 0
        
        ReturnValue(0)
    }
}

// Try to load data from files, fall back to defaults
Function.Char_LoadData {
    Input: data_path: Address
    Output: Integer
    Body: {
        loaded = 0
        
        // Try loading each file
        result = Char_LoadSkillsFile(data_path)
        IfCondition GreaterThan(result, 0) ThenBlock: {
            loaded = Add(loaded, 1)
        } ElseBlock: {
            Char_RegisterDefaultSkills()
        }
        
        result = Char_LoadClassesFile(data_path)
        IfCondition GreaterThan(result, 0) ThenBlock: {
            loaded = Add(loaded, 1)
        } ElseBlock: {
            Char_SetupDefaultClasses()
        }
        
        result = Char_LoadXPTableFile(data_path)
        IfCondition GreaterThan(result, 0) ThenBlock: {
            loaded = Add(loaded, 1)
        } ElseBlock: {
            Char_SetupDefaultXPTable()
        }
        
        result = Char_LoadLevelGainsFile(data_path)
        IfCondition GreaterThan(result, 0) ThenBlock: {
            loaded = Add(loaded, 1)
        } ElseBlock: {
            Char_SetupWarriorLevels()
            Char_SetupMageLevels()
            Char_SetupRogueLevels()
            Char_SetupClericLevels()
            Char_SetupRangerLevels()
        }
        
        IfCondition GreaterThan(loaded, 0) ThenBlock: {
            Char_State.data_loaded = 1
        }
        
        ReturnValue(loaded)
    }
}

// Load with defaults (no files)
Function.Char_LoadDefaults {
    Body: {
        Char_RegisterDefaultSkills()
        Char_SetupDefaultClasses()
        Char_SetupDefaultXPTable()
        Char_SetupWarriorLevels()
        Char_SetupMageLevels()
        Char_SetupRogueLevels()
        Char_SetupClericLevels()
        Char_SetupRangerLevels()
        ReturnValue(0)
    }
}


Function.Char_SetName {
    Input: char_data: Address
    Input: name: Address
    Body: {
        i = 0
        WhileLoop LessThan(i, 23) {
            ch = GetByte(name, i)
            SetByte(char_data, i, ch)
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            i = Add(i, 1)
        }
        SetByte(char_data, 23, 0)  // Ensure null termination
        ReturnValue(0)
    }
}

Function.Char_SetClass {
    Input: char_data: Address
    Input: class_id: Integer
    Body: {
        SetByte(char_data, Char_Offsets.CLASS, class_id)
        ReturnValue(0)
    }
}

Function.Char_SetLevel {
    Input: char_data: Address
    Input: level: Integer
    Body: {
        SetByte(char_data, Char_Offsets.LEVEL, level)
        ReturnValue(0)
    }
}

// ============================================
// DEFAULT XP TABLE
// ============================================

Function.Char_SetupDefaultXPTable {
    Body: {
        // Dragon Warrior inspired curve
        Char_SetXPRequired(2, 20)
        Char_SetXPRequired(3, 40)
        Char_SetXPRequired(4, 80)
        Char_SetXPRequired(5, 150)
        Char_SetXPRequired(6, 250)
        Char_SetXPRequired(7, 400)
        Char_SetXPRequired(8, 600)
        Char_SetXPRequired(9, 850)
        Char_SetXPRequired(10, 1200)
        Char_SetXPRequired(11, 1600)
        Char_SetXPRequired(12, 2100)
        Char_SetXPRequired(13, 2700)
        Char_SetXPRequired(14, 3400)
        Char_SetXPRequired(15, 4200)
        Char_SetXPRequired(16, 5200)
        Char_SetXPRequired(17, 6400)
        Char_SetXPRequired(18, 7800)
        Char_SetXPRequired(19, 9500)
        Char_SetXPRequired(20, 11500)
        Char_SetXPRequired(21, 14000)
        Char_SetXPRequired(22, 17000)
        Char_SetXPRequired(23, 20500)
        Char_SetXPRequired(24, 24500)
        Char_SetXPRequired(25, 29000)
        Char_SetXPRequired(26, 34000)
        Char_SetXPRequired(27, 40000)
        Char_SetXPRequired(28, 47000)
        Char_SetXPRequired(29, 55000)
        Char_SetXPRequired(30, 65000)
        ReturnValue(0)
    }
}

Function.Char_SetXPRequired {
    Input: level: Integer
    Input: xp: Integer
    Body: {
        // Store as 4-byte value
        offset = Multiply(Subtract(level, 1), 4)
        base = Add(Char_State.xp_table, offset)
        SetByte(base, 0, BitwiseAnd(xp, 255))
        SetByte(base, 1, BitwiseAnd(RightShift(xp, 8), 255))
        SetByte(base, 2, BitwiseAnd(RightShift(xp, 16), 255))
        SetByte(base, 3, BitwiseAnd(RightShift(xp, 24), 255))
        ReturnValue(0)
    }
}

// ============================================
// DEFAULT CLASSES
// ============================================

Function.Char_SetupDefaultClasses {
    Body: {
        Char_RegisterClass(1, "Warrior", 30, 5, 12, 8, 12, 6, 8)
        Char_RegisterClass(2, "Mage", 18, 25, 6, 8, 6, 14, 10)
        Char_RegisterClass(3, "Rogue", 22, 12, 8, 14, 8, 8, 12)
        Char_RegisterClass(4, "Cleric", 24, 20, 8, 7, 10, 12, 10)
        Char_RegisterClass(5, "Ranger", 25, 15, 10, 12, 9, 8, 10)
        Char_State.class_count = 5
        ReturnValue(0)
    }
}

Function.Char_RegisterClass {
    Input: id: Integer
    Input: name: Address
    Input: hp: Integer
    Input: mp: Integer
    Input: str: Integer
    Input: agi: Integer
    Input: vit: Integer
    Input: intelligence: Integer
    Input: luk: Integer
    Body: {
        offset = Multiply(Subtract(id, 1), ClassTable_Offsets.SIZE)
        base = Add(Char_State.class_table, offset)
        
        // Copy name
        i = 0
        WhileLoop LessThan(i, 23) {
            ch = GetByte(name, i)
            SetByte(base, i, ch)
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            i = Add(i, 1)
        }
        SetByte(base, 23, 0)
        
        // Set stats
        Char_SetStat16(base, ClassTable_Offsets.HP, hp)
        Char_SetStat16(base, ClassTable_Offsets.MP, mp)
        Char_SetStat16(base, ClassTable_Offsets.STR, str)
        Char_SetStat16(base, ClassTable_Offsets.AGI, agi)
        Char_SetStat16(base, ClassTable_Offsets.VIT, vit)
        Char_SetStat16(base, ClassTable_Offsets.INT, intelligence)
        Char_SetStat16(base, ClassTable_Offsets.LUK, luk)
        
        IfCondition GreaterEqual(id, Char_State.class_count) ThenBlock: {
            Char_State.class_count = id
        }
        
        ReturnValue(0)
    }
}

Function.Char_GetClassName {
    Input: class_id: Integer
    Output: Address
    Body: {
        offset = Multiply(Subtract(class_id, 1), ClassTable_Offsets.SIZE)
        base = Add(Char_State.class_table, offset)
        ReturnValue(base)
    }
}

// ============================================
// FILE LOADING FUNCTIONS
// ============================================

Function.Char_LoadSkillsFile {
    Input: path: Address
    Output: Integer
    Body: {
        // Build path: path/skills.dnddat
        filename = Char_BuildPath(path, "skills.dnddat")
        
        fd = SystemCall(257, -100, filename, 0, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            Deallocate(filename, 256)
            ReturnValue(0)
        }
        
        buffer = Allocate(8192)
        bytes = SystemCall(0, fd, buffer, 8192)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes, 0) ThenBlock: {
            Deallocate(buffer, 8192)
            Deallocate(filename, 256)
            ReturnValue(0)
        }
        
        // Parse CSV: ID,NAME,TYPE,TARGET,MP_COST,POWER,ACCURACY
        count = Char_ParseSkillsCSV(buffer, bytes)
        
        Deallocate(buffer, 8192)
        Deallocate(filename, 256)
        ReturnValue(count)
    }
}

Function.Char_LoadClassesFile {
    Input: path: Address
    Output: Integer
    Body: {
        filename = Char_BuildPath(path, "classes.dnddat")
        
        fd = SystemCall(257, -100, filename, 0, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            Deallocate(filename, 256)
            ReturnValue(0)
        }
        
        buffer = Allocate(4096)
        bytes = SystemCall(0, fd, buffer, 4096)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes, 0) ThenBlock: {
            Deallocate(buffer, 4096)
            Deallocate(filename, 256)
            ReturnValue(0)
        }
        
        count = Char_ParseClassesCSV(buffer, bytes)
        
        Deallocate(buffer, 4096)
        Deallocate(filename, 256)
        ReturnValue(count)
    }
}

Function.Char_LoadXPTableFile {
    Input: path: Address
    Output: Integer
    Body: {
        filename = Char_BuildPath(path, "xp_table.dnddat")
        
        fd = SystemCall(257, -100, filename, 0, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            Deallocate(filename, 256)
            ReturnValue(0)
        }
        
        buffer = Allocate(2048)
        bytes = SystemCall(0, fd, buffer, 2048)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes, 0) ThenBlock: {
            Deallocate(buffer, 2048)
            Deallocate(filename, 256)
            ReturnValue(0)
        }
        
        count = Char_ParseXPTableCSV(buffer, bytes)
        
        Deallocate(buffer, 2048)
        Deallocate(filename, 256)
        ReturnValue(count)
    }
}

Function.Char_LoadLevelGainsFile {
    Input: path: Address
    Output: Integer
    Body: {
        filename = Char_BuildPath(path, "level_gains.dnddat")
        
        fd = SystemCall(257, -100, filename, 0, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            Deallocate(filename, 256)
            ReturnValue(0)
        }
        
        buffer = Allocate(16384)
        bytes = SystemCall(0, fd, buffer, 16384)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes, 0) ThenBlock: {
            Deallocate(buffer, 16384)
            Deallocate(filename, 256)
            ReturnValue(0)
        }
        
        count = Char_ParseLevelGainsCSV(buffer, bytes)
        
        Deallocate(buffer, 16384)
        Deallocate(filename, 256)
        ReturnValue(count)
    }
}

Function.Char_BuildPath {
    Input: base: Address
    Input: file: Address
    Output: Address
    Body: {
        path = Allocate(256)
        pos = 0
        
        // Copy base path if not null
        IfCondition NotEqual(base, 0) ThenBlock: {
            i = 0
            WhileLoop LessThan(i, 200) {
                ch = GetByte(base, i)
                IfCondition EqualTo(ch, 0) ThenBlock: {
                    BreakLoop
                }
                SetByte(path, pos, ch)
                pos = Add(pos, 1)
                i = Add(i, 1)
            }
            
            // Add / if needed
            IfCondition GreaterThan(pos, 0) ThenBlock: {
                last = GetByte(path, Subtract(pos, 1))
                IfCondition NotEqual(last, 47) ThenBlock: {
                    SetByte(path, pos, 47)
                    pos = Add(pos, 1)
                }
            }
        }
        
        // Copy filename
        i = 0
        WhileLoop LessThan(i, 50) {
            ch = GetByte(file, i)
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            SetByte(path, pos, ch)
            pos = Add(pos, 1)
            i = Add(i, 1)
        }
        
        SetByte(path, pos, 0)
        ReturnValue(path)
    }
}

// ============================================
// CSV PARSING HELPERS
// ============================================

Function.Char_ParseInt {
    Input: buffer: Address
    Input: start: Integer
    Input: end: Integer
    Output: Integer
    Body: {
        value = 0
        i = start
        
        WhileLoop LessThan(i, end) {
            ch = GetByte(buffer, i)
            IfCondition And(GreaterEqual(ch, 48), LessEqual(ch, 57)) ThenBlock: {
                value = Add(Multiply(value, 10), Subtract(ch, 48))
            }
            i = Add(i, 1)
        }
        
        ReturnValue(value)
    }
}

Function.Char_ParseSkillsCSV {
    Input: buffer: Address
    Input: length: Integer
    Output: Integer
    Body: {
        count = 0
        pos = 0
        line_start = 0
        
        // Skip header line
        WhileLoop LessThan(pos, length) {
            ch = GetByte(buffer, pos)
            IfCondition EqualTo(ch, 10) ThenBlock: {
                pos = Add(pos, 1)
                line_start = pos
                BreakLoop
            }
            pos = Add(pos, 1)
        }
        
        // Parse each line: ID,NAME,TYPE,TARGET,MP_COST,POWER,ACCURACY
        WhileLoop LessThan(pos, length) {
            ch = GetByte(buffer, pos)
            
            // Skip comment lines
            first_ch = GetByte(buffer, line_start)
            IfCondition EqualTo(first_ch, 35) ThenBlock: {
                // Skip to end of line
                WhileLoop And(LessThan(pos, length), NotEqual(GetByte(buffer, pos), 10)) {
                    pos = Add(pos, 1)
                }
                pos = Add(pos, 1)
                line_start = pos
                ContinueLoop
            }
            
            IfCondition EqualTo(ch, 10) ThenBlock: {
                // Parse line
                IfCondition GreaterThan(pos, line_start) ThenBlock: {
                    result = Char_ParseSkillLine(buffer, line_start, pos)
                    IfCondition GreaterThan(result, 0) ThenBlock: {
                        count = Add(count, 1)
                    }
                }
                pos = Add(pos, 1)
                line_start = pos
            } ElseBlock: {
                pos = Add(pos, 1)
            }
        }
        
        ReturnValue(count)
    }
}

Function.Char_ParseSkillLine {
    Input: buffer: Address
    Input: start: Integer
    Input: end: Integer
    Output: Integer
    Body: {
        // Parse: ID,NAME,TYPE,TARGET,MP_COST,POWER,ACCURACY
        fields = Allocate(56)  // 7 fields x 8 bytes (start, end pairs)
        field_idx = 0
        field_start = start
        pos = start
        
        WhileLoop LessEqual(pos, end) {
            ch = GetByte(buffer, pos)
            IfCondition Or(EqualTo(ch, 44), Or(EqualTo(ch, 10), EqualTo(pos, end))) ThenBlock: {
                // Store field bounds
                StoreValue(Add(fields, Multiply(field_idx, 8)), field_start)
                StoreValue(Add(fields, Add(Multiply(field_idx, 8), 4)), pos)
                field_idx = Add(field_idx, 1)
                field_start = Add(pos, 1)
            }
            pos = Add(pos, 1)
        }
        
        IfCondition LessThan(field_idx, 7) ThenBlock: {
            Deallocate(fields, 56)
            ReturnValue(0)
        }
        
        // Extract values
        id = Char_ParseInt(buffer, Dereference(fields), Dereference(Add(fields, 4)))
        
        // Name - copy to temp buffer
        name = Allocate(24)
        name_start = Dereference(Add(fields, 8))
        name_end = Dereference(Add(fields, 12))
        i = 0
        WhileLoop And(LessThan(i, 20), LessThan(Add(name_start, i), name_end)) {
            SetByte(name, i, GetByte(buffer, Add(name_start, i)))
            i = Add(i, 1)
        }
        SetByte(name, i, 0)
        
        type_val = Char_ParseInt(buffer, Dereference(Add(fields, 16)), Dereference(Add(fields, 20)))
        target = Char_ParseInt(buffer, Dereference(Add(fields, 24)), Dereference(Add(fields, 28)))
        mp_cost = Char_ParseInt(buffer, Dereference(Add(fields, 32)), Dereference(Add(fields, 36)))
        power = Char_ParseInt(buffer, Dereference(Add(fields, 40)), Dereference(Add(fields, 44)))
        accuracy = Char_ParseInt(buffer, Dereference(Add(fields, 48)), Dereference(Add(fields, 52)))
        
        // Register skill
        Char_RegisterSkill(id, name, type_val, target, mp_cost, power, accuracy)
        
        Deallocate(name, 24)
        Deallocate(fields, 56)
        ReturnValue(id)
    }
}

Function.Char_ParseClassesCSV {
    Input: buffer: Address
    Input: length: Integer
    Output: Integer
    Body: {
        count = 0
        pos = 0
        line_start = 0
        
        // Skip header
        WhileLoop LessThan(pos, length) {
            ch = GetByte(buffer, pos)
            IfCondition EqualTo(ch, 10) ThenBlock: {
                pos = Add(pos, 1)
                line_start = pos
                BreakLoop
            }
            pos = Add(pos, 1)
        }
        
        WhileLoop LessThan(pos, length) {
            ch = GetByte(buffer, pos)
            
            IfCondition EqualTo(ch, 10) ThenBlock: {
                IfCondition GreaterThan(pos, line_start) ThenBlock: {
                    result = Char_ParseClassLine(buffer, line_start, pos)
                    IfCondition GreaterThan(result, 0) ThenBlock: {
                        count = Add(count, 1)
                    }
                }
                pos = Add(pos, 1)
                line_start = pos
            } ElseBlock: {
                pos = Add(pos, 1)
            }
        }
        
        Char_State.class_count = count
        ReturnValue(count)
    }
}

Function.Char_ParseClassLine {
    Input: buffer: Address
    Input: start: Integer
    Input: end: Integer
    Output: Integer
    Body: {
        // Parse: ID,NAME,HP,MP,STR,AGI,VIT,INT,LUK
        fields = Allocate(80)
        field_idx = 0
        field_start = start
        pos = start
        
        WhileLoop LessEqual(pos, end) {
            ch = GetByte(buffer, pos)
            IfCondition Or(EqualTo(ch, 44), Or(EqualTo(ch, 10), EqualTo(pos, end))) ThenBlock: {
                StoreValue(Add(fields, Multiply(field_idx, 8)), field_start)
                StoreValue(Add(fields, Add(Multiply(field_idx, 8), 4)), pos)
                field_idx = Add(field_idx, 1)
                field_start = Add(pos, 1)
            }
            pos = Add(pos, 1)
        }
        
        IfCondition LessThan(field_idx, 9) ThenBlock: {
            Deallocate(fields, 80)
            ReturnValue(0)
        }
        
        id = Char_ParseInt(buffer, Dereference(fields), Dereference(Add(fields, 4)))
        
        name = Allocate(24)
        name_start = Dereference(Add(fields, 8))
        name_end = Dereference(Add(fields, 12))
        i = 0
        WhileLoop And(LessThan(i, 20), LessThan(Add(name_start, i), name_end)) {
            SetByte(name, i, GetByte(buffer, Add(name_start, i)))
            i = Add(i, 1)
        }
        SetByte(name, i, 0)
        
        hp = Char_ParseInt(buffer, Dereference(Add(fields, 16)), Dereference(Add(fields, 20)))
        mp = Char_ParseInt(buffer, Dereference(Add(fields, 24)), Dereference(Add(fields, 28)))
        str_val = Char_ParseInt(buffer, Dereference(Add(fields, 32)), Dereference(Add(fields, 36)))
        agi = Char_ParseInt(buffer, Dereference(Add(fields, 40)), Dereference(Add(fields, 44)))
        vit = Char_ParseInt(buffer, Dereference(Add(fields, 48)), Dereference(Add(fields, 52)))
        int_val = Char_ParseInt(buffer, Dereference(Add(fields, 56)), Dereference(Add(fields, 60)))
        luk = Char_ParseInt(buffer, Dereference(Add(fields, 64)), Dereference(Add(fields, 68)))
        
        Char_RegisterClass(id, name, hp, mp, str_val, agi, vit, int_val, luk)
        
        Deallocate(name, 24)
        Deallocate(fields, 80)
        ReturnValue(id)
    }
}

Function.Char_ParseXPTableCSV {
    Input: buffer: Address
    Input: length: Integer
    Output: Integer
    Body: {
        count = 0
        pos = 0
        line_start = 0
        
        // Skip header
        WhileLoop LessThan(pos, length) {
            ch = GetByte(buffer, pos)
            IfCondition EqualTo(ch, 10) ThenBlock: {
                pos = Add(pos, 1)
                line_start = pos
                BreakLoop
            }
            pos = Add(pos, 1)
        }
        
        WhileLoop LessThan(pos, length) {
            ch = GetByte(buffer, pos)
            
            // Skip comments
            first_ch = GetByte(buffer, line_start)
            IfCondition EqualTo(first_ch, 35) ThenBlock: {
                WhileLoop And(LessThan(pos, length), NotEqual(GetByte(buffer, pos), 10)) {
                    pos = Add(pos, 1)
                }
                pos = Add(pos, 1)
                line_start = pos
                ContinueLoop
            }
            
            IfCondition EqualTo(ch, 10) ThenBlock: {
                IfCondition GreaterThan(pos, line_start) ThenBlock: {
                    // Parse LEVEL,XP_REQUIRED
                    comma = line_start
                    WhileLoop LessThan(comma, pos) {
                        IfCondition EqualTo(GetByte(buffer, comma), 44) ThenBlock: {
                            BreakLoop
                        }
                        comma = Add(comma, 1)
                    }
                    
                    level = Char_ParseInt(buffer, line_start, comma)
                    xp = Char_ParseInt(buffer, Add(comma, 1), pos)
                    
                    IfCondition And(GreaterThan(level, 0), LessEqual(level, 30)) ThenBlock: {
                        Char_SetXPRequired(level, xp)
                        count = Add(count, 1)
                    }
                }
                pos = Add(pos, 1)
                line_start = pos
            } ElseBlock: {
                pos = Add(pos, 1)
            }
        }
        
        ReturnValue(count)
    }
}

Function.Char_ParseLevelGainsCSV {
    Input: buffer: Address
    Input: length: Integer
    Output: Integer
    Body: {
        count = 0
        pos = 0
        line_start = 0
        
        // Skip header
        WhileLoop LessThan(pos, length) {
            ch = GetByte(buffer, pos)
            IfCondition EqualTo(ch, 10) ThenBlock: {
                pos = Add(pos, 1)
                line_start = pos
                BreakLoop
            }
            pos = Add(pos, 1)
        }
        
        WhileLoop LessThan(pos, length) {
            ch = GetByte(buffer, pos)
            
            // Skip comments
            first_ch = GetByte(buffer, line_start)
            IfCondition EqualTo(first_ch, 35) ThenBlock: {
                WhileLoop And(LessThan(pos, length), NotEqual(GetByte(buffer, pos), 10)) {
                    pos = Add(pos, 1)
                }
                pos = Add(pos, 1)
                line_start = pos
                ContinueLoop
            }
            
            IfCondition EqualTo(ch, 10) ThenBlock: {
                IfCondition GreaterThan(pos, line_start) ThenBlock: {
                    result = Char_ParseLevelGainLine(buffer, line_start, pos)
                    IfCondition GreaterThan(result, 0) ThenBlock: {
                        count = Add(count, 1)
                    }
                }
                pos = Add(pos, 1)
                line_start = pos
            } ElseBlock: {
                pos = Add(pos, 1)
            }
        }
        
        ReturnValue(count)
    }
}

Function.Char_ParseLevelGainLine {
    Input: buffer: Address
    Input: start: Integer
    Input: end: Integer
    Output: Integer
    Body: {
        // Parse: CLASS,LEVEL,HP,MP,STR,AGI,VIT,INT,SKILL_ID
        fields = Allocate(80)
        field_idx = 0
        field_start = start
        pos = start
        
        WhileLoop LessEqual(pos, end) {
            ch = GetByte(buffer, pos)
            IfCondition Or(EqualTo(ch, 44), Or(EqualTo(ch, 10), EqualTo(pos, end))) ThenBlock: {
                StoreValue(Add(fields, Multiply(field_idx, 8)), field_start)
                StoreValue(Add(fields, Add(Multiply(field_idx, 8), 4)), pos)
                field_idx = Add(field_idx, 1)
                field_start = Add(pos, 1)
            }
            pos = Add(pos, 1)
        }
        
        IfCondition LessThan(field_idx, 9) ThenBlock: {
            Deallocate(fields, 80)
            ReturnValue(0)
        }
        
        class_id = Char_ParseInt(buffer, Dereference(fields), Dereference(Add(fields, 4)))
        level = Char_ParseInt(buffer, Dereference(Add(fields, 8)), Dereference(Add(fields, 12)))
        hp = Char_ParseInt(buffer, Dereference(Add(fields, 16)), Dereference(Add(fields, 20)))
        mp = Char_ParseInt(buffer, Dereference(Add(fields, 24)), Dereference(Add(fields, 28)))
        str_val = Char_ParseInt(buffer, Dereference(Add(fields, 32)), Dereference(Add(fields, 36)))
        agi = Char_ParseInt(buffer, Dereference(Add(fields, 40)), Dereference(Add(fields, 44)))
        vit = Char_ParseInt(buffer, Dereference(Add(fields, 48)), Dereference(Add(fields, 52)))
        int_val = Char_ParseInt(buffer, Dereference(Add(fields, 56)), Dereference(Add(fields, 60)))
        skill_id = Char_ParseInt(buffer, Dereference(Add(fields, 64)), Dereference(Add(fields, 68)))
        
        Char_SetLevelGains(class_id, level, hp, mp, str_val, agi, vit, int_val, skill_id)
        
        Deallocate(fields, 80)
        ReturnValue(1)
    }
}

Function.Char_Cleanup {
    Body: {
        IfCondition NotEqual(Char_State.skill_table, 0) ThenBlock: {
            Deallocate(Char_State.skill_table, Multiply(64, Skill_Offsets.SIZE))
        }
        IfCondition NotEqual(Char_State.level_tables, 0) ThenBlock: {
            table_size = Multiply(Multiply(5, 30), LevelTable_Offsets.SIZE)
            Deallocate(Char_State.level_tables, table_size)
        }
        IfCondition NotEqual(Char_State.xp_table, 0) ThenBlock: {
            Deallocate(Char_State.xp_table, Multiply(30, 4))
        }
        IfCondition NotEqual(Char_State.class_table, 0) ThenBlock: {
            Deallocate(Char_State.class_table, Multiply(10, ClassTable_Offsets.SIZE))
        }
        ReturnValue(0)
    }
}

// ============================================
// SKILL REGISTRATION
// ============================================

Function.Char_RegisterSkill {
    Input: id: Integer
    Input: name: Address
    Input: type: Integer
    Input: target: Integer
    Input: mp_cost: Integer
    Input: power: Integer
    Input: accuracy: Integer
    Body: {
        offset = Multiply(id, Skill_Offsets.SIZE)
        base = Add(Char_State.skill_table, offset)
        
        // Copy name
        i = 0
        WhileLoop LessThan(i, 19) {
            ch = GetByte(name, i)
            SetByte(base, i, ch)
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            i = Add(i, 1)
        }
        SetByte(base, 19, 0)
        
        SetByte(base, Skill_Offsets.TYPE, type)
        SetByte(base, Skill_Offsets.TARGET, target)
        SetByte(base, Skill_Offsets.MP_COST, mp_cost)
        SetByte(base, Skill_Offsets.POWER, power)
        SetByte(base, Skill_Offsets.ACCURACY, accuracy)
        SetByte(base, Skill_Offsets.ELEMENT, 0)
        SetByte(base, Skill_Offsets.STATUS, 0)
        SetByte(base, Skill_Offsets.STATUS_CHANCE, 0)
        
        IfCondition GreaterEqual(id, Char_State.skill_count) ThenBlock: {
            Char_State.skill_count = Add(id, 1)
        }
        
        ReturnValue(0)
    }
}

Function.Char_RegisterDefaultSkills {
    Body: {
        // ID 1: Attack (basic, everyone has it)
        Char_RegisterSkill(1, "Attack", Skill_Types.ATTACK, Skill_Targets.SINGLE_ENEMY, 0, 0, 95)
        
        // Combat Skills (Warrior/Ranger)
        Char_RegisterSkill(2, "Power Strike", Skill_Types.ATTACK, Skill_Targets.SINGLE_ENEMY, 3, 15, 90)
        Char_RegisterSkill(3, "Cleave", Skill_Types.ATTACK, Skill_Targets.ALL_ENEMIES, 5, 10, 85)
        Char_RegisterSkill(4, "Shield Bash", Skill_Types.ATTACK, Skill_Targets.SINGLE_ENEMY, 2, 8, 95)
        Char_RegisterSkill(5, "Berserk", Skill_Types.BUFF, Skill_Targets.SELF, 4, 20, 100)
        
        // Magic Skills (Mage)
        Char_RegisterSkill(10, "Fire", Skill_Types.ATTACK, Skill_Targets.SINGLE_ENEMY, 4, 20, 100)
        Char_RegisterSkill(11, "Ice", Skill_Types.ATTACK, Skill_Targets.SINGLE_ENEMY, 4, 20, 100)
        Char_RegisterSkill(12, "Lightning", Skill_Types.ATTACK, Skill_Targets.SINGLE_ENEMY, 6, 30, 95)
        Char_RegisterSkill(13, "Fireball", Skill_Types.ATTACK, Skill_Targets.ALL_ENEMIES, 8, 25, 90)
        Char_RegisterSkill(14, "Blizzard", Skill_Types.ATTACK, Skill_Targets.ALL_ENEMIES, 10, 35, 85)
        
        // Healing Skills (Cleric)
        Char_RegisterSkill(20, "Heal", Skill_Types.HEAL, Skill_Targets.SINGLE_ALLY, 3, 20, 100)
        Char_RegisterSkill(21, "Cure", Skill_Types.HEAL, Skill_Targets.SINGLE_ALLY, 2, 0, 100)  // Remove status
        Char_RegisterSkill(22, "Heal All", Skill_Types.HEAL, Skill_Targets.ALL_ALLIES, 8, 15, 100)
        Char_RegisterSkill(23, "Revive", Skill_Types.HEAL, Skill_Targets.SINGLE_ALLY, 15, 50, 80)
        Char_RegisterSkill(24, "Bless", Skill_Types.BUFF, Skill_Targets.SINGLE_ALLY, 5, 10, 100)
        
        // Rogue Skills
        Char_RegisterSkill(30, "Backstab", Skill_Types.ATTACK, Skill_Targets.SINGLE_ENEMY, 3, 25, 85)
        Char_RegisterSkill(31, "Poison Blade", Skill_Types.ATTACK, Skill_Targets.SINGLE_ENEMY, 4, 10, 90)
        Char_RegisterSkill(32, "Steal", Skill_Types.UTILITY, Skill_Targets.SINGLE_ENEMY, 0, 0, 60)
        Char_RegisterSkill(33, "Evade", Skill_Types.BUFF, Skill_Targets.SELF, 2, 30, 100)
        Char_RegisterSkill(34, "Critical Eye", Skill_Types.PASSIVE, Skill_Targets.SELF, 0, 10, 100)
        
        // Ranger Skills
        Char_RegisterSkill(40, "Aim", Skill_Types.BUFF, Skill_Targets.SELF, 2, 20, 100)
        Char_RegisterSkill(41, "Multi-Shot", Skill_Types.ATTACK, Skill_Targets.ALL_ENEMIES, 5, 12, 80)
        Char_RegisterSkill(42, "Trap", Skill_Types.DEBUFF, Skill_Targets.SINGLE_ENEMY, 3, 0, 75)
        Char_RegisterSkill(43, "Nature's Gift", Skill_Types.HEAL, Skill_Targets.SELF, 4, 15, 100)
        
        ReturnValue(0)
    }
}

// ============================================
// LEVEL TABLE SETUP
// ============================================

Function.Char_SetLevelGains {
    Input: class_id: Integer
    Input: level: Integer
    Input: hp: Integer
    Input: mp: Integer
    Input: str: Integer
    Input: agi: Integer
    Input: vit: Integer
    Input: intelligence: Integer
    Input: skill_id: Integer
    Body: {
        // Calculate offset: (class-1) * 30 * 8 + (level-1) * 8
        class_offset = Multiply(Subtract(class_id, 1), Multiply(30, LevelTable_Offsets.SIZE))
        level_offset = Multiply(Subtract(level, 1), LevelTable_Offsets.SIZE)
        offset = Add(class_offset, level_offset)
        base = Add(Char_State.level_tables, offset)
        
        SetByte(base, LevelTable_Offsets.HP, hp)
        SetByte(base, LevelTable_Offsets.MP, mp)
        SetByte(base, LevelTable_Offsets.STR, str)
        SetByte(base, LevelTable_Offsets.AGI, agi)
        SetByte(base, LevelTable_Offsets.VIT, vit)
        SetByte(base, LevelTable_Offsets.INT, intelligence)
        SetByte(base, LevelTable_Offsets.SKILL, skill_id)
        
        ReturnValue(0)
    }
}

Function.Char_SetupWarriorLevels {
    Body: {
        c = Char_Classes.WARRIOR
        // Level: HP, MP, STR, AGI, VIT, INT, Skill
        Char_SetLevelGains(c, 1, 0, 0, 0, 0, 0, 0, 1)      // Start: Attack
        Char_SetLevelGains(c, 2, 8, 0, 2, 1, 2, 0, 0)
        Char_SetLevelGains(c, 3, 10, 1, 2, 1, 2, 0, 2)     // Power Strike
        Char_SetLevelGains(c, 4, 10, 0, 3, 1, 2, 0, 0)
        Char_SetLevelGains(c, 5, 12, 1, 3, 1, 3, 0, 4)     // Shield Bash
        Char_SetLevelGains(c, 6, 12, 0, 3, 2, 3, 0, 0)
        Char_SetLevelGains(c, 7, 14, 1, 4, 2, 3, 1, 0)
        Char_SetLevelGains(c, 8, 14, 0, 4, 2, 4, 0, 3)     // Cleave
        Char_SetLevelGains(c, 9, 16, 1, 4, 2, 4, 0, 0)
        Char_SetLevelGains(c, 10, 18, 2, 5, 2, 4, 1, 5)    // Berserk
        // Continue pattern for higher levels...
        ReturnValue(0)
    }
}

Function.Char_SetupMageLevels {
    Body: {
        c = Char_Classes.MAGE
        // Mages: Low HP, High MP, INT focused
        Char_SetLevelGains(c, 1, 0, 0, 0, 0, 0, 0, 1)      // Attack
        Char_SetLevelGains(c, 2, 4, 4, 0, 1, 1, 3, 0)
        Char_SetLevelGains(c, 3, 4, 5, 1, 1, 1, 3, 10)     // Fire
        Char_SetLevelGains(c, 4, 5, 5, 0, 1, 1, 4, 0)
        Char_SetLevelGains(c, 5, 5, 6, 1, 2, 1, 4, 11)     // Ice
        Char_SetLevelGains(c, 6, 6, 6, 0, 2, 1, 4, 0)
        Char_SetLevelGains(c, 7, 6, 7, 1, 2, 2, 5, 12)     // Lightning
        Char_SetLevelGains(c, 8, 6, 8, 0, 2, 2, 5, 0)
        Char_SetLevelGains(c, 9, 7, 8, 1, 2, 2, 6, 0)
        Char_SetLevelGains(c, 10, 8, 10, 1, 3, 2, 6, 13)   // Fireball
        ReturnValue(0)
    }
}

Function.Char_SetupRogueLevels {
    Body: {
        c = Char_Classes.ROGUE
        // Rogues: Medium HP, Low MP, AGI focused
        Char_SetLevelGains(c, 1, 0, 0, 0, 0, 0, 0, 1)
        Char_SetLevelGains(c, 2, 6, 2, 1, 3, 1, 1, 0)
        Char_SetLevelGains(c, 3, 6, 2, 2, 3, 1, 1, 30)     // Backstab
        Char_SetLevelGains(c, 4, 7, 2, 2, 4, 1, 1, 0)
        Char_SetLevelGains(c, 5, 7, 3, 2, 4, 2, 2, 32)     // Steal
        Char_SetLevelGains(c, 6, 8, 3, 2, 4, 2, 2, 0)
        Char_SetLevelGains(c, 7, 8, 3, 3, 5, 2, 2, 33)     // Evade
        Char_SetLevelGains(c, 8, 9, 4, 3, 5, 2, 2, 31)     // Poison Blade
        Char_SetLevelGains(c, 9, 9, 4, 3, 6, 2, 2, 0)
        Char_SetLevelGains(c, 10, 10, 5, 4, 6, 3, 3, 34)   // Critical Eye
        ReturnValue(0)
    }
}

Function.Char_SetupClericLevels {
    Body: {
        c = Char_Classes.CLERIC
        // Clerics: Medium HP, High MP, balanced
        Char_SetLevelGains(c, 1, 0, 0, 0, 0, 0, 0, 1)
        Char_SetLevelGains(c, 2, 6, 4, 1, 1, 2, 2, 20)     // Heal right away!
        Char_SetLevelGains(c, 3, 6, 4, 1, 1, 2, 3, 0)
        Char_SetLevelGains(c, 4, 7, 5, 2, 1, 2, 3, 21)     // Cure
        Char_SetLevelGains(c, 5, 7, 5, 2, 1, 3, 3, 0)
        Char_SetLevelGains(c, 6, 8, 6, 2, 2, 3, 4, 24)     // Bless
        Char_SetLevelGains(c, 7, 8, 6, 2, 2, 3, 4, 0)
        Char_SetLevelGains(c, 8, 9, 7, 2, 2, 3, 4, 0)
        Char_SetLevelGains(c, 9, 9, 8, 2, 2, 4, 5, 22)     // Heal All
        Char_SetLevelGains(c, 10, 10, 10, 3, 2, 4, 5, 23)  // Revive
        ReturnValue(0)
    }
}

Function.Char_SetupRangerLevels {
    Body: {
        c = Char_Classes.RANGER
        // Rangers: Medium HP/MP, AGI/STR balanced
        Char_SetLevelGains(c, 1, 0, 0, 0, 0, 0, 0, 1)
        Char_SetLevelGains(c, 2, 6, 2, 2, 2, 2, 1, 0)
        Char_SetLevelGains(c, 3, 7, 3, 2, 3, 2, 1, 40)     // Aim
        Char_SetLevelGains(c, 4, 7, 3, 2, 3, 2, 1, 0)
        Char_SetLevelGains(c, 5, 8, 3, 3, 3, 2, 2, 42)     // Trap
        Char_SetLevelGains(c, 6, 8, 4, 3, 3, 2, 2, 0)
        Char_SetLevelGains(c, 7, 9, 4, 3, 4, 3, 2, 43)     // Nature's Gift
        Char_SetLevelGains(c, 8, 9, 4, 3, 4, 3, 2, 0)
        Char_SetLevelGains(c, 9, 10, 5, 4, 4, 3, 2, 0)
        Char_SetLevelGains(c, 10, 11, 6, 4, 5, 3, 3, 41)   // Multi-Shot
        ReturnValue(0)
    }
}

// ============================================
// CHARACTER CREATION
// ============================================

Function.Char_Create {
    Input: name: Address
    Input: class_id: Integer
    Output: Address
    Body: {
        // Allocate character
        char_data = Allocate(Char_Offsets.SIZE)
        
        // Clear
        i = 0
        WhileLoop LessThan(i, Char_Offsets.SIZE) {
            SetByte(char_data, i, 0)
            i = Add(i, 1)
        }
        
        // Set name
        i = 0
        WhileLoop LessThan(i, 23) {
            ch = GetByte(name, i)
            SetByte(char_data, i, ch)
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            i = Add(i, 1)
        }
        SetByte(char_data, 23, 0)
        
        // Set class and level
        SetByte(char_data, Char_Offsets.CLASS, class_id)
        SetByte(char_data, Char_Offsets.LEVEL, 1)
        
        // Get base stats from class table
        class_offset = Multiply(Subtract(class_id, 1), ClassTable_Offsets.SIZE)
        class_data = Add(Char_State.class_table, class_offset)
        
        base_hp = Char_GetStat16(class_data, ClassTable_Offsets.HP)
        base_mp = Char_GetStat16(class_data, ClassTable_Offsets.MP)
        base_str = Char_GetStat16(class_data, ClassTable_Offsets.STR)
        base_agi = Char_GetStat16(class_data, ClassTable_Offsets.AGI)
        base_vit = Char_GetStat16(class_data, ClassTable_Offsets.VIT)
        base_int = Char_GetStat16(class_data, ClassTable_Offsets.INT)
        base_luk = Char_GetStat16(class_data, ClassTable_Offsets.LUK)
        
        // Apply to character
        Char_SetStat16(char_data, Char_Offsets.MAX_HP, base_hp)
        Char_SetStat16(char_data, Char_Offsets.MAX_MP, base_mp)
        Char_SetStat16(char_data, Char_Offsets.STR, base_str)
        Char_SetStat16(char_data, Char_Offsets.AGI, base_agi)
        Char_SetStat16(char_data, Char_Offsets.VIT, base_vit)
        Char_SetStat16(char_data, Char_Offsets.INT, base_int)
        Char_SetStat16(char_data, Char_Offsets.LUK, base_luk)
        
        // Set current HP/MP to max
        Char_SetStat16(char_data, Char_Offsets.HP, base_hp)
        Char_SetStat16(char_data, Char_Offsets.MP, base_mp)
        
        // Give starting skill (Attack)
        Char_LearnSkill(char_data, 1)
        
        // Calculate derived stats
        Char_RecalculateStats(char_data)
        
        ReturnValue(char_data)
    }
}

// ============================================
// STAT HELPERS (16-bit read/write)
// ============================================

Function.Char_GetStat16 {
    Input: char_data: Address
    Input: offset: Integer
    Output: Integer
    Body: {
        low = GetByte(char_data, offset)
        high = GetByte(char_data, Add(offset, 1))
        value = Add(low, Multiply(high, 256))
        ReturnValue(value)
    }
}

Function.Char_SetStat16 {
    Input: char_data: Address
    Input: offset: Integer
    Input: value: Integer
    Body: {
        SetByte(char_data, offset, BitwiseAnd(value, 255))
        SetByte(char_data, Add(offset, 1), BitwiseAnd(RightShift(value, 8), 255))
        ReturnValue(0)
    }
}

// ============================================
// DERIVED STATS CALCULATION
// ============================================

Function.Char_RecalculateStats {
    Input: char_data: Address
    Body: {
        str_val = Char_GetStat16(char_data, Char_Offsets.STR)
        agi_val = Char_GetStat16(char_data, Char_Offsets.AGI)
        vit_val = Char_GetStat16(char_data, Char_Offsets.VIT)
        int_val = Char_GetStat16(char_data, Char_Offsets.INT)
        
        // Attack = STR + weapon bonus (weapon bonus added elsewhere)
        attack = str_val
        
        // Defense = VIT / 2 + armor bonus
        defense = Divide(vit_val, 2)
        
        // Speed = AGI (for initiative)
        speed = agi_val
        
        // Magic Attack = INT
        matk = int_val
        
        // Magic Defense = INT / 2 + VIT / 4
        mdef = Add(Divide(int_val, 2), Divide(vit_val, 4))
        
        Char_SetStat16(char_data, Char_Offsets.ATK, attack)
        Char_SetStat16(char_data, Char_Offsets.DEF, defense)
        Char_SetStat16(char_data, Char_Offsets.SPD, speed)
        Char_SetStat16(char_data, Char_Offsets.MATK, matk)
        Char_SetStat16(char_data, Char_Offsets.MDEF, mdef)
        
        ReturnValue(0)
    }
}

// ============================================
// SKILL LEARNING
// ============================================

Function.Char_LearnSkill {
    Input: char_data: Address
    Input: skill_id: Integer
    Output: Integer
    Body: {
        // Check if already known
        skill_count = GetByte(char_data, Char_Offsets.SKILL_COUNT)
        
        i = 0
        WhileLoop LessThan(i, skill_count) {
            offset = Add(Char_Offsets.SKILLS, Multiply(i, 2))
            known_id = Char_GetStat16(char_data, offset)
            IfCondition EqualTo(known_id, skill_id) ThenBlock: {
                ReturnValue(0)  // Already known
            }
            i = Add(i, 1)
        }
        
        // Check if room for more skills
        IfCondition GreaterEqual(skill_count, Char_Limits.MAX_SKILLS) ThenBlock: {
            ReturnValue(-1)  // No room
        }
        
        // Add skill
        offset = Add(Char_Offsets.SKILLS, Multiply(skill_count, 2))
        Char_SetStat16(char_data, offset, skill_id)
        SetByte(char_data, Char_Offsets.SKILL_COUNT, Add(skill_count, 1))
        
        ReturnValue(1)  // Learned!
    }
}

Function.Char_HasSkill {
    Input: char_data: Address
    Input: skill_id: Integer
    Output: Integer
    Body: {
        skill_count = GetByte(char_data, Char_Offsets.SKILL_COUNT)
        
        i = 0
        WhileLoop LessThan(i, skill_count) {
            offset = Add(Char_Offsets.SKILLS, Multiply(i, 2))
            known_id = Char_GetStat16(char_data, offset)
            IfCondition EqualTo(known_id, skill_id) ThenBlock: {
                ReturnValue(1)
            }
            i = Add(i, 1)
        }
        
        ReturnValue(0)
    }
}

Function.Char_GetSkillCount {
    Input: char_data: Address
    Output: Integer
    Body: {
        ReturnValue(GetByte(char_data, Char_Offsets.SKILL_COUNT))
    }
}

Function.Char_GetSkillAt {
    Input: char_data: Address
    Input: index: Integer
    Output: Integer
    Body: {
        offset = Add(Char_Offsets.SKILLS, Multiply(index, 2))
        ReturnValue(Char_GetStat16(char_data, offset))
    }
}

// ============================================
// LEVELING UP
// ============================================

Function.Char_GetXPForLevel {
    Input: level: Integer
    Output: Integer
    Body: {
        // Read from XP table
        IfCondition Or(LessThan(level, 1), GreaterThan(level, 30)) ThenBlock: {
            ReturnValue(999999)
        }
        
        offset = Multiply(Subtract(level, 1), 4)
        base = Add(Char_State.xp_table, offset)
        
        b0 = GetByte(base, 0)
        b1 = GetByte(base, 1)
        b2 = GetByte(base, 2)
        b3 = GetByte(base, 3)
        
        xp = Add(b0, Add(Multiply(b1, 256), Add(Multiply(b2, 65536), Multiply(b3, 16777216))))
        
        // Fallback if not set
        IfCondition EqualTo(xp, 0) ThenBlock: {
            xp = Multiply(Multiply(level, level), 10)
        }
        
        ReturnValue(xp)
    }
}

Function.Char_AddXP {
    Input: char_data: Address
    Input: xp_gained: Integer
    Output: Integer
    Body: {
        current_level = GetByte(char_data, Char_Offsets.LEVEL)
        
        // Add to total XP
        total_xp = Char_GetStat16(char_data, Char_Offsets.TOTAL_XP)
        total_xp = Add(total_xp, xp_gained)
        Char_SetStat16(char_data, Char_Offsets.TOTAL_XP, total_xp)
        
        // Add to current level progress
        current_xp = Char_GetStat16(char_data, Char_Offsets.XP)
        current_xp = Add(current_xp, xp_gained)
        
        // Check for level up
        leveled_up = 0
        xp_needed = Char_GetXPForLevel(Add(current_level, 1))
        
        WhileLoop GreaterEqual(current_xp, xp_needed) {
            // Level up!
            current_xp = Subtract(current_xp, xp_needed)
            current_level = Add(current_level, 1)
            leveled_up = 1
            
            // Apply level gains
            Char_ApplyLevelGains(char_data, current_level)
            
            // Calculate XP for next level
            xp_needed = Char_GetXPForLevel(Add(current_level, 1))
            
            // Cap at max level
            IfCondition GreaterEqual(current_level, Char_Limits.MAX_LEVEL) ThenBlock: {
                current_level = Char_Limits.MAX_LEVEL
                BreakLoop
            }
        }
        
        SetByte(char_data, Char_Offsets.LEVEL, current_level)
        Char_SetStat16(char_data, Char_Offsets.XP, current_xp)
        
        ReturnValue(leveled_up)
    }
}

Function.Char_ApplyLevelGains {
    Input: char_data: Address
    Input: new_level: Integer
    Body: {
        class_id = GetByte(char_data, Char_Offsets.CLASS)
        
        // Get level table entry
        class_offset = Multiply(Subtract(class_id, 1), Multiply(30, LevelTable_Offsets.SIZE))
        level_offset = Multiply(Subtract(new_level, 1), LevelTable_Offsets.SIZE)
        offset = Add(class_offset, level_offset)
        base = Add(Char_State.level_tables, offset)
        
        // Read gains
        hp_gain = GetByte(base, LevelTable_Offsets.HP)
        mp_gain = GetByte(base, LevelTable_Offsets.MP)
        str_gain = GetByte(base, LevelTable_Offsets.STR)
        agi_gain = GetByte(base, LevelTable_Offsets.AGI)
        vit_gain = GetByte(base, LevelTable_Offsets.VIT)
        int_gain = GetByte(base, LevelTable_Offsets.INT)
        skill_id = GetByte(base, LevelTable_Offsets.SKILL)
        
        // Apply stat gains
        max_hp = Char_GetStat16(char_data, Char_Offsets.MAX_HP)
        max_mp = Char_GetStat16(char_data, Char_Offsets.MAX_MP)
        str_val = Char_GetStat16(char_data, Char_Offsets.STR)
        agi_val = Char_GetStat16(char_data, Char_Offsets.AGI)
        vit_val = Char_GetStat16(char_data, Char_Offsets.VIT)
        int_val = Char_GetStat16(char_data, Char_Offsets.INT)
        
        Char_SetStat16(char_data, Char_Offsets.MAX_HP, Add(max_hp, hp_gain))
        Char_SetStat16(char_data, Char_Offsets.MAX_MP, Add(max_mp, mp_gain))
        Char_SetStat16(char_data, Char_Offsets.STR, Add(str_val, str_gain))
        Char_SetStat16(char_data, Char_Offsets.AGI, Add(agi_val, agi_gain))
        Char_SetStat16(char_data, Char_Offsets.VIT, Add(vit_val, vit_gain))
        Char_SetStat16(char_data, Char_Offsets.INT, Add(int_val, int_gain))
        
        // Fully heal on level up
        new_max_hp = Char_GetStat16(char_data, Char_Offsets.MAX_HP)
        new_max_mp = Char_GetStat16(char_data, Char_Offsets.MAX_MP)
        Char_SetStat16(char_data, Char_Offsets.HP, new_max_hp)
        Char_SetStat16(char_data, Char_Offsets.MP, new_max_mp)
        
        // Learn new skill if any
        IfCondition GreaterThan(skill_id, 0) ThenBlock: {
            Char_LearnSkill(char_data, skill_id)
        }
        
        // Recalculate derived stats
        Char_RecalculateStats(char_data)
        
        ReturnValue(0)
    }
}

// ============================================
// ACCESSORS
// ============================================

Function.Char_GetLevel {
    Input: char_data: Address
    Output: Integer
    Body: {
        ReturnValue(GetByte(char_data, Char_Offsets.LEVEL))
    }
}

Function.Char_GetClass {
    Input: char_data: Address
    Output: Integer
    Body: {
        ReturnValue(GetByte(char_data, Char_Offsets.CLASS))
    }
}

Function.Char_GetHP {
    Input: char_data: Address
    Output: Integer
    Body: {
        ReturnValue(Char_GetStat16(char_data, Char_Offsets.HP))
    }
}

Function.Char_GetMaxHP {
    Input: char_data: Address
    Output: Integer
    Body: {
        ReturnValue(Char_GetStat16(char_data, Char_Offsets.MAX_HP))
    }
}

Function.Char_GetMP {
    Input: char_data: Address
    Output: Integer
    Body: {
        ReturnValue(Char_GetStat16(char_data, Char_Offsets.MP))
    }
}

Function.Char_GetMaxMP {
    Input: char_data: Address
    Output: Integer
    Body: {
        ReturnValue(Char_GetStat16(char_data, Char_Offsets.MAX_MP))
    }
}

Function.Char_GetName {
    Input: char_data: Address
    Output: Address
    Body: {
        ReturnValue(char_data)  // Name is at offset 0
    }
}

Function.Char_GetAttack {
    Input: char_data: Address
    Output: Integer
    Body: {
        ReturnValue(Char_GetStat16(char_data, Char_Offsets.ATK))
    }
}

Function.Char_GetDefense {
    Input: char_data: Address
    Output: Integer
    Body: {
        ReturnValue(Char_GetStat16(char_data, Char_Offsets.DEF))
    }
}

// ============================================
// DAMAGE / HEALING
// ============================================

Function.Char_TakeDamage {
    Input: char_data: Address
    Input: damage: Integer
    Output: Integer
    Body: {
        hp = Char_GetStat16(char_data, Char_Offsets.HP)
        hp = Subtract(hp, damage)
        
        IfCondition LessThan(hp, 0) ThenBlock: {
            hp = 0
        }
        
        Char_SetStat16(char_data, Char_Offsets.HP, hp)
        ReturnValue(hp)
    }
}

Function.Char_Heal {
    Input: char_data: Address
    Input: amount: Integer
    Output: Integer
    Body: {
        hp = Char_GetStat16(char_data, Char_Offsets.HP)
        max_hp = Char_GetStat16(char_data, Char_Offsets.MAX_HP)
        
        hp = Add(hp, amount)
        IfCondition GreaterThan(hp, max_hp) ThenBlock: {
            hp = max_hp
        }
        
        Char_SetStat16(char_data, Char_Offsets.HP, hp)
        ReturnValue(hp)
    }
}

Function.Char_UseMana {
    Input: char_data: Address
    Input: cost: Integer
    Output: Integer
    Body: {
        mp = Char_GetStat16(char_data, Char_Offsets.MP)
        
        IfCondition LessThan(mp, cost) ThenBlock: {
            ReturnValue(0)  // Not enough MP
        }
        
        mp = Subtract(mp, cost)
        Char_SetStat16(char_data, Char_Offsets.MP, mp)
        ReturnValue(1)  // Success
    }
}

Function.Char_IsAlive {
    Input: char_data: Address
    Output: Integer
    Body: {
        hp = Char_GetStat16(char_data, Char_Offsets.HP)
        IfCondition GreaterThan(hp, 0) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// ============================================
// MISSING SKILL GETTER FUNCTIONS
// Add these to Library.Character.ailang
// (after Char_RegisterSkill or in a SKILL INFO section)
// ============================================

// Get skill name from skill table
Function.Char_GetSkillName {
    Input: skill_id: Integer
    Output: Address
    Body: {
        IfCondition Or(LessThan(skill_id, 0), GreaterEqual(skill_id, Char_State.skill_count)) ThenBlock: {
            ReturnValue(0)
        }
        offset = Multiply(skill_id, Skill_Offsets.SIZE)
        base = Add(Char_State.skill_table, offset)
        // Name is at offset 0 in skill entry
        ReturnValue(base)
    }
}

// Get skill MP cost
Function.Char_GetSkillMPCost {
    Input: skill_id: Integer
    Output: Integer
    Body: {
        IfCondition Or(LessThan(skill_id, 0), GreaterEqual(skill_id, Char_State.skill_count)) ThenBlock: {
            ReturnValue(0)
        }
        offset = Multiply(skill_id, Skill_Offsets.SIZE)
        base = Add(Char_State.skill_table, offset)
        ReturnValue(GetByte(base, Skill_Offsets.MP_COST))
    }
}

// Get skill type (ATTACK, HEAL, BUFF, etc.)
Function.Char_GetSkillType {
    Input: skill_id: Integer
    Output: Integer
    Body: {
        IfCondition Or(LessThan(skill_id, 0), GreaterEqual(skill_id, Char_State.skill_count)) ThenBlock: {
            ReturnValue(0)
        }
        offset = Multiply(skill_id, Skill_Offsets.SIZE)
        base = Add(Char_State.skill_table, offset)
        ReturnValue(GetByte(base, Skill_Offsets.TYPE))
    }
}

// Get skill power (damage/heal amount)
Function.Char_GetSkillPower {
    Input: skill_id: Integer
    Output: Integer
    Body: {
        IfCondition Or(LessThan(skill_id, 0), GreaterEqual(skill_id, Char_State.skill_count)) ThenBlock: {
            ReturnValue(0)
        }
        offset = Multiply(skill_id, Skill_Offsets.SIZE)
        base = Add(Char_State.skill_table, offset)
        ReturnValue(GetByte(base, Skill_Offsets.POWER))
    }
}

// Get skill accuracy
Function.Char_GetSkillAccuracy {
    Input: skill_id: Integer
    Output: Integer
    Body: {
        IfCondition Or(LessThan(skill_id, 0), GreaterEqual(skill_id, Char_State.skill_count)) ThenBlock: {
            ReturnValue(0)
        }
        offset = Multiply(skill_id, Skill_Offsets.SIZE)
        base = Add(Char_State.skill_table, offset)
        ReturnValue(GetByte(base, Skill_Offsets.ACCURACY))
    }
}

// Get skill target type (SELF, SINGLE_ENEMY, ALL_ENEMIES, etc.)
Function.Char_GetSkillTarget {
    Input: skill_id: Integer
    Output: Integer
    Body: {
        IfCondition Or(LessThan(skill_id, 0), GreaterEqual(skill_id, Char_State.skill_count)) ThenBlock: {
            ReturnValue(0)
        }
        offset = Multiply(skill_id, Skill_Offsets.SIZE)
        base = Add(Char_State.skill_table, offset)
        ReturnValue(GetByte(base, Skill_Offsets.TARGET))
    }
}