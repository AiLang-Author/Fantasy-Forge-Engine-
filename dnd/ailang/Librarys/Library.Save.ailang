// ============================================
// Library.Save.ailang
// Save/Load Game State System
// ============================================
//
// FEATURES:
//   - Party support (up to 4 characters)
//   - Inn checkpoint saves
//   - Multiple save slots
//   - Human-readable INI-like format
//   - Checksum for network/integrity
//   - Quest flags persistence
//
// FILE FORMAT (.dndsav):
//   [HEADER]
//   VERSION=1
//   TIMESTAMP=...
//   CHECKSUM=...
//   
//   [WORLD]
//   MAP_ID=...
//   PLAYER_X=...
//   ...
//
//   [PARTY]
//   COUNT=...
//   GOLD=...
//   
//   [CHAR:0]
//   NAME=...
//   CLASS=...
//   ...
//
//   [INVENTORY]
//   ...
//
//   [FLAGS]
//   quest_dragon=1
//   ...
//
// ============================================

LibraryImport.TUI
LibraryImport.Character
LibraryImport.Item

// ============================================
// CONSTANTS
// ============================================

FixedPool.Save_Limits {
    "MAX_SLOTS": Initialize=3
    "MAX_PARTY": Initialize=4
    "MAX_FLAGS": Initialize=64
    "FLAG_NAME_LEN": Initialize=32
    "MAX_PATH_LEN": Initialize=128
    "BUFFER_SIZE": Initialize=8192
    "VERSION": Initialize=1
}

// ============================================
// SAVE SLOT STRUCTURE (for slot list UI)
// 64 bytes per slot
// ============================================
// 0:     Used flag (1 byte)
// 1:     Party size (1 byte)
// 2-3:   Hours played (2 bytes)
// 4-5:   Lead char level (2 bytes)
// 6-9:   Gold (4 bytes)
// 10:    Map ID (1 byte)
// 11-42: Lead char name (32 bytes)
// 43-62: Location name (20 bytes)
// 63:    Reserved

FixedPool.SlotInfo_Offsets {
    "USED": Initialize=0
    "PARTY_SIZE": Initialize=1
    "HOURS": Initialize=2
    "LEVEL": Initialize=4
    "GOLD": Initialize=6
    "MAP_ID": Initialize=10
    "CHAR_NAME": Initialize=11
    "LOCATION": Initialize=43
    "SIZE": Initialize=64
}

// ============================================
// QUEST FLAGS STRUCTURE
// 36 bytes per flag (32 name + 4 value)
// ============================================

FixedPool.Flag_Offsets {
    "NAME": Initialize=0
    "VALUE": Initialize=32
    "SIZE": Initialize=36
}

// ============================================
// GLOBAL STATE
// ============================================

FixedPool.Save_State {
    "initialized": Initialize=0
    "flags": Initialize=0          
    "flag_count": Initialize=0
    "slot_info": Initialize=0      
    "save_path": Initialize=0      
    "last_inn_map": Initialize=0   
    "last_inn_x": Initialize=0
    "last_inn_y": Initialize=0
    "playtime_seconds": Initialize=0
}

// Temp buffer for building save data
FixedPool.Save_Buffer {
    "data": Initialize=0
    "pos": Initialize=0
    "size": Initialize=0
}

// ============================================
// INITIALIZATION
// ============================================

Function.Save_Init {
    Body: {
        // Allocate quest flags
        flags_size = Multiply(Save_Limits.MAX_FLAGS, Flag_Offsets.SIZE)
        Save_State.flags = Allocate(flags_size)
        Save_State.flag_count = 0
        
        // Clear flags
        i = 0
        WhileLoop LessThan(i, flags_size) {
            SetByte(Save_State.flags, i, 0)
            i = Add(i, 1)
        }
        
        // Allocate slot info cache
        slot_size = Multiply(Save_Limits.MAX_SLOTS, SlotInfo_Offsets.SIZE)
        Save_State.slot_info = Allocate(slot_size)
        
        // Clear slot info
        i = 0
        WhileLoop LessThan(i, slot_size) {
            SetByte(Save_State.slot_info, i, 0)
            i = Add(i, 1)
        }
        
        // Allocate save path
        Save_State.save_path = Allocate(Save_Limits.MAX_PATH_LEN)
        Save_SetPath("saves/")
        
        // Allocate write buffer
        Save_Buffer.data = Allocate(Save_Limits.BUFFER_SIZE)
        Save_Buffer.size = Save_Limits.BUFFER_SIZE
        Save_Buffer.pos = 0
        
        Save_State.initialized = 1
        Save_State.playtime_seconds = 0
        
        ReturnValue(0)
    }
}

Function.Save_Cleanup {
    Body: {
        IfCondition NotEqual(Save_State.flags, 0) ThenBlock: {
            Deallocate(Save_State.flags, Multiply(Save_Limits.MAX_FLAGS, Flag_Offsets.SIZE))
        }
        IfCondition NotEqual(Save_State.slot_info, 0) ThenBlock: {
            Deallocate(Save_State.slot_info, Multiply(Save_Limits.MAX_SLOTS, SlotInfo_Offsets.SIZE))
        }
        IfCondition NotEqual(Save_State.save_path, 0) ThenBlock: {
            Deallocate(Save_State.save_path, Save_Limits.MAX_PATH_LEN)
        }
        IfCondition NotEqual(Save_Buffer.data, 0) ThenBlock: {
            Deallocate(Save_Buffer.data, Save_Limits.BUFFER_SIZE)
        }
        Save_State.initialized = 0
        ReturnValue(0)
    }
}

Function.Save_SetPath {
    Input: path: Address
    Body: {
        i = 0
        WhileLoop LessThan(i, Subtract(Save_Limits.MAX_PATH_LEN, 1)) {
            ch = GetByte(path, i)
            SetByte(Save_State.save_path, i, ch)
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            i = Add(i, 1)
        }
        SetByte(Save_State.save_path, i, 0)
        ReturnValue(0)
    }
}

// ============================================
// QUEST FLAG SYSTEM
// ============================================

Function.Save_SetFlag {
    Input: name: Address
    Input: value: Integer
    Output: Integer
    Body: {
        // Check if flag exists
        idx = Save_FindFlag(name)
        
        IfCondition GreaterEqual(idx, 0) ThenBlock: {
            // Update existing
            offset = Multiply(idx, Flag_Offsets.SIZE)
            base = Add(Save_State.flags, offset)
            Save_WriteInt32(base, Flag_Offsets.VALUE, value)
            ReturnValue(idx)
        }
        
        // Add new flag
        IfCondition GreaterEqual(Save_State.flag_count, Save_Limits.MAX_FLAGS) ThenBlock: {
            ReturnValue(-1)  // Full
        }
        
        idx = Save_State.flag_count
        offset = Multiply(idx, Flag_Offsets.SIZE)
        base = Add(Save_State.flags, offset)
        
        // Copy name
        i = 0
        WhileLoop LessThan(i, Subtract(Save_Limits.FLAG_NAME_LEN, 1)) {
            ch = GetByte(name, i)
            SetByte(base, i, ch)
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            i = Add(i, 1)
        }
        SetByte(base, i, 0)
        
        // Set value
        Save_WriteInt32(base, Flag_Offsets.VALUE, value)
        
        Save_State.flag_count = Add(Save_State.flag_count, 1)
        ReturnValue(idx)
    }
}

Function.Save_GetFlag {
    Input: name: Address
    Output: Integer
    Body: {
        idx = Save_FindFlag(name)
        IfCondition LessThan(idx, 0) ThenBlock: {
            ReturnValue(0)  // Default to 0
        }
        
        offset = Multiply(idx, Flag_Offsets.SIZE)
        base = Add(Save_State.flags, offset)
        ReturnValue(Save_ReadInt32(base, Flag_Offsets.VALUE))
    }
}

Function.Save_FindFlag {
    Input: name: Address
    Output: Integer
    Body: {
        i = 0
        WhileLoop LessThan(i, Save_State.flag_count) {
            offset = Multiply(i, Flag_Offsets.SIZE)
            base = Add(Save_State.flags, offset)
            
            // Compare names
            match = 1
            j = 0
            WhileLoop LessThan(j, Save_Limits.FLAG_NAME_LEN) {
                c1 = GetByte(base, j)
                c2 = GetByte(name, j)
                IfCondition NotEqual(c1, c2) ThenBlock: {
                    match = 0
                    BreakLoop
                }
                IfCondition EqualTo(c1, 0) ThenBlock: {
                    BreakLoop
                }
                j = Add(j, 1)
            }
            
            IfCondition EqualTo(match, 1) ThenBlock: {
                ReturnValue(i)
            }
            
            i = Add(i, 1)
        }
        ReturnValue(-1)
    }
}

// ============================================
// BUFFER WRITE HELPERS
// ============================================

Function.Save_BufClear {
    Body: {
        Save_Buffer.pos = 0
        ReturnValue(0)
    }
}

Function.Save_BufWriteStr {
    Input: str: Address
    Body: {
        i = 0
        WhileLoop LessThan(Save_Buffer.pos, Save_Buffer.size) {
            ch = GetByte(str, i)
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            SetByte(Save_Buffer.data, Save_Buffer.pos, ch)
            Save_Buffer.pos = Add(Save_Buffer.pos, 1)
            i = Add(i, 1)
        }
        ReturnValue(0)
    }
}

Function.Save_BufWriteLine {
    Input: str: Address
    Body: {
        Save_BufWriteStr(str)
        SetByte(Save_Buffer.data, Save_Buffer.pos, 10)  // newline
        Save_Buffer.pos = Add(Save_Buffer.pos, 1)
        ReturnValue(0)
    }
}

Function.Save_BufWriteKV {
    Input: key: Address
    Input: value: Integer
    Body: {
        Save_BufWriteStr(key)
        SetByte(Save_Buffer.data, Save_Buffer.pos, 61)  // '='
        Save_Buffer.pos = Add(Save_Buffer.pos, 1)
        Save_BufWriteInt(value)
        SetByte(Save_Buffer.data, Save_Buffer.pos, 10)  // newline
        Save_Buffer.pos = Add(Save_Buffer.pos, 1)
        ReturnValue(0)
    }
}

Function.Save_BufWriteKVStr {
    Input: key: Address
    Input: value: Address
    Body: {
        Save_BufWriteStr(key)
        SetByte(Save_Buffer.data, Save_Buffer.pos, 61)  // '='
        Save_Buffer.pos = Add(Save_Buffer.pos, 1)
        Save_BufWriteStr(value)
        SetByte(Save_Buffer.data, Save_Buffer.pos, 10)  // newline
        Save_Buffer.pos = Add(Save_Buffer.pos, 1)
        ReturnValue(0)
    }
}

Function.Save_BufWriteInt {
    Input: num: Integer
    Body: {
        // Handle negative
        IfCondition LessThan(num, 0) ThenBlock: {
            SetByte(Save_Buffer.data, Save_Buffer.pos, 45)  // '-'
            Save_Buffer.pos = Add(Save_Buffer.pos, 1)
            num = Subtract(0, num)
        }
        
        // Handle zero
        IfCondition EqualTo(num, 0) ThenBlock: {
            SetByte(Save_Buffer.data, Save_Buffer.pos, 48)  // '0'
            Save_Buffer.pos = Add(Save_Buffer.pos, 1)
            ReturnValue(0)
        }
        
        // Write digits in reverse, then flip
        start = Save_Buffer.pos
        WhileLoop GreaterThan(num, 0) {
            digit = Modulo(num, 10)
            SetByte(Save_Buffer.data, Save_Buffer.pos, Add(48, digit))
            Save_Buffer.pos = Add(Save_Buffer.pos, 1)
            num = Divide(num, 10)
        }
        
        // Reverse the digits
        end = Subtract(Save_Buffer.pos, 1)
        WhileLoop LessThan(start, end) {
            c1 = GetByte(Save_Buffer.data, start)
            c2 = GetByte(Save_Buffer.data, end)
            SetByte(Save_Buffer.data, start, c2)
            SetByte(Save_Buffer.data, end, c1)
            start = Add(start, 1)
            end = Subtract(end, 1)
        }
        
        ReturnValue(0)
    }
}

// ============================================
// INT HELPERS (32-bit storage)
// ============================================

Function.Save_WriteInt32 {
    Input: base: Address
    Input: offset: Integer
    Input: value: Integer
    Body: {
        SetByte(base, offset, BitwiseAnd(value, 255))
        SetByte(base, Add(offset, 1), BitwiseAnd(RightShift(value, 8), 255))
        SetByte(base, Add(offset, 2), BitwiseAnd(RightShift(value, 16), 255))
        SetByte(base, Add(offset, 3), BitwiseAnd(RightShift(value, 24), 255))
        ReturnValue(0)
    }
}

Function.Save_ReadInt32 {
    Input: base: Address
    Input: offset: Integer
    Output: Integer
    Body: {
        b0 = GetByte(base, offset)
        b1 = GetByte(base, Add(offset, 1))
        b2 = GetByte(base, Add(offset, 2))
        b3 = GetByte(base, Add(offset, 3))
        ReturnValue(Add(b0, Add(LeftShift(b1, 8), Add(LeftShift(b2, 16), LeftShift(b3, 24)))))
    }
}

Function.Save_WriteInt16 {
    Input: base: Address
    Input: offset: Integer
    Input: value: Integer
    Body: {
        SetByte(base, offset, BitwiseAnd(value, 255))
        SetByte(base, Add(offset, 1), BitwiseAnd(RightShift(value, 8), 255))
        ReturnValue(0)
    }
}

Function.Save_ReadInt16 {
    Input: base: Address
    Input: offset: Integer
    Output: Integer
    Body: {
        lo = GetByte(base, offset)
        hi = GetByte(base, Add(offset, 1))
        ReturnValue(Add(lo, LeftShift(hi, 8)))
    }
}

// ============================================
// CHECKSUM (simple XOR-based)
// ============================================

Function.Save_ComputeChecksum {
    Input: data: Address
    Input: length: Integer
    Output: Integer
    Body: {
        checksum = 0
        i = 0
        WhileLoop LessThan(i, length) {
            b = GetByte(data, i)
            // Rotate and XOR
            checksum = BitwiseXor(checksum, LeftShift(b, Modulo(i, 24)))
            i = Add(i, 1)
        }
        ReturnValue(checksum)
    }
}

// ============================================
// SAVE GAME - MAIN FUNCTION
// ============================================
// Saves complete game state to file
// party: array of character data pointers (up to 4)
// party_count: number of party members
// For single player, pass party_count=1

Function.Save_Game {
    Input: slot: Integer
    Input: party: Address          // Array of char_data pointers
    Input: party_count: Integer
    Input: player_x: Integer
    Input: player_y: Integer
    Input: map_id: Integer
    Input: gold: Integer
    Input: location_name: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(Save_State.initialized, 0) ThenBlock: {
            ReturnValue(-1)
        }
        
        // Build filename: saves/slot_N.dndsav
        filename = Allocate(64)
        Save_BuildSlotPath(filename, slot)
        
        // Clear buffer
        Save_BufClear()
        
        // ==================
        // [HEADER]
        // ==================
        Save_BufWriteLine("[HEADER]")
        Save_BufWriteKV("VERSION", Save_Limits.VERSION)
        Save_BufWriteKV("SLOT", slot)
        // Timestamp would use time syscall - simplified here
        Save_BufWriteKV("PLAYTIME", Save_State.playtime_seconds)
        Save_BufWriteLine("")
        
        // ==================
        // [WORLD]
        // ==================
        Save_BufWriteLine("[WORLD]")
        Save_BufWriteKV("MAP_ID", map_id)
        Save_BufWriteKV("PLAYER_X", player_x)
        Save_BufWriteKV("PLAYER_Y", player_y)
        Save_BufWriteKV("INN_MAP", Save_State.last_inn_map)
        Save_BufWriteKV("INN_X", Save_State.last_inn_x)
        Save_BufWriteKV("INN_Y", Save_State.last_inn_y)
        Save_BufWriteLine("")
        
        // ==================
        // [PARTY]
        // ==================
        Save_BufWriteLine("[PARTY]")
        Save_BufWriteKV("COUNT", party_count)
        Save_BufWriteKV("GOLD", gold)
        Save_BufWriteLine("")
        
        // ==================
        // [CHAR:N] for each party member
        // ==================
        i = 0
        WhileLoop LessThan(i, party_count) {
            // Get character pointer from array
            char_ptr = Dereference(Add(party, Multiply(i, 8)))  // 8 bytes per pointer
            Save_WriteCharacter(i, char_ptr)
            i = Add(i, 1)
        }
        
        // ==================
        // [INVENTORY]
        // ==================
        Save_WriteInventory()
        
        // ==================
        // [EQUIPMENT] - per character
        // ==================
        Save_WriteEquipment()
        
        // ==================
        // [FLAGS]
        // ==================
        Save_WriteFlags()
        
        // ==================
        // [CHECKSUM]
        // ==================
        checksum = Save_ComputeChecksum(Save_Buffer.data, Save_Buffer.pos)
        Save_BufWriteLine("[CHECKSUM]")
        Save_BufWriteKV("VALUE", checksum)
        
        // Write to file
        fd = SystemCall(257, -100, filename, 577, 420)  // O_WRONLY|O_CREAT|O_TRUNC, 0644
        IfCondition LessThan(fd, 0) ThenBlock: {
            Deallocate(filename, 64)
            ReturnValue(-2)  // Failed to create file
        }
        
        SystemCall(1, fd, Save_Buffer.data, Save_Buffer.pos)
        SystemCall(3, fd)  // close
        
        // Update slot info cache
        Save_UpdateSlotInfo(slot, party, party_count, gold, map_id, location_name)
        
        Deallocate(filename, 64)
        ReturnValue(0)
    }
}

// Single character save (convenience wrapper)
Function.Save_GameSingle {
    Input: slot: Integer
    Input: char_data: Address
    Input: player_x: Integer
    Input: player_y: Integer
    Input: map_id: Integer
    Input: gold: Integer
    Input: location_name: Address
    Output: Integer
    Body: {
        // Create single-element party array on stack
        party = Allocate(8)
        StoreValue(party, char_data)
        
        result = Save_Game(slot, party, 1, player_x, player_y, map_id, gold, location_name)
        
        Deallocate(party, 8)
        ReturnValue(result)
    }
}

// ============================================
// SAVE HELPERS - WRITE SECTIONS
// ============================================

Function.Save_WriteCharacter {
    Input: index: Integer
    Input: char_data: Address
    Body: {
        // Section header [CHAR:N]
        Save_BufWriteStr("[CHAR:")
        Save_BufWriteInt(index)
        Save_BufWriteStr("]")
        SetByte(Save_Buffer.data, Save_Buffer.pos, 10)
        Save_Buffer.pos = Add(Save_Buffer.pos, 1)
        
        // Name
        Save_BufWriteStr("NAME=")
        Save_BufWriteStr(char_data)  // Name is at offset 0
        SetByte(Save_Buffer.data, Save_Buffer.pos, 10)
        Save_Buffer.pos = Add(Save_Buffer.pos, 1)
        
        // Class
        Save_BufWriteKV("CLASS", Char_GetClass(char_data))
        
        // Level
        Save_BufWriteKV("LEVEL", Char_GetLevel(char_data))
        
        // XP
        Save_BufWriteKV("XP", Char_GetStat16(char_data, Char_Offsets.TOTAL_XP))
        
        // Current HP/MP
        Save_BufWriteKV("HP", Char_GetStat16(char_data, Char_Offsets.HP))
        Save_BufWriteKV("MAX_HP", Char_GetStat16(char_data, Char_Offsets.MAX_HP))
        Save_BufWriteKV("MP", Char_GetStat16(char_data, Char_Offsets.MP))
        Save_BufWriteKV("MAX_MP", Char_GetStat16(char_data, Char_Offsets.MAX_MP))
        
        // Base stats
        Save_BufWriteKV("STR", Char_GetStat16(char_data, Char_Offsets.STR))
        Save_BufWriteKV("AGI", Char_GetStat16(char_data, Char_Offsets.AGI))
        Save_BufWriteKV("VIT", Char_GetStat16(char_data, Char_Offsets.VIT))
        Save_BufWriteKV("INT", Char_GetStat16(char_data, Char_Offsets.INT))
        Save_BufWriteKV("LUK", Char_GetStat16(char_data, Char_Offsets.LUK))
        
        // Skills learned (bitmask)
        Save_BufWriteKV("SKILLS", Char_GetStat16(char_data, Char_Offsets.SKILLS))
        
        Save_BufWriteLine("")
        ReturnValue(0)
    }
}

Function.Save_WriteInventory {
    Body: {
        Save_BufWriteLine("[INVENTORY]")
        
        count = Item_InvCount()
        Save_BufWriteKV("COUNT", count)
        
        i = 0
        WhileLoop LessThan(i, count) {
            item_id = Item_InvGetItemId(i)
            quantity = Item_InvGetQuantity(i)
            
            // ITEM_N=id,quantity
            Save_BufWriteStr("ITEM_")
            Save_BufWriteInt(i)
            SetByte(Save_Buffer.data, Save_Buffer.pos, 61)  // '='
            Save_Buffer.pos = Add(Save_Buffer.pos, 1)
            Save_BufWriteInt(item_id)
            SetByte(Save_Buffer.data, Save_Buffer.pos, 44)  // ','
            Save_Buffer.pos = Add(Save_Buffer.pos, 1)
            Save_BufWriteInt(quantity)
            SetByte(Save_Buffer.data, Save_Buffer.pos, 10)
            Save_Buffer.pos = Add(Save_Buffer.pos, 1)
            
            i = Add(i, 1)
        }
        
        Save_BufWriteLine("")
        ReturnValue(0)
    }
}

Function.Save_WriteEquipment {
    Body: {
        Save_BufWriteLine("[EQUIPMENT]")
        
        // Write each slot: SLOT_N=item_id
        slot = 0
        WhileLoop LessThan(slot, 6) {
            item_id = Item_GetEquipped(slot)
            Save_BufWriteStr("SLOT_")
            Save_BufWriteInt(slot)
            SetByte(Save_Buffer.data, Save_Buffer.pos, 61)
            Save_Buffer.pos = Add(Save_Buffer.pos, 1)
            Save_BufWriteInt(item_id)
            SetByte(Save_Buffer.data, Save_Buffer.pos, 10)
            Save_Buffer.pos = Add(Save_Buffer.pos, 1)
            slot = Add(slot, 1)
        }
        
        Save_BufWriteLine("")
        ReturnValue(0)
    }
}

Function.Save_WriteFlags {
    Body: {
        Save_BufWriteLine("[FLAGS]")
        Save_BufWriteKV("COUNT", Save_State.flag_count)
        
        i = 0
        WhileLoop LessThan(i, Save_State.flag_count) {
            offset = Multiply(i, Flag_Offsets.SIZE)
            base = Add(Save_State.flags, offset)
            
            // Write flag_name=value
            Save_BufWriteStr(base)  // Name at offset 0
            SetByte(Save_Buffer.data, Save_Buffer.pos, 61)
            Save_Buffer.pos = Add(Save_Buffer.pos, 1)
            value = Save_ReadInt32(base, Flag_Offsets.VALUE)
            Save_BufWriteInt(value)
            SetByte(Save_Buffer.data, Save_Buffer.pos, 10)
            Save_Buffer.pos = Add(Save_Buffer.pos, 1)
            
            i = Add(i, 1)
        }
        
        Save_BufWriteLine("")
        ReturnValue(0)
    }
}

// ============================================
// SLOT INFO MANAGEMENT
// ============================================

Function.Save_BuildSlotPath {
    Input: dest: Address
    Input: slot: Integer
    Body: {
        // Copy base path
        i = 0
        WhileLoop LessThan(i, Save_Limits.MAX_PATH_LEN) {
            ch = GetByte(Save_State.save_path, i)
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            SetByte(dest, i, ch)
            i = Add(i, 1)
        }
        
        // Add "slot_"
        SetByte(dest, i, 115)  // s
        SetByte(dest, Add(i, 1), 108)  // l
        SetByte(dest, Add(i, 2), 111)  // o
        SetByte(dest, Add(i, 3), 116)  // t
        SetByte(dest, Add(i, 4), 95)   // _
        i = Add(i, 5)
        
        // Add slot number
        SetByte(dest, i, Add(48, slot))  // '0' + slot
        i = Add(i, 1)
        
        // Add extension
        SetByte(dest, i, 46)      // .
        SetByte(dest, Add(i, 1), 100)  // d
        SetByte(dest, Add(i, 2), 110)  // n
        SetByte(dest, Add(i, 3), 100)  // d
        SetByte(dest, Add(i, 4), 115)  // s
        SetByte(dest, Add(i, 5), 97)   // a
        SetByte(dest, Add(i, 6), 118)  // v
        SetByte(dest, Add(i, 7), 0)
        
        ReturnValue(0)
    }
}

Function.Save_UpdateSlotInfo {
    Input: slot: Integer
    Input: party: Address
    Input: party_count: Integer
    Input: gold: Integer
    Input: map_id: Integer
    Input: location_name: Address
    Body: {
        offset = Multiply(slot, SlotInfo_Offsets.SIZE)
        base = Add(Save_State.slot_info, offset)
        
        SetByte(base, SlotInfo_Offsets.USED, 1)
        SetByte(base, SlotInfo_Offsets.PARTY_SIZE, party_count)
        SetByte(base, SlotInfo_Offsets.MAP_ID, map_id)
        
        // Get lead character info
        lead_char = Dereference(party)
        level = Char_GetLevel(lead_char)
        Save_WriteInt16(base, SlotInfo_Offsets.LEVEL, level)
        Save_WriteInt32(base, SlotInfo_Offsets.GOLD, gold)
        
        // Hours played
        hours = Divide(Save_State.playtime_seconds, 3600)
        Save_WriteInt16(base, SlotInfo_Offsets.HOURS, hours)
        
        // Copy lead char name
        i = 0
        WhileLoop LessThan(i, 31) {
            ch = GetByte(lead_char, i)
            SetByte(base, Add(SlotInfo_Offsets.CHAR_NAME, i), ch)
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            i = Add(i, 1)
        }
        SetByte(base, Add(SlotInfo_Offsets.CHAR_NAME, 31), 0)
        
        // Copy location name
        i = 0
        WhileLoop LessThan(i, 19) {
            ch = GetByte(location_name, i)
            SetByte(base, Add(SlotInfo_Offsets.LOCATION, i), ch)
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            i = Add(i, 1)
        }
        SetByte(base, Add(SlotInfo_Offsets.LOCATION, 19), 0)
        
        ReturnValue(0)
    }
}

// ============================================
// LOAD GAME
// ============================================

Function.Save_Load {
    Input: slot: Integer
    Input: party: Address          // Output: array for char_data pointers
    Input: party_count_out: Address // Output: party count
    Input: player_x_out: Address
    Input: player_y_out: Address
    Input: map_id_out: Address
    Input: gold_out: Address
    Output: Integer
    Body: {
        filename = Allocate(64)
        Save_BuildSlotPath(filename, slot)
        
        // Open file
        fd = SystemCall(257, -100, filename, 0, 0)  // O_RDONLY
        IfCondition LessThan(fd, 0) ThenBlock: {
            Deallocate(filename, 64)
            ReturnValue(-1)  // File not found
        }
        
        // Read entire file
        buffer = Allocate(Save_Limits.BUFFER_SIZE)
        bytes = SystemCall(0, fd, buffer, Save_Limits.BUFFER_SIZE)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes, 0) ThenBlock: {
            Deallocate(buffer, Save_Limits.BUFFER_SIZE)
            Deallocate(filename, 64)
            ReturnValue(-2)  // Read error
        }
        
        // Parse the save file
        result = Save_ParseBuffer(buffer, bytes, party, party_count_out, 
                                  player_x_out, player_y_out, map_id_out, gold_out)
        
        Deallocate(buffer, Save_Limits.BUFFER_SIZE)
        Deallocate(filename, 64)
        ReturnValue(result)
    }
}

// Single character load (convenience wrapper)
Function.Save_LoadSingle {
    Input: slot: Integer
    Input: char_data_out: Address  // Output: where to store char_data pointer
    Input: player_x_out: Address
    Input: player_y_out: Address
    Input: map_id_out: Address
    Input: gold_out: Address
    Output: Integer
    Body: {
        party = Allocate(32)  // Room for 4 pointers
        party_count = 0
        
        result = Save_Load(slot, party, AddressOf(party_count),
                          player_x_out, player_y_out, map_id_out, gold_out)
        
        IfCondition GreaterEqual(result, 0) ThenBlock: {
            // Copy first character pointer to output
            StoreValue(char_data_out, Dereference(party))
        }
        
        Deallocate(party, 32)
        ReturnValue(result)
    }
}

// ============================================
// PARSE HELPERS
// ============================================

Function.Save_ParseBuffer {
    Input: buffer: Address
    Input: length: Integer
    Input: party: Address
    Input: party_count_out: Address
    Input: player_x_out: Address
    Input: player_y_out: Address
    Input: map_id_out: Address
    Input: gold_out: Address
    Output: Integer
    Body: {
        pos = 0
        current_section = 0  // 0=none, 1=header, 2=world, 3=party, 4=char, 5=inv, 6=equip, 7=flags
        current_char_idx = 0
        party_count = 0
        
        // Temp storage for values
        temp_key = Allocate(64)
        temp_value = Allocate(256)
        
        WhileLoop LessThan(pos, length) {
            ch = GetByte(buffer, pos)
            
            // Skip whitespace
            IfCondition Or(EqualTo(ch, 32), Or(EqualTo(ch, 9), EqualTo(ch, 13))) ThenBlock: {
                pos = Add(pos, 1)
                ContinueLoop
            }
            
            // Section header
            IfCondition EqualTo(ch, 91) ThenBlock: {  // '['
                pos = Add(pos, 1)
                section_name = Save_ParseUntil(buffer, length, pos, 93)  // ']'
                pos = Add(pos, 1)
                
                current_section = Save_IdentifySection(section_name, AddressOf(current_char_idx))
                
                // If it's a new character, allocate
                IfCondition EqualTo(current_section, 4) ThenBlock: {
                    new_char = Char_Create("", 1)  // Temp name/class
                    StoreValue(Add(party, Multiply(current_char_idx, 8)), new_char)
                    IfCondition GreaterEqual(current_char_idx, party_count) ThenBlock: {
                        party_count = Add(current_char_idx, 1)
                    }
                }
                
                // Skip to end of line
                WhileLoop And(LessThan(pos, length), NotEqual(GetByte(buffer, pos), 10)) {
                    pos = Add(pos, 1)
                }
                pos = Add(pos, 1)
                ContinueLoop
            }
            
            // Comment or empty line
            IfCondition Or(EqualTo(ch, 35), EqualTo(ch, 10)) ThenBlock: {  // '#' or newline
                WhileLoop And(LessThan(pos, length), NotEqual(GetByte(buffer, pos), 10)) {
                    pos = Add(pos, 1)
                }
                pos = Add(pos, 1)
                ContinueLoop
            }
            
            // Key=Value pair
            key_start = pos
            WhileLoop And(LessThan(pos, length), NotEqual(GetByte(buffer, pos), 61)) {
                pos = Add(pos, 1)
            }
            key_len = Subtract(pos, key_start)
            
            // Copy key
            i = 0
            WhileLoop LessThan(i, key_len) {
                SetByte(temp_key, i, GetByte(buffer, Add(key_start, i)))
                i = Add(i, 1)
            }
            SetByte(temp_key, key_len, 0)
            
            pos = Add(pos, 1)  // Skip '='
            
            // Read value until newline
            value_start = pos
            WhileLoop And(LessThan(pos, length), NotEqual(GetByte(buffer, pos), 10)) {
                pos = Add(pos, 1)
            }
            value_len = Subtract(pos, value_start)
            
            // Copy value
            i = 0
            WhileLoop LessThan(i, value_len) {
                SetByte(temp_value, i, GetByte(buffer, Add(value_start, i)))
                i = Add(i, 1)
            }
            SetByte(temp_value, value_len, 0)
            
            pos = Add(pos, 1)  // Skip newline
            
            // Apply value based on section
            Save_ApplyValue(current_section, current_char_idx, temp_key, temp_value,
                           party, player_x_out, player_y_out, map_id_out, gold_out)
        }
        
        // Output party count
        StoreValue(party_count_out, party_count)
        
        Deallocate(temp_key, 64)
        Deallocate(temp_value, 256)
        
        ReturnValue(0)
    }
}

Function.Save_IdentifySection {
    Input: name: Address
    Input: char_idx_out: Address
    Output: Integer
    Body: {
        // Check for known sections
        IfCondition Save_StrEquals(name, "HEADER") ThenBlock: { ReturnValue(1) }
        IfCondition Save_StrEquals(name, "WORLD") ThenBlock: { ReturnValue(2) }
        IfCondition Save_StrEquals(name, "PARTY") ThenBlock: { ReturnValue(3) }
        IfCondition Save_StrEquals(name, "INVENTORY") ThenBlock: { ReturnValue(5) }
        IfCondition Save_StrEquals(name, "EQUIPMENT") ThenBlock: { ReturnValue(6) }
        IfCondition Save_StrEquals(name, "FLAGS") ThenBlock: { ReturnValue(7) }
        IfCondition Save_StrEquals(name, "CHECKSUM") ThenBlock: { ReturnValue(8) }
        
        // Check for CHAR:N
        IfCondition And(EqualTo(GetByte(name, 0), 67), EqualTo(GetByte(name, 4), 58)) ThenBlock: {
            // CHAR:N - extract N
            idx = Subtract(GetByte(name, 5), 48)
            StoreValue(char_idx_out, idx)
            ReturnValue(4)
        }
        
        ReturnValue(0)
    }
}

Function.Save_StrEquals {
    Input: s1: Address
    Input: s2: Address
    Output: Integer
    Body: {
        i = 0
        WhileLoop LessThan(i, 64) {
            c1 = GetByte(s1, i)
            c2 = GetByte(s2, i)
            IfCondition NotEqual(c1, c2) ThenBlock: {
                ReturnValue(0)
            }
            IfCondition EqualTo(c1, 0) ThenBlock: {
                ReturnValue(1)
            }
            i = Add(i, 1)
        }
        ReturnValue(1)
    }
}

Function.Save_ParseInt {
    Input: str: Address
    Output: Integer
    Body: {
        result = 0
        neg = 0
        i = 0
        
        ch = GetByte(str, 0)
        IfCondition EqualTo(ch, 45) ThenBlock: {  // '-'
            neg = 1
            i = 1
        }
        
        WhileLoop LessThan(i, 16) {
            ch = GetByte(str, i)
            IfCondition Or(LessThan(ch, 48), GreaterThan(ch, 57)) ThenBlock: {
                BreakLoop
            }
            result = Add(Multiply(result, 10), Subtract(ch, 48))
            i = Add(i, 1)
        }
        
        IfCondition EqualTo(neg, 1) ThenBlock: {
            result = Subtract(0, result)
        }
        
        ReturnValue(result)
    }
}

Function.Save_ApplyValue {
    Input: section: Integer
    Input: char_idx: Integer
    Input: key: Address
    Input: value: Address
    Input: party: Address
    Input: player_x_out: Address
    Input: player_y_out: Address
    Input: map_id_out: Address
    Input: gold_out: Address
    Body: {
        int_val = Save_ParseInt(value)
        
        // WORLD section
        IfCondition EqualTo(section, 2) ThenBlock: {
            IfCondition Save_StrEquals(key, "MAP_ID") ThenBlock: {
                StoreValue(map_id_out, int_val)
            }
            IfCondition Save_StrEquals(key, "PLAYER_X") ThenBlock: {
                StoreValue(player_x_out, int_val)
            }
            IfCondition Save_StrEquals(key, "PLAYER_Y") ThenBlock: {
                StoreValue(player_y_out, int_val)
            }
            IfCondition Save_StrEquals(key, "INN_MAP") ThenBlock: {
                Save_State.last_inn_map = int_val
            }
            IfCondition Save_StrEquals(key, "INN_X") ThenBlock: {
                Save_State.last_inn_x = int_val
            }
            IfCondition Save_StrEquals(key, "INN_Y") ThenBlock: {
                Save_State.last_inn_y = int_val
            }
        }
        
        // PARTY section
        IfCondition EqualTo(section, 3) ThenBlock: {
            IfCondition Save_StrEquals(key, "GOLD") ThenBlock: {
                StoreValue(gold_out, int_val)
            }
        }
        
        // CHARACTER section
        IfCondition EqualTo(section, 4) ThenBlock: {
            char_data = Dereference(Add(party, Multiply(char_idx, 8)))
            
            IfCondition Save_StrEquals(key, "NAME") ThenBlock: {
                Char_SetName(char_data, value)
            }
            IfCondition Save_StrEquals(key, "CLASS") ThenBlock: {
                Char_SetClass(char_data, int_val)
            }
            IfCondition Save_StrEquals(key, "LEVEL") ThenBlock: {
                Char_SetLevel(char_data, int_val)
            }
            IfCondition Save_StrEquals(key, "XP") ThenBlock: {
                Char_SetStat16(char_data, Char_Offsets.TOTAL_XP, int_val)
            }
            IfCondition Save_StrEquals(key, "HP") ThenBlock: {
                Char_SetStat16(char_data, Char_Offsets.HP, int_val)
            }
            IfCondition Save_StrEquals(key, "MAX_HP") ThenBlock: {
                Char_SetStat16(char_data, Char_Offsets.MAX_HP, int_val)
            }
            IfCondition Save_StrEquals(key, "MP") ThenBlock: {
                Char_SetStat16(char_data, Char_Offsets.MP, int_val)
            }
            IfCondition Save_StrEquals(key, "MAX_MP") ThenBlock: {
                Char_SetStat16(char_data, Char_Offsets.MAX_MP, int_val)
            }
            IfCondition Save_StrEquals(key, "STR") ThenBlock: {
                Char_SetStat16(char_data, Char_Offsets.STR, int_val)
            }
            IfCondition Save_StrEquals(key, "AGI") ThenBlock: {
                Char_SetStat16(char_data, Char_Offsets.AGI, int_val)
            }
            IfCondition Save_StrEquals(key, "VIT") ThenBlock: {
                Char_SetStat16(char_data, Char_Offsets.VIT, int_val)
            }
            IfCondition Save_StrEquals(key, "INT") ThenBlock: {
                Char_SetStat16(char_data, Char_Offsets.INT, int_val)
            }
            IfCondition Save_StrEquals(key, "LUK") ThenBlock: {
                Char_SetStat16(char_data, Char_Offsets.LUK, int_val)
            }
            IfCondition Save_StrEquals(key, "SKILLS") ThenBlock: {
                Char_SetStat16(char_data, Char_Offsets.SKILLS, int_val)
            }
        }
        
        // INVENTORY section - parse ITEM_N=id,qty
        IfCondition EqualTo(section, 5) ThenBlock: {
            IfCondition EqualTo(GetByte(key, 0), 73) ThenBlock: {  // 'I' for ITEM_
                // Parse "id,qty" from value
                item_id = Save_ParseInt(value)
                // Find comma and parse qty
                pos = 0
                WhileLoop NotEqual(GetByte(value, pos), 44) {  // ','
                    pos = Add(pos, 1)
                    IfCondition EqualTo(GetByte(value, pos), 0) ThenBlock: {
                        BreakLoop
                    }
                }
                qty = Save_ParseInt(Add(value, Add(pos, 1)))
                Item_InvAdd(item_id, qty)
            }
        }
        
        // EQUIPMENT section - parse SLOT_N=item_id
        IfCondition EqualTo(section, 6) ThenBlock: {
            IfCondition EqualTo(GetByte(key, 0), 83) ThenBlock: {  // 'S' for SLOT_
                slot_num = Subtract(GetByte(key, 5), 48)
                IfCondition GreaterThan(int_val, 0) ThenBlock: {
                    Item_Equip(slot_num, int_val)
                }
            }
        }
        
        // FLAGS section
        IfCondition EqualTo(section, 7) ThenBlock: {
            IfCondition NotEqual(GetByte(key, 0), 67) ThenBlock: {  // Not COUNT
                Save_SetFlag(key, int_val)
            }
        }
        
        ReturnValue(0)
    }
}

Function.Save_ParseUntil {
    Input: buffer: Address
    Input: length: Integer
    Input: start: Integer
    Input: stop_char: Integer
    Output: Address
    Body: {
        // Returns pointer into buffer at start, null-terminates at stop_char
        // Modifies buffer in place (careful!)
        pos = start
        WhileLoop And(LessThan(pos, length), NotEqual(GetByte(buffer, pos), stop_char)) {
            pos = Add(pos, 1)
        }
        SetByte(buffer, pos, 0)
        ReturnValue(Add(buffer, start))
    }
}

// ============================================
// SLOT MANAGEMENT UI
// ============================================

Function.Save_SlotExists {
    Input: slot: Integer
    Output: Integer
    Body: {
        filename = Allocate(64)
        Save_BuildSlotPath(filename, slot)
        
        fd = SystemCall(257, -100, filename, 0, 0)
        Deallocate(filename, 64)
        
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        SystemCall(3, fd)
        ReturnValue(1)
    }
}

Function.Save_DeleteSlot {
    Input: slot: Integer
    Output: Integer
    Body: {
        filename = Allocate(64)
        Save_BuildSlotPath(filename, slot)
        
        result = SystemCall(87, filename)  // unlink
        
        // Clear slot info
        offset = Multiply(slot, SlotInfo_Offsets.SIZE)
        base = Add(Save_State.slot_info, offset)
        SetByte(base, SlotInfo_Offsets.USED, 0)
        
        Deallocate(filename, 64)
        ReturnValue(result)
    }
}

// ============================================
// INN CHECKPOINT HELPERS
// ============================================

Function.Save_SetInnCheckpoint {
    Input: map_id: Integer
    Input: x: Integer
    Input: y: Integer
    Body: {
        Save_State.last_inn_map = map_id
        Save_State.last_inn_x = x
        Save_State.last_inn_y = y
        ReturnValue(0)
    }
}

Function.Save_GetInnCheckpoint {
    Input: map_id_out: Address
    Input: x_out: Address
    Input: y_out: Address
    Body: {
        StoreValue(map_id_out, Save_State.last_inn_map)
        StoreValue(x_out, Save_State.last_inn_x)
        StoreValue(y_out, Save_State.last_inn_y)
        ReturnValue(0)
    }
}

// ============================================
// PLAYTIME TRACKING
// ============================================

Function.Save_AddPlaytime {
    Input: seconds: Integer
    Body: {
        Save_State.playtime_seconds = Add(Save_State.playtime_seconds, seconds)
        ReturnValue(0)
    }
}

Function.Save_GetPlaytime {
    Output: Integer
    Body: {
        ReturnValue(Save_State.playtime_seconds)
    }
}

// ============================================
// QUICK SAVE/LOAD (auto slot 0)
// ============================================

Function.Save_QuickSave {
    Input: char_data: Address
    Input: player_x: Integer
    Input: player_y: Integer
    Input: map_id: Integer
    Input: gold: Integer
    Output: Integer
    Body: {
        location = "Quick Save"
        ReturnValue(Save_GameSingle(0, char_data, player_x, player_y, map_id, gold, location))
    }
}

Function.Save_QuickLoad {
    Input: char_data_out: Address
    Input: player_x_out: Address
    Input: player_y_out: Address
    Input: map_id_out: Address
    Input: gold_out: Address
    Output: Integer
    Body: {
        ReturnValue(Save_LoadSingle(0, char_data_out, player_x_out, player_y_out, map_id_out, gold_out))
    }
}