// ============================================
// Library.GameConfig.ailang
// Configuration-driven world loading
// ============================================
//
// Loads .dndconf files to define:
//   - Which maps to load
//   - How maps connect (stairs, exits)
//   - Starting conditions
//   - Inns and shops
//
// ============================================

LibraryImport.TUI
LibraryImport.Inn    
LibraryImport.Shop
LibraryImport.Portal
// ============================================
// CONSTANTS
// ============================================

FixedPool.Config_Limits {
    "MAX_MAPS": Initialize=32
    "MAX_CONNECTIONS": Initialize=64
    "MAX_INNS": Initialize=16
    "MAX_SHOPS": Initialize=32
    "MAX_START_ITEMS": Initialize=16
    "MAX_PATH_LEN": Initialize=128
    "MAX_NAME_LEN": Initialize=64
    "BUFFER_SIZE": Initialize=8192
}

// Map entry: 256 bytes each
// 0-127: filepath
// 128-191: display name
// 192: type (1=TOWN, 2=DUNGEON, 3=OVERWORLD, 4=BUILDING, 5=CAVE)
// 193: loaded (0/1)
// 194-255: reserved

FixedPool.MapEntry_Offsets {
    "PATH": Initialize=0
    "NAME": Initialize=128
    "TYPE": Initialize=192
    "LOADED": Initialize=193
    "SIZE": Initialize=256
}

// Connection entry: 16 bytes each
// 0-1: from_map (int16)
FixedPool.Connection_Offsets {
    "FROM_MAP": Initialize=0      
    "FROM_X": Initialize=2        
    "FROM_Y": Initialize=4        
    "TO_MAP": Initialize=6        
    "TO_X": Initialize=8         
    "TO_Y": Initialize=10        
    "SIZE": Initialize=16
}

// Starting item entry: 4 bytes each
// 0-1: item_id (int16)
// 2-3: quantity (int16)
FixedPool.StartItem_Offsets {
    "ID": Initialize=0
    "QTY": Initialize=2
    "SIZE": Initialize=4
}

// Map types
FixedPool.Map_Types {
    "TOWN": Initialize=1
    "DUNGEON": Initialize=2
    "OVERWORLD": Initialize=3
    "BUILDING": Initialize=4
    "CAVE": Initialize=5
}

// ============================================
// STATE
// ============================================

FixedPool.Config_State {
    "maps": Initialize=0
    "map_count": Initialize=0
    "connections": Initialize=0
    "connection_count": Initialize=0
    "world_name": Initialize=0
    "start_map": Initialize=0
    "start_x": Initialize=0
    "start_y": Initialize=0
    "start_gold": Initialize=0
    "start_items": Initialize=0
    "start_item_count": Initialize=0
    "current_map": Initialize=0
    "initialized": Initialize=0
    "config_path": Initialize=0
}

// ============================================
// INITIALIZATION
// ============================================

Function.Config_Init {
    Body: {
        // Allocate maps array
        maps_size = Multiply(Config_Limits.MAX_MAPS, MapEntry_Offsets.SIZE)
        Config_State.maps = Allocate(maps_size)
        Config_State.map_count = 0
        
        // Clear maps
        i = 0
        WhileLoop LessThan(i, maps_size) {
            SetByte(Config_State.maps, i, 0)
            i = Add(i, 1)
        }
        
        // Allocate connections array
        conn_size = Multiply(Config_Limits.MAX_CONNECTIONS, Connection_Offsets.SIZE)
        Config_State.connections = Allocate(conn_size)
        Config_State.connection_count = 0
        
        // Clear connections
        i = 0
        WhileLoop LessThan(i, conn_size) {
            SetByte(Config_State.connections, i, 0)
            i = Add(i, 1)
        }
        
        // Allocate world name
        Config_State.world_name = Allocate(Config_Limits.MAX_NAME_LEN)
        SetByte(Config_State.world_name, 0, 0)
        
        // Allocate config path
        Config_State.config_path = Allocate(Config_Limits.MAX_PATH_LEN)
        
        // Allocate starting items array
        items_size = Multiply(Config_Limits.MAX_START_ITEMS, StartItem_Offsets.SIZE)
        Config_State.start_items = Allocate(items_size)
        Config_State.start_item_count = 0
        
        Config_State.initialized = 1
        ReturnValue(0)
    }
}

Function.Config_Cleanup {
    Body: {
        IfCondition NotEqual(Config_State.maps, 0) ThenBlock: {
            maps_size = Multiply(Config_Limits.MAX_MAPS, MapEntry_Offsets.SIZE)
            Deallocate(Config_State.maps, maps_size)
        }
        IfCondition NotEqual(Config_State.connections, 0) ThenBlock: {
            conn_size = Multiply(Config_Limits.MAX_CONNECTIONS, Connection_Offsets.SIZE)
            Deallocate(Config_State.connections, conn_size)
        }
        IfCondition NotEqual(Config_State.world_name, 0) ThenBlock: {
            Deallocate(Config_State.world_name, Config_Limits.MAX_NAME_LEN)
        }
        IfCondition NotEqual(Config_State.config_path, 0) ThenBlock: {
            Deallocate(Config_State.config_path, Config_Limits.MAX_PATH_LEN)
        }
        IfCondition NotEqual(Config_State.start_items, 0) ThenBlock: {
            items_size = Multiply(Config_Limits.MAX_START_ITEMS, StartItem_Offsets.SIZE)
            Deallocate(Config_State.start_items, items_size)
        }
        Config_State.initialized = 0
        ReturnValue(0)
    }
}

// ============================================
// HELPER FUNCTIONS (must be defined first)
// ============================================

Function.Config_ParseInt {
    Input: str: Address
    Output: Integer
    Body: {
        result = 0
        pos = 0
        WhileLoop NotEqual(GetByte(str, pos), 0) {
            ch = GetByte(str, pos)
            IfCondition And(GreaterEqual(ch, 48), LessEqual(ch, 57)) ThenBlock: {
                result = Add(Multiply(result, 10), Subtract(ch, 48))
            }
            pos = Add(pos, 1)
        }
        ReturnValue(result)
    }
}

Function.Config_ParseMapType {
    Input: str: Address
    Output: Integer
    Body: {
        IfCondition Config_StrEquals(str, "TOWN") ThenBlock: { ReturnValue(Map_Types.TOWN) }
        IfCondition Config_StrEquals(str, "DUNGEON") ThenBlock: { ReturnValue(Map_Types.DUNGEON) }
        IfCondition Config_StrEquals(str, "OVERWORLD") ThenBlock: { ReturnValue(Map_Types.OVERWORLD) }
        IfCondition Config_StrEquals(str, "BUILDING") ThenBlock: { ReturnValue(Map_Types.BUILDING) }
        IfCondition Config_StrEquals(str, "CAVE") ThenBlock: { ReturnValue(Map_Types.CAVE) }
        ReturnValue(Map_Types.DUNGEON)
    }
}

Function.Config_ParseShopType {
    Input: str: Address
    Output: Integer
    Body: {
        IfCondition Config_StrEquals(str, "WEAPON") ThenBlock: { ReturnValue(2) }
        IfCondition Config_StrEquals(str, "ARMOR") ThenBlock: { ReturnValue(3) }
        IfCondition Config_StrEquals(str, "MAGIC") ThenBlock: { ReturnValue(4) }
        IfCondition Config_StrEquals(str, "GENERAL") ThenBlock: { ReturnValue(1) }
        ReturnValue(1)
    }
}

Function.Config_ParseTileType {
    Input: str: Address
    Output: Integer
    Body: {
        IfCondition Config_StrEquals(str, "STAIRS_UP") ThenBlock: { ReturnValue(60) }
        IfCondition Config_StrEquals(str, "STAIRS_DOWN") ThenBlock: { ReturnValue(62) }
        IfCondition Config_StrEquals(str, "EXIT") ThenBlock: { ReturnValue(39) }
        IfCondition Config_StrEquals(str, "DOOR") ThenBlock: { ReturnValue(43) }
        ReturnValue(62)
    }
}

Function.Config_StrEquals {
    Input: a: Address
    Input: b: Address
    Output: Integer
    Body: {
        pos = 0
        WhileLoop 1 {
            ca = GetByte(a, pos)
            cb = GetByte(b, pos)
            IfCondition NotEqual(ca, cb) ThenBlock: { ReturnValue(0) }
            IfCondition EqualTo(ca, 0) ThenBlock: { ReturnValue(1) }
            pos = Add(pos, 1)
        }
        ReturnValue(0)
    }
}

Function.Config_StrStartsWith {
    Input: str: Address
    Input: prefix: Address
    Output: Integer
    Body: {
        pos = 0
        WhileLoop NotEqual(GetByte(prefix, pos), 0) {
            IfCondition NotEqual(GetByte(str, pos), GetByte(prefix, pos)) ThenBlock: {
                ReturnValue(0)
            }
            pos = Add(pos, 1)
        }
        ReturnValue(1)
    }
}

Function.Config_CopyStr {
    Input: src: Address
    Input: dst: Address
    Input: max_len: Integer
    Body: {
        i = 0
        WhileLoop LessThan(i, Subtract(max_len, 1)) {
            ch = GetByte(src, i)
            SetByte(dst, i, ch)
            IfCondition EqualTo(ch, 0) ThenBlock: { BreakLoop }
            i = Add(i, 1)
        }
        SetByte(dst, i, 0)
        ReturnValue(0)
    }
}

Function.Config_ParseKeyValue {
    Input: line: Address
    Input: key_out: Address
    Input: val_out: Address
    Body: {
        pos = 0
        key_pos = 0
        
        // Read key until '='
        WhileLoop And(NotEqual(GetByte(line, pos), 0), NotEqual(GetByte(line, pos), 61)) {
            SetByte(key_out, key_pos, GetByte(line, pos))
            key_pos = Add(key_pos, 1)
            pos = Add(pos, 1)
        }
        SetByte(key_out, key_pos, 0)
        
        // Skip '='
        IfCondition EqualTo(GetByte(line, pos), 61) ThenBlock: {
            pos = Add(pos, 1)
        }
        
        // Read value
        val_pos = 0
        WhileLoop NotEqual(GetByte(line, pos), 0) {
            SetByte(val_out, val_pos, GetByte(line, pos))
            val_pos = Add(val_pos, 1)
            pos = Add(pos, 1)
        }
        SetByte(val_out, val_pos, 0)
        
        ReturnValue(0)
    }
}

// ============================================
// SECTION HANDLERS (must be before ParseBuffer)
// ============================================

Function.Config_HandleWorld {
    Input: key: Address
    Input: value: Address
    Body: {
        IfCondition Config_StrEquals(key, "NAME") ThenBlock: {
            Config_CopyStr(value, Config_State.world_name, Config_Limits.MAX_NAME_LEN)
        }
        ReturnValue(0)
    }
}

Function.Config_HandleStart {
    Input: key: Address
    Input: value: Address
    Body: {
        int_val = Config_ParseInt(value)
        
        IfCondition Config_StrEquals(key, "MAP") ThenBlock: {
            Config_State.start_map = int_val
        }
        IfCondition Config_StrEquals(key, "X") ThenBlock: {
            Config_State.start_x = int_val
        }
        IfCondition Config_StrEquals(key, "Y") ThenBlock: {
            Config_State.start_y = int_val
        }
        IfCondition Config_StrEquals(key, "GOLD") ThenBlock: {
            Config_State.start_gold = int_val
        }
        ReturnValue(0)
    }
}

Function.Config_HandleMapLine {
    Input: line: Address
    Body: {
        // Parse: ID,filepath,type,name
        IfCondition GreaterEqual(Config_State.map_count, Config_Limits.MAX_MAPS) ThenBlock: {
            ReturnValue(-1)
        }
        
        map_idx = Config_State.map_count
        entry_base = Add(Config_State.maps, Multiply(map_idx, MapEntry_Offsets.SIZE))
        
        pos = 0
        field = 0
        field_buf = Allocate(128)
        field_pos = 0
        
        WhileLoop NotEqual(GetByte(line, pos), 0) {
            ch = GetByte(line, pos)
            
            IfCondition EqualTo(ch, 44) ThenBlock: {
                SetByte(field_buf, field_pos, 0)
                
                IfCondition EqualTo(field, 0) ThenBlock: {
                    parsed_id = Config_ParseInt(field_buf)
                }
                IfCondition EqualTo(field, 1) ThenBlock: {
                    Config_CopyStr(field_buf, Add(entry_base, MapEntry_Offsets.PATH), 128)
                }
                IfCondition EqualTo(field, 2) ThenBlock: {
                    map_type = Config_ParseMapType(field_buf)
                    SetByte(entry_base, MapEntry_Offsets.TYPE, map_type)
                }
                
                field = Add(field, 1)
                field_pos = 0
            } ElseBlock: {
                SetByte(field_buf, field_pos, ch)
                field_pos = Add(field_pos, 1)
            }
            pos = Add(pos, 1)
        }
        
        // Last field: name
        SetByte(field_buf, field_pos, 0)
        Config_CopyStr(field_buf, Add(entry_base, MapEntry_Offsets.NAME), 64)
        SetByte(entry_base, MapEntry_Offsets.LOADED, 0)
        
        Deallocate(field_buf, 128)
        
        Config_State.map_count = Add(Config_State.map_count, 1)
        ReturnValue(0)
    }
}

Function.Config_HandleConnectionLine {
    Input: line: Address
    Body: {
        // Parse: from_map,from_x,from_y,to_map,to_x,to_y
        IfCondition GreaterEqual(Config_State.connection_count, Config_Limits.MAX_CONNECTIONS) ThenBlock: {
            ReturnValue(-1)
        }
        
        conn_idx = Config_State.connection_count
        conn_base = Add(Config_State.connections, Multiply(conn_idx, Connection_Offsets.SIZE))
        
        pos = 0
        field = 0
        field_buf = Allocate(64)
        field_pos = 0
        
        WhileLoop NotEqual(GetByte(line, pos), 0) {
            ch = GetByte(line, pos)
            
            IfCondition EqualTo(ch, 44) ThenBlock: {
                SetByte(field_buf, field_pos, 0)
                val = Config_ParseInt(field_buf)
                
                IfCondition EqualTo(field, 0) ThenBlock: {
                    // from_map
                    SetByte(conn_base, Connection_Offsets.FROM_MAP, BitwiseAnd(val, 255))
                    SetByte(conn_base, Add(Connection_Offsets.FROM_MAP, 1), RightShift(val, 8))
                }
                IfCondition EqualTo(field, 1) ThenBlock: {
                    // from_x
                    SetByte(conn_base, Connection_Offsets.FROM_X, BitwiseAnd(val, 255))
                    SetByte(conn_base, Add(Connection_Offsets.FROM_X, 1), RightShift(val, 8))
                }
                IfCondition EqualTo(field, 2) ThenBlock: {
                    // from_y
                    SetByte(conn_base, Connection_Offsets.FROM_Y, BitwiseAnd(val, 255))
                    SetByte(conn_base, Add(Connection_Offsets.FROM_Y, 1), RightShift(val, 8))
                }
                IfCondition EqualTo(field, 3) ThenBlock: {
                    // to_map
                    SetByte(conn_base, Connection_Offsets.TO_MAP, BitwiseAnd(val, 255))
                    SetByte(conn_base, Add(Connection_Offsets.TO_MAP, 1), RightShift(val, 8))
                }
                IfCondition EqualTo(field, 4) ThenBlock: {
                    // to_x
                    SetByte(conn_base, Connection_Offsets.TO_X, BitwiseAnd(val, 255))
                    SetByte(conn_base, Add(Connection_Offsets.TO_X, 1), RightShift(val, 8))
                }
                
                field = Add(field, 1)
                field_pos = 0
            } ElseBlock: {
                SetByte(field_buf, field_pos, ch)
                field_pos = Add(field_pos, 1)
            }
            pos = Add(pos, 1)
        }
        
        // Last field: to_y
        SetByte(field_buf, field_pos, 0)
        val = Config_ParseInt(field_buf)
        SetByte(conn_base, Connection_Offsets.TO_Y, BitwiseAnd(val, 255))
        SetByte(conn_base, Add(Connection_Offsets.TO_Y, 1), RightShift(val, 8))
        
        Deallocate(field_buf, 64)
        
        Config_State.connection_count = Add(Config_State.connection_count, 1)
        ReturnValue(0)
    }
}

Function.Config_HandleInnLine {
    Input: line: Address
    Body: {
        // Parse: map_id,x,y,name,cost,can_save
        pos = 0
        field = 0
        field_buf = Allocate(64)
        field_pos = 0
        
        map_id = 0
        x = 0
        y = 0
        name_buf = Allocate(32)
        cost = 0
        can_save = 0
        
        WhileLoop NotEqual(GetByte(line, pos), 0) {
            ch = GetByte(line, pos)
            
            IfCondition EqualTo(ch, 44) ThenBlock: {
                SetByte(field_buf, field_pos, 0)
                
                IfCondition EqualTo(field, 0) ThenBlock: {
                    map_id = Config_ParseInt(field_buf)
                }
                IfCondition EqualTo(field, 1) ThenBlock: {
                    x = Config_ParseInt(field_buf)
                }
                IfCondition EqualTo(field, 2) ThenBlock: {
                    y = Config_ParseInt(field_buf)
                }
                IfCondition EqualTo(field, 3) ThenBlock: {
                    Config_CopyStr(field_buf, name_buf, 32)
                }
                IfCondition EqualTo(field, 4) ThenBlock: {
                    cost = Config_ParseInt(field_buf)
                }
                
                field = Add(field, 1)
                field_pos = 0
            } ElseBlock: {
                SetByte(field_buf, field_pos, ch)
                field_pos = Add(field_pos, 1)
            }
            pos = Add(pos, 1)
        }
        
        // Last field: can_save
        SetByte(field_buf, field_pos, 0)
        can_save = Config_ParseInt(field_buf)
        
        // Register the inn
        Inn_Register(Inn_State.inn_count, name_buf, cost, map_id, x, y, can_save)
        
        Deallocate(field_buf, 64)
        Deallocate(name_buf, 32)
        ReturnValue(0)
    }
}

Function.Config_HandleShopLine {
    Input: line: Address
    Body: {
        // Parse: map_id,x,y,name,type,buy_rate,sell_rate
        pos = 0
        field = 0
        field_buf = Allocate(64)
        field_pos = 0
        
        map_id = 0
        x = 0
        y = 0
        name_buf = Allocate(32)
        shop_type = 1
        buy_rate = 100
        sell_rate = 50
        
        WhileLoop NotEqual(GetByte(line, pos), 0) {
            ch = GetByte(line, pos)
            
            IfCondition EqualTo(ch, 44) ThenBlock: {
                SetByte(field_buf, field_pos, 0)
                
                IfCondition EqualTo(field, 0) ThenBlock: {
                    map_id = Config_ParseInt(field_buf)
                }
                IfCondition EqualTo(field, 1) ThenBlock: {
                    x = Config_ParseInt(field_buf)
                }
                IfCondition EqualTo(field, 2) ThenBlock: {
                    y = Config_ParseInt(field_buf)
                }
                IfCondition EqualTo(field, 3) ThenBlock: {
                    Config_CopyStr(field_buf, name_buf, 32)
                }
                IfCondition EqualTo(field, 4) ThenBlock: {
                    shop_type = Config_ParseShopType(field_buf)
                }
                IfCondition EqualTo(field, 5) ThenBlock: {
                    buy_rate = Config_ParseInt(field_buf)
                }
                
                field = Add(field, 1)
                field_pos = 0
            } ElseBlock: {
                SetByte(field_buf, field_pos, ch)
                field_pos = Add(field_pos, 1)
            }
            pos = Add(pos, 1)
        }
        
        // Last field: sell_rate
        SetByte(field_buf, field_pos, 0)
        sell_rate = Config_ParseInt(field_buf)
        
        // Register the shop
        Shop_Register(Shop_State.shop_count, name_buf, buy_rate, sell_rate, map_id, x, y, shop_type)
        
        Deallocate(field_buf, 64)
        Deallocate(name_buf, 32)
        ReturnValue(0)
    }
}

Function.Config_HandleItemLine {
    Input: line: Address
    Body: {
        // Parse: item_id,quantity
        IfCondition GreaterEqual(Config_State.start_item_count, Config_Limits.MAX_START_ITEMS) ThenBlock: {
            ReturnValue(-1)
        }
        
        item_idx = Config_State.start_item_count
        item_base = Add(Config_State.start_items, Multiply(item_idx, StartItem_Offsets.SIZE))
        
        pos = 0
        field_buf = Allocate(64)
        field_pos = 0
        
        // Parse item_id
        WhileLoop And(NotEqual(GetByte(line, pos), 0), NotEqual(GetByte(line, pos), 44)) {
            SetByte(field_buf, field_pos, GetByte(line, pos))
            field_pos = Add(field_pos, 1)
            pos = Add(pos, 1)
        }
        SetByte(field_buf, field_pos, 0)
        val = Config_ParseInt(field_buf)
        SetByte(item_base, StartItem_Offsets.ID, BitwiseAnd(val, 255))
        SetByte(item_base, Add(StartItem_Offsets.ID, 1), RightShift(val, 8))
        
        // Skip comma
        IfCondition EqualTo(GetByte(line, pos), 44) ThenBlock: {
            pos = Add(pos, 1)
        }
        
        // Parse quantity
        field_pos = 0
        WhileLoop NotEqual(GetByte(line, pos), 0) {
            SetByte(field_buf, field_pos, GetByte(line, pos))
            field_pos = Add(field_pos, 1)
            pos = Add(pos, 1)
        }
        SetByte(field_buf, field_pos, 0)
        val = Config_ParseInt(field_buf)
        SetByte(item_base, StartItem_Offsets.QTY, BitwiseAnd(val, 255))
        SetByte(item_base, Add(StartItem_Offsets.QTY, 1), RightShift(val, 8))
        
        Deallocate(field_buf, 64)
        
        Config_State.start_item_count = Add(Config_State.start_item_count, 1)
        ReturnValue(0)
    }
}

Function.Config_HandlePortalLine {
    Input: line: Address
    Body: {
        name_a = Allocate(32)
        name_b = Allocate(32)
        
        pos = 0
        name_pos = 0
        
        // Read name_a until comma (ASCII 44) or null
        done = 0
        WhileLoop EqualTo(done, 0) {
            ch = GetByte(line, pos)
            IfCondition EqualTo(ch, 44) ThenBlock: {
                done = 1
            } ElseBlock: {
            IfCondition EqualTo(ch, 0) ThenBlock: {
                done = 1
            } ElseBlock: {
                // Skip whitespace
                is_space = EqualTo(ch, 32)
                is_cr = EqualTo(ch, 13)
                is_lf = EqualTo(ch, 10)
                is_ws = Or(is_space, Or(is_cr, is_lf))
                IfCondition EqualTo(is_ws, 0) ThenBlock: {
                    IfCondition LessThan(name_pos, 31) ThenBlock: {
                        SetByte(name_a, name_pos, ch)
                        name_pos = Add(name_pos, 1)
                    }
                }
                pos = Add(pos, 1)
            }
            }
        }
        SetByte(name_a, name_pos, 0)
        
        // Skip comma
        IfCondition EqualTo(GetByte(line, pos), 44) ThenBlock: {
            pos = Add(pos, 1)
        }
        
        // Read name_b until end
        name_pos = 0
        done = 0
        WhileLoop EqualTo(done, 0) {
            ch = GetByte(line, pos)
            IfCondition EqualTo(ch, 0) ThenBlock: {
                done = 1
            } ElseBlock: {
                is_space = EqualTo(ch, 32)
                is_cr = EqualTo(ch, 13)
                is_lf = EqualTo(ch, 10)
                is_ws = Or(is_space, Or(is_cr, is_lf))
                IfCondition EqualTo(is_ws, 0) ThenBlock: {
                    IfCondition LessThan(name_pos, 31) ThenBlock: {
                        SetByte(name_b, name_pos, ch)
                        name_pos = Add(name_pos, 1)
                    }
                }
                pos = Add(pos, 1)
            }
        }
        SetByte(name_b, name_pos, 0)
        
        // Register the bidirectional link
        Portal_RegisterLink(name_a, name_b)
        
        Deallocate(name_a, 32)
        Deallocate(name_b, 32)
        ReturnValue(0)
    }
}




// ============================================
// BUFFER PARSING (must be before Config_Load)
// ============================================

Function.Config_ParseBuffer {
    Input: buffer: Address
    Input: length: Integer
    Output: Integer
    Body: {
        pos = 0
        section = 0  // 0=none, 1=WORLD, 2=START, 3=MAPS, 4=CONNECTIONS, 5=INNS, 6=SHOPS, 7=ITEMS
        
        line_buf = Allocate(256)
        key_buf = Allocate(64)
        val_buf = Allocate(192)
        
        WhileLoop LessThan(pos, length) {
            // Read line
            line_len = 0
            WhileLoop And(LessThan(pos, length), NotEqual(GetByte(buffer, pos), 10)) {
                ch = GetByte(buffer, pos)
                IfCondition NotEqual(ch, 13) ThenBlock: {
                    SetByte(line_buf, line_len, ch)
                    line_len = Add(line_len, 1)
                }
                pos = Add(pos, 1)
            }
            SetByte(line_buf, line_len, 0)
            pos = Add(pos, 1)
            
            // Skip empty lines and comments
            first_ch = GetByte(line_buf, 0)
            IfCondition Or(EqualTo(first_ch, 0), EqualTo(first_ch, 35)) ThenBlock: {
                // Skip
            } ElseBlock: {
            
            // Check for section headers
            IfCondition EqualTo(first_ch, 91) ThenBlock: {
                IfCondition Config_StrStartsWith(line_buf, "[WORLD]") ThenBlock: { section = 1 }
                IfCondition Config_StrStartsWith(line_buf, "[START]") ThenBlock: { section = 2 }
                IfCondition Config_StrStartsWith(line_buf, "[MAPS]") ThenBlock: { section = 3 }
                IfCondition Config_StrStartsWith(line_buf, "[CONNECTIONS]") ThenBlock: { section = 4 }
                IfCondition Config_StrStartsWith(line_buf, "[INNS]") ThenBlock: { section = 5 }
                IfCondition Config_StrStartsWith(line_buf, "[SHOPS]") ThenBlock: { section = 6 }
                IfCondition Config_StrStartsWith(line_buf, "[ITEMS]") ThenBlock: { section = 7 }
                IfCondition Config_StrStartsWith(line_buf, "[PORTALS]") ThenBlock: { section = 8 }
            } ElseBlock: {
                // Parse based on section
                IfCondition EqualTo(section, 1) ThenBlock: {
                    Config_ParseKeyValue(line_buf, key_buf, val_buf)
                    Config_HandleWorld(key_buf, val_buf)
                }
                IfCondition EqualTo(section, 2) ThenBlock: {
                    Config_ParseKeyValue(line_buf, key_buf, val_buf)
                    Config_HandleStart(key_buf, val_buf)
                }
                IfCondition EqualTo(section, 3) ThenBlock: {
                    Config_HandleMapLine(line_buf)
                }
                IfCondition EqualTo(section, 4) ThenBlock: {
                    Config_HandleConnectionLine(line_buf)
                }
                IfCondition EqualTo(section, 5) ThenBlock: {
                    Config_HandleInnLine(line_buf)
                }
                IfCondition EqualTo(section, 6) ThenBlock: {
                    Config_HandleShopLine(line_buf)
                }
                IfCondition EqualTo(section, 7) ThenBlock: {
                    Config_HandleItemLine(line_buf)
                }
                IfCondition EqualTo(section, 8) ThenBlock: {
                    Config_HandlePortalLine(line_buf)
                }
            }
            }
        }
        
        Deallocate(line_buf, 256)
        Deallocate(key_buf, 64)
        Deallocate(val_buf, 192)
        
        ReturnValue(Config_State.map_count)
    }
}

// ============================================
// FILE LOADING (calls ParseBuffer)
// ============================================

Function.Config_Load {
    Input: filepath: Address
    Output: Integer
    Body: {
        // Copy path
        i = 0
        WhileLoop LessThan(i, Subtract(Config_Limits.MAX_PATH_LEN, 1)) {
            ch = GetByte(filepath, i)
            SetByte(Config_State.config_path, i, ch)
            IfCondition EqualTo(ch, 0) ThenBlock: { BreakLoop }
            i = Add(i, 1)
        }
        SetByte(Config_State.config_path, i, 0)
        
        // Open file
        fd = SystemCall(257, -100, filepath, 0, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(-1)
        }
        
        // Read file
        buffer = Allocate(Config_Limits.BUFFER_SIZE)
        bytes = SystemCall(0, fd, buffer, Config_Limits.BUFFER_SIZE)
        SystemCall(3, fd)
        
        IfCondition LessEqual(bytes, 0) ThenBlock: {
            Deallocate(buffer, Config_Limits.BUFFER_SIZE)
            ReturnValue(-2)
        }
        
        // Parse config
        result = Config_ParseBuffer(buffer, bytes)
        
        Deallocate(buffer, Config_Limits.BUFFER_SIZE)
        ReturnValue(result)
    }
}

// ============================================
// ACCESSOR FUNCTIONS
// ============================================

Function.Config_GetMapPath {
    Input: map_id: Integer
    Output: Address
    Body: {
        IfCondition Or(LessThan(map_id, 0), GreaterEqual(map_id, Config_State.map_count)) ThenBlock: {
            ReturnValue(0)
        }
        entry_base = Add(Config_State.maps, Multiply(map_id, MapEntry_Offsets.SIZE))
        ReturnValue(Add(entry_base, MapEntry_Offsets.PATH))
    }
}

Function.Config_GetMapName {
    Input: map_id: Integer
    Output: Address
    Body: {
        IfCondition Or(LessThan(map_id, 0), GreaterEqual(map_id, Config_State.map_count)) ThenBlock: {
            ReturnValue(0)
        }
        entry_base = Add(Config_State.maps, Multiply(map_id, MapEntry_Offsets.SIZE))
        ReturnValue(Add(entry_base, MapEntry_Offsets.NAME))
    }
}

Function.Config_GetMapType {
    Input: map_id: Integer
    Output: Integer
    Body: {
        IfCondition Or(LessThan(map_id, 0), GreaterEqual(map_id, Config_State.map_count)) ThenBlock: {
            ReturnValue(0)
        }
        entry_base = Add(Config_State.maps, Multiply(map_id, MapEntry_Offsets.SIZE))
        ReturnValue(GetByte(entry_base, MapEntry_Offsets.TYPE))
    }
}

// Find where a tile leads from current map
// Returns: 1 if found (outputs set), 0 if no connection
Function.Config_FindConnection {
    Input: from_map: Integer
    Input: from_x: Integer
    Input: from_y: Integer
    Input: to_map_out: Address
    Input: to_x_out: Address
    Input: to_y_out: Address
    Output: Integer
    Body: {
        i = 0
        WhileLoop LessThan(i, Config_State.connection_count) {
            conn_base = Add(Config_State.connections, Multiply(i, Connection_Offsets.SIZE))
            
            // Read from_map
            conn_from_map = Add(GetByte(conn_base, Connection_Offsets.FROM_MAP),
                               Multiply(GetByte(conn_base, Add(Connection_Offsets.FROM_MAP, 1)), 256))
            
            // Read from_x
            conn_from_x = Add(GetByte(conn_base, Connection_Offsets.FROM_X),
                             Multiply(GetByte(conn_base, Add(Connection_Offsets.FROM_X, 1)), 256))
            
            // Read from_y
            conn_from_y = Add(GetByte(conn_base, Connection_Offsets.FROM_Y),
                             Multiply(GetByte(conn_base, Add(Connection_Offsets.FROM_Y, 1)), 256))
            
            // Check if this connection matches our position
            IfCondition And(EqualTo(conn_from_map, from_map), 
                           And(EqualTo(conn_from_x, from_x), 
                               EqualTo(conn_from_y, from_y))) ThenBlock: {
                // Found match! Extract destination
                to_map = Add(GetByte(conn_base, Connection_Offsets.TO_MAP),
                            Multiply(GetByte(conn_base, Add(Connection_Offsets.TO_MAP, 1)), 256))
                to_x = Add(GetByte(conn_base, Connection_Offsets.TO_X),
                          Multiply(GetByte(conn_base, Add(Connection_Offsets.TO_X, 1)), 256))
                to_y = Add(GetByte(conn_base, Connection_Offsets.TO_Y),
                          Multiply(GetByte(conn_base, Add(Connection_Offsets.TO_Y, 1)), 256))
                
                StoreValue(to_map_out, to_map)
                StoreValue(to_x_out, to_x)
                StoreValue(to_y_out, to_y)
                ReturnValue(1)
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(0)
    }
}